<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACE Calibration Tool (Admin)</title>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <!-- Analysis pipeline modules (same order as production) -->
    <script src="js/signal-filters.js"></script>
    <script src="js/kalman-velocity-estimator.js"></script>
    <script src="js/landmark-filter.js"></script>
    <script src="js/physics-analyzer.js"></script>
    <script src="js/stroke-classifier.js"></script>
    <script src="js/professional-references.js"></script>
    <script src="js/coaching-orchestrator.js"></script>
    <script src="js/phase-detector.js"></script>
    <script src="js/kinetic-chain-analyzer.js"></script>
    <script src="js/motion-sequence-analyzer.js"></script>
    <script src="js/biomechanical-checkpoints.js"></script>
    <script src="js/footwork-analyzer.js"></script>
    <script src="js/serve-analyzer.js"></script>
    <script src="js/enhanced-tennis-analyzer.js"></script>
    <script src="js/calibration-tool.js"></script>
    <script src="js/threshold-updater.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .header {
            background: #111;
            border-bottom: 1px solid #222;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
            color: #A0F0FF;
            letter-spacing: 1px;
        }

        .header .badge {
            background: #A0F0FF;
            color: #0a0a0a;
            font-size: 10px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 4px;
            letter-spacing: 1px;
        }

        .main {
            max-width: 1100px;
            margin: 0 auto;
            padding: 24px;
        }

        .section {
            background: #111;
            border: 1px solid #222;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 2px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 16px;
        }

        /* Metadata form */
        .meta-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }

        .meta-field label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
            letter-spacing: 0.5px;
        }

        .meta-field select,
        .meta-field input {
            width: 100%;
            padding: 8px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 13px;
        }

        .meta-field select:focus,
        .meta-field input:focus {
            outline: none;
            border-color: #A0F0FF;
        }

        /* Upload zone */
        .upload-zone {
            border: 2px dashed #333;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: #A0F0FF;
            background: rgba(160, 240, 255, 0.03);
        }

        .upload-zone .upload-label {
            font-size: 14px;
            font-weight: 600;
            color: #A0F0FF;
            margin-bottom: 6px;
        }

        .upload-zone .upload-hint {
            font-size: 12px;
            color: #555;
        }

        #fileInput { display: none; }

        /* Video queue */
        .queue-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #1a1a1a;
            border: 1px solid #222;
            border-radius: 6px;
            margin-top: 8px;
            font-size: 13px;
        }

        .queue-item .file-name {
            font-weight: 600;
            color: #ccc;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .queue-item .file-meta {
            font-size: 11px;
            color: #555;
            margin-left: 12px;
        }

        .queue-item .file-status {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            padding: 2px 8px;
            border-radius: 4px;
            margin-left: 12px;
        }

        .status-pending { background: #332b00; color: #ffcc00; }
        .status-processing { background: #002233; color: #A0F0FF; }
        .status-complete { background: #003300; color: #66ff66; }
        .status-error { background: #330000; color: #ff6666; }

        .queue-item .file-strokes {
            font-size: 11px;
            color: #888;
            margin-left: 12px;
        }

        .queue-item .remove-btn {
            background: none;
            border: none;
            color: #555;
            cursor: pointer;
            font-size: 16px;
            margin-left: 8px;
            padding: 0 4px;
        }

        .queue-item .remove-btn:hover { color: #ff6666; }

        /* Progress */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
            margin: 12px 0 8px;
        }

        .progress-fill {
            height: 100%;
            background: #A0F0FF;
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
        }

        /* Buttons */
        .btn {
            padding: 8px 20px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a1a;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: #A0F0FF;
            color: #A0F0FF;
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #A0F0FF;
            color: #0a0a0a;
            border-color: #A0F0FF;
        }

        .btn-primary:hover {
            background: #80d8e8;
            border-color: #80d8e8;
            color: #0a0a0a;
        }

        .btn-danger {
            border-color: #ff4444;
            color: #ff4444;
        }

        .btn-danger:hover {
            background: #ff4444;
            color: #0a0a0a;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        /* Results */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 12px;
        }

        .result-card {
            background: #1a1a1a;
            border: 1px solid #222;
            border-radius: 6px;
            padding: 16px;
        }

        .result-card h3 {
            font-size: 13px;
            font-weight: 700;
            color: #A0F0FF;
            letter-spacing: 1px;
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 3px 0;
            border-bottom: 1px solid #1e1e1e;
        }

        .metric-label { color: #666; }
        .metric-value { color: #ccc; font-weight: 600; font-variant-numeric: tabular-nums; }

        .metric-row.header-row {
            border-bottom: 1px solid #333;
            margin-top: 8px;
            padding-top: 8px;
        }

        .metric-row.header-row .metric-label {
            color: #aaa;
            font-weight: 700;
        }

        /* Log console */
        .log-console {
            background: #0d0d0d;
            border: 1px solid #222;
            border-radius: 6px;
            padding: 12px;
            font-size: 11px;
            max-height: 250px;
            overflow-y: auto;
            line-height: 1.6;
            color: #4a4;
        }

        .log-console .log-time { color: #555; }
        .log-console .log-stroke { color: #A0F0FF; }
        .log-console .log-error { color: #f66; }
        .log-console .log-info { color: #4a4; }

        /* Aggregate summary */
        .agg-stats {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .agg-stat {
            background: #1a1a1a;
            border: 1px solid #222;
            border-radius: 6px;
            padding: 12px 16px;
            text-align: center;
            min-width: 100px;
        }

        .agg-stat .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #A0F0FF;
        }

        .agg-stat .stat-label {
            font-size: 10px;
            color: #555;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ACE CALIBRATION TOOL</h1>
        <span class="badge">ADMIN</span>
    </div>

    <div class="main">
        <!-- 1. Metadata -->
        <div class="section">
            <div class="section-title">Video Metadata</div>
            <div class="meta-grid">
                <div class="meta-field">
                    <label>NTRP Level</label>
                    <select id="metaNtrp">
                        <option value="2.0">2.0</option>
                        <option value="2.5">2.5</option>
                        <option value="3.0">3.0</option>
                        <option value="3.5">3.5</option>
                        <option value="4.0" selected>4.0</option>
                        <option value="4.5">4.5</option>
                        <option value="5.0">5.0</option>
                        <option value="professional">Professional</option>
                    </select>
                </div>
                <div class="meta-field">
                    <label>Camera Angle</label>
                    <select id="metaCamera">
                        <option value="behind_baseline">Behind Baseline</option>
                        <option value="side_court">Side Court</option>
                        <option value="elevated">Elevated</option>
                        <option value="mixed">Mixed</option>
                    </select>
                </div>
                <div class="meta-field">
                    <label>Handedness</label>
                    <select id="metaHand">
                        <option value="right">Right</option>
                        <option value="left">Left</option>
                        <option value="unknown">Unknown (auto-detect)</option>
                    </select>
                </div>
                <div class="meta-field">
                    <label>Video Speed</label>
                    <select id="metaSpeed">
                        <option value="1">Real-time (1x)</option>
                        <option value="0.5">0.5x Slow-mo</option>
                        <option value="0.25">0.25x Slow-mo</option>
                    </select>
                </div>
                <div class="meta-field">
                    <label>Player Name</label>
                    <input type="text" id="metaPlayer" placeholder="e.g., Djokovic">
                </div>
                <div class="meta-field">
                    <label>Notes</label>
                    <input type="text" id="metaNotes" placeholder="e.g., practice session, match point">
                </div>
            </div>
        </div>

        <!-- 2. Upload -->
        <div class="section">
            <div class="section-title">Upload Videos</div>
            <div class="upload-zone" id="uploadZone">
                <div class="upload-label">Click or drag & drop video files</div>
                <div class="upload-hint">Upload real-time or slow-motion tennis footage. MP4, MOV, WebM supported. Multiple files allowed.</div>
            </div>
            <input type="file" id="fileInput" accept="video/*" multiple>
            <div id="videoQueue"></div>
        </div>

        <!-- 3. Process -->
        <div class="section">
            <div class="section-title">Process</div>
            <div class="btn-row">
                <button class="btn btn-primary" id="processBtn" disabled>START CALIBRATION</button>
                <button class="btn" id="cancelBtn" disabled>CANCEL</button>
                <button class="btn btn-danger" id="clearBtn">CLEAR ALL</button>
            </div>
            <div id="progressSection" class="hidden">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText"></div>
            </div>
        </div>

        <!-- 4. Results -->
        <div class="section hidden" id="resultsSection">
            <div class="section-title">Results</div>
            <div class="agg-stats" id="aggStats"></div>
            <div class="results-grid" id="resultsGrid"></div>
            <div class="btn-row">
                <button class="btn" id="exportJsonBtn">EXPORT JSON</button>
                <button class="btn" id="exportCodeBtn">EXPORT THRESHOLD CODE</button>
                <button class="btn" id="consoleStatsBtn">VIEW CONSOLE STATS</button>
            </div>
        </div>

        <!-- 5. Log -->
        <div class="section">
            <div class="section-title">Log</div>
            <div class="log-console" id="logConsole">
                <div><span class="log-time">[--:--:--]</span> <span class="log-info">Ready. Add videos and click START CALIBRATION.</span></div>
            </div>
        </div>
    </div>

    <script>
    // NTRP → label mapping
    function ntrpToLabel(ntrp) {
        if (ntrp === 'professional') return 'professional';
        const n = parseFloat(ntrp);
        if (n <= 2.5) return 'beginner';
        if (n <= 3.5) return 'intermediate';
        if (n <= 4.5) return 'advanced';
        return 'professional';
    }

    // ============ State ============
    let calibrationTool = null;
    let videoQueue = [];  // [{file, name, size, status, strokeCount}]
    let isProcessing = false;

    // ============ DOM refs ============
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const queueEl = document.getElementById('videoQueue');
    const processBtn = document.getElementById('processBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const clearBtn = document.getElementById('clearBtn');
    const progressSection = document.getElementById('progressSection');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const resultsSection = document.getElementById('resultsSection');
    const aggStatsEl = document.getElementById('aggStats');
    const resultsGrid = document.getElementById('resultsGrid');
    const logConsole = document.getElementById('logConsole');

    // ============ Logging ============
    function log(msg, type = 'info') {
        const time = new Date().toLocaleTimeString();
        const div = document.createElement('div');
        div.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-${type}">${msg}</span>`;
        logConsole.appendChild(div);
        logConsole.scrollTop = logConsole.scrollHeight;
        console.log(`[${type}] ${msg}`);
    }

    // ============ Upload ============
    uploadZone.addEventListener('click', () => fileInput.click());

    uploadZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadZone.classList.add('dragover');
    });

    uploadZone.addEventListener('dragleave', () => {
        uploadZone.classList.remove('dragover');
    });

    uploadZone.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadZone.classList.remove('dragover');
        addFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener('change', (e) => {
        addFiles(e.target.files);
        fileInput.value = '';
    });

    function addFiles(files) {
        let added = 0;
        for (const file of files) {
            if (file.type.startsWith('video/')) {
                videoQueue.push({
                    file,
                    name: file.name,
                    size: formatSize(file.size),
                    status: 'pending',
                    strokeCount: 0,
                    results: null
                });
                added++;
            }
        }
        if (added > 0) {
            log(`Added ${added} video(s) to queue`);
            renderQueue();
            updateButtons();
        }
    }

    function removeFromQueue(index) {
        if (isProcessing) return;
        videoQueue.splice(index, 1);
        renderQueue();
        updateButtons();
    }

    function renderQueue() {
        if (videoQueue.length === 0) {
            queueEl.innerHTML = '';
            return;
        }
        queueEl.innerHTML = videoQueue.map((v, i) => `
            <div class="queue-item">
                <span class="file-name">${v.name}</span>
                <span class="file-meta">${v.size}</span>
                ${v.strokeCount > 0 ? `<span class="file-strokes">${v.strokeCount} strokes</span>` : ''}
                <span class="file-status status-${v.status}">${v.status.toUpperCase()}</span>
                ${v.status === 'pending' ? `<button class="remove-btn" onclick="removeFromQueue(${i})">&times;</button>` : ''}
            </div>
        `).join('');
    }

    function updateButtons() {
        const hasPending = videoQueue.some(v => v.status === 'pending');
        processBtn.disabled = !hasPending || isProcessing;
        cancelBtn.disabled = !isProcessing;
    }

    // ============ Processing ============
    processBtn.addEventListener('click', startProcessing);
    cancelBtn.addEventListener('click', () => {
        if (calibrationTool) calibrationTool.cancel();
        isProcessing = false;
        updateButtons();
        log('Cancelled by user', 'error');
    });

    clearBtn.addEventListener('click', () => {
        if (isProcessing) return;
        videoQueue = [];
        renderQueue();
        updateButtons();
        resultsSection.classList.add('hidden');
        progressSection.classList.add('hidden');
        if (calibrationTool) calibrationTool.clearAllData();
        log('Cleared all data');
    });

    async function startProcessing() {
        isProcessing = true;
        updateButtons();
        progressSection.classList.remove('hidden');

        // Read metadata
        const ntrpLevel = document.getElementById('metaNtrp').value;
        const label = ntrpToLabel(ntrpLevel);
        const cameraAngle = document.getElementById('metaCamera').value;
        const handedness = document.getElementById('metaHand').value;
        const videoSpeed = parseFloat(document.getElementById('metaSpeed').value);
        const player = document.getElementById('metaPlayer').value || 'unknown';
        const notes = document.getElementById('metaNotes').value;

        log(`Metadata: NTRP=${ntrpLevel} (${label}), camera=${cameraAngle}, hand=${handedness}, speed=${videoSpeed}x, player=${player}`);

        // Initialize calibration tool
        if (!calibrationTool) {
            calibrationTool = new CalibrationTool();
        }

        log('Initializing MediaPipe Pose...');
        try {
            await calibrationTool.initialize();
            log('MediaPipe ready');
        } catch (err) {
            log(`MediaPipe init failed: ${err.message}`, 'error');
            isProcessing = false;
            updateButtons();
            return;
        }

        const pendingVideos = videoQueue.filter(v => v.status === 'pending');
        const allResults = [];

        for (let i = 0; i < pendingVideos.length && isProcessing; i++) {
            const video = pendingVideos[i];
            video.status = 'processing';
            renderQueue();

            log(`Processing ${i + 1}/${pendingVideos.length}: ${video.name}`);

            try {
                const results = await calibrationTool.calibrateFromVideo(video.file, {
                    label,
                    player,
                    strokeType: 'all',
                    ntrpLevel,
                    cameraAngle,
                    handedness,
                    videoSpeed,
                    notes,
                    onProgress: (p) => {
                        const overallProgress = ((i + p.progress / 100) / pendingVideos.length) * 100;
                        progressFill.style.width = overallProgress + '%';
                        progressText.textContent = `Video ${i + 1}/${pendingVideos.length} — ${p.progress.toFixed(0)}% — ${p.strokesDetected} strokes`;
                        video.strokeCount = p.strokesDetected;
                        renderQueue();
                    },
                    onStrokeDetected: (stroke, count) => {
                        log(`  Stroke #${count}: ${stroke.type} (quality: ${stroke.qualityOverall}, conf: ${stroke.confidence?.toFixed(2) || 'N/A'})`, 'stroke');
                        video.strokeCount = count;
                        renderQueue();
                    }
                });

                video.status = 'complete';
                video.strokeCount = results.totalStrokes;
                video.results = results;
                allResults.push(results);
                log(`Complete: ${video.name} — ${results.totalStrokes} strokes in ${results.duration.toFixed(1)}s`);

            } catch (err) {
                video.status = 'error';
                log(`Error: ${video.name} — ${err.message}`, 'error');
            }

            renderQueue();
        }

        isProcessing = false;
        updateButtons();
        progressFill.style.width = '100%';
        progressText.textContent = 'Done';

        if (allResults.length > 0) {
            showResults(allResults);
        }

        log(`Finished processing ${allResults.length} video(s)`);
    }

    // ============ Results ============
    function showResults(allResults) {
        resultsSection.classList.remove('hidden');

        // Aggregate stats
        const totalStrokes = allResults.reduce((s, r) => s + r.totalStrokes, 0);
        const totalNormalized = allResults.reduce((s, r) => s + r.normalizedStrokes, 0);
        const totalDuration = allResults.reduce((s, r) => s + r.duration, 0);

        // Stroke type totals
        const strokeTypes = {};
        allResults.forEach(r => {
            if (r.distributions?.strokeTypes) {
                for (const [type, count] of Object.entries(r.distributions.strokeTypes)) {
                    strokeTypes[type] = (strokeTypes[type] || 0) + count;
                }
            }
        });

        aggStatsEl.innerHTML = `
            <div class="agg-stat"><div class="stat-value">${allResults.length}</div><div class="stat-label">Videos</div></div>
            <div class="agg-stat"><div class="stat-value">${totalStrokes}</div><div class="stat-label">Strokes</div></div>
            <div class="agg-stat"><div class="stat-value">${totalNormalized}</div><div class="stat-label">Normalized</div></div>
            <div class="agg-stat"><div class="stat-value">${totalDuration.toFixed(0)}s</div><div class="stat-label">Process Time</div></div>
            ${Object.entries(strokeTypes).map(([type, count]) =>
                `<div class="agg-stat"><div class="stat-value">${count}</div><div class="stat-label">${type}</div></div>`
            ).join('')}
        `;

        // Per-video result cards
        resultsGrid.innerHTML = '';
        allResults.forEach((r, i) => {
            const card = document.createElement('div');
            card.className = 'result-card';

            let metricsHtml = '';

            // Key metrics
            const keyMetrics = [
                ['velocity', 'Velocity'],
                ['acceleration', 'Acceleration'],
                ['rotation', 'Rotation'],
                ['qualityOverall', 'Quality'],
                ['biomechanicalScore', 'Biomechanical'],
                ['confidence', 'Confidence'],
                ['footworkScore', 'Footwork'],
                ['serveScore', 'Serve']
            ];

            for (const [key, label] of keyMetrics) {
                if (r.metrics[key]) {
                    const m = r.metrics[key];
                    metricsHtml += `
                        <div class="metric-row header-row"><span class="metric-label">${label} (n=${m.count})</span><span class="metric-value"></span></div>
                        <div class="metric-row"><span class="metric-label">avg / median</span><span class="metric-value">${fmt(m.avg)} / ${fmt(m.median)}</span></div>
                        <div class="metric-row"><span class="metric-label">min / max</span><span class="metric-value">${fmt(m.min)} / ${fmt(m.max)}</span></div>
                        <div class="metric-row"><span class="metric-label">p10 / p90</span><span class="metric-value">${fmt(m.p10)} / ${fmt(m.p90)}</span></div>
                    `;
                }
            }

            // Fault frequency
            if (r.distributions?.faultFrequency && Object.keys(r.distributions.faultFrequency).length > 0) {
                metricsHtml += `<div class="metric-row header-row"><span class="metric-label">Faults</span><span class="metric-value"></span></div>`;
                for (const [fault, count] of Object.entries(r.distributions.faultFrequency).sort((a, b) => b[1] - a[1])) {
                    metricsHtml += `<div class="metric-row"><span class="metric-label">${fault}</span><span class="metric-value">${count}/${r.totalStrokes}</span></div>`;
                }
            }

            // Confidence distribution
            if (r.distributions?.confidenceBuckets) {
                const cb = r.distributions.confidenceBuckets;
                metricsHtml += `<div class="metric-row header-row"><span class="metric-label">Confidence Dist.</span><span class="metric-value"></span></div>`;
                metricsHtml += `<div class="metric-row"><span class="metric-label">high / med / low</span><span class="metric-value">${cb.high} / ${cb.medium} / ${cb.low}</span></div>`;
            }

            card.innerHTML = `
                <h3>Video ${i + 1}: ${r.player} (${r.label})</h3>
                <div class="metric-row"><span class="metric-label">Strokes</span><span class="metric-value">${r.totalStrokes}</span></div>
                <div class="metric-row"><span class="metric-label">NTRP</span><span class="metric-value">${r.ntrpLevel || '—'}</span></div>
                <div class="metric-row"><span class="metric-label">Camera</span><span class="metric-value">${r.cameraAngle || '—'}</span></div>
                <div class="metric-row"><span class="metric-label">Hand</span><span class="metric-value">${r.handedness || '—'}</span></div>
                <div class="metric-row"><span class="metric-label">Speed</span><span class="metric-value">${r.videoSpeed || 1}x</span></div>
                ${r.notes ? `<div class="metric-row"><span class="metric-label">Notes</span><span class="metric-value">${r.notes}</span></div>` : ''}
                ${metricsHtml}
            `;

            resultsGrid.appendChild(card);
        });

        // Recommended thresholds card (from last result that has them)
        const lastResult = allResults[allResults.length - 1];
        if (lastResult.recommendedThresholds && Object.keys(lastResult.recommendedThresholds).length > 0) {
            const card = document.createElement('div');
            card.className = 'result-card';
            let threshHtml = '';
            for (const [metric, data] of Object.entries(lastResult.recommendedThresholds)) {
                threshHtml += `<div class="metric-row header-row"><span class="metric-label">${metric}</span><span class="metric-value"></span></div>`;
                if (data.current) {
                    threshHtml += `<div class="metric-row"><span class="metric-label">current</span><span class="metric-value">${JSON.stringify(data.current)}</span></div>`;
                }
                if (data.recommended) {
                    for (const [k, v] of Object.entries(data.recommended)) {
                        threshHtml += `<div class="metric-row"><span class="metric-label">rec: ${k}</span><span class="metric-value">${fmt(v)}</span></div>`;
                    }
                }
                if (data.note) {
                    threshHtml += `<div class="metric-row"><span class="metric-label">note</span><span class="metric-value" style="font-size:10px;color:#555">${data.note}</span></div>`;
                }
            }
            card.innerHTML = `<h3>Recommended Thresholds</h3>${threshHtml}`;
            resultsGrid.appendChild(card);
        }
    }

    function fmt(v) {
        if (v == null) return '—';
        if (Math.abs(v) < 1) return v.toFixed(4);
        if (Math.abs(v) < 100) return v.toFixed(1);
        return v.toFixed(0);
    }

    // ============ Export buttons ============
    document.getElementById('exportJsonBtn').addEventListener('click', () => {
        if (!calibrationTool) return;
        calibrationTool.exportCalibrationData();
        log('Exported JSON');
    });

    document.getElementById('exportCodeBtn').addEventListener('click', () => {
        if (typeof thresholdUpdater !== 'undefined') {
            thresholdUpdater.exportUpdates();
            log('Exported threshold code');
        } else if (typeof ThresholdUpdater !== 'undefined') {
            const tu = new ThresholdUpdater();
            tu.exportUpdates();
            log('Exported threshold code');
        } else {
            log('ThresholdUpdater not available', 'error');
        }
    });

    document.getElementById('consoleStatsBtn').addEventListener('click', () => {
        if (!calibrationTool) return;
        calibrationTool.printThresholdComparison();
        const stats = calibrationTool.getAggregateStats();
        console.log('Aggregate Stats:', stats);
        log('Printed stats to browser console');
    });

    // ============ Helpers ============
    function formatSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    </script>
</body>
</html>
