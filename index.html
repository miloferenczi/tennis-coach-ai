<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACE - AI Coach</title>
    <meta name="description" content="AI-powered athletic coaching with real-time pose analysis">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#0A0A0A">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ACE">

    <!-- Premium Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Link to manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/supabase-client.js"></script>

        <!-- Signal processing filters (must load before physics/analysis) -->
    <script src="js/signal-filters.js"></script>
    <script src="js/kalman-velocity-estimator.js"></script>

        <!-- Add these new scripts in order -->
    <script src="js/physics-analyzer.js"></script>
    <script src="js/stroke-classifier.js"></script>
    <script src="js/professional-references.js"></script>
    <script src="js/coaching-orchestrator.js"></script>
    <script src="js/phase-detector.js"></script>
    <script src="js/kinetic-chain-analyzer.js"></script>
    <script src="js/motion-sequence-analyzer.js"></script>
    <script src="js/biomechanical-checkpoints.js"></script>
    <script src="js/diagnostic-logger.js"></script>
    <script src="js/calibration-tool.js"></script>
    <script src="js/threshold-updater.js"></script>

    <!-- Sport Configuration -->
    <script src="js/sport-loader.js"></script>

    <!-- Ball/Court Tracking -->
    <script src="js/ball-tracking-client.js"></script>

    <!-- Application Scripts -->
    <script src="js/session-storage.js"></script>
    <script src="js/improvement-tracker.js"></script>
    <script src="js/player-profile.js"></script>
    <script src="js/ghost-overlay.js"></script>
    <script src="js/corrected-pose-engine.js"></script>
    <script src="js/stroke-replay.js"></script>
    <script src="js/scene-analyzer.js"></script>
    <script src="js/visual-analysis-merger.js"></script>
    <script src="js/live-feedback-overlay.js"></script>
    <script src="js/court-position-analyzer.js"></script>
    <script src="js/speech-gate.js"></script>
    <script src="js/batch-coaching-accumulator.js"></script>
    <script src="js/insight-miner.js"></script>
    <script src="js/proactive-triggers.js"></script>
    <script src="js/curriculum-engine.js"></script>
    <script src="js/share-card-generator.js"></script>
    <script src="js/session-video-manager.js"></script>
    <script src="js/rally-tracker.js"></script>
    <script src="js/challenge-mode.js"></script>
    <script src="js/drill-mode.js"></script>
    <script src="js/coach-notebook.js"></script>
    <script src="js/footwork-analyzer.js"></script>
    <script src="js/serve-analyzer.js"></script>
    <script src="js/enhanced-tennis-analyzer.js"></script>
    <script src="js/gpt-voice-coach.js"></script>
    <script src="js/video-analyzer.js"></script>

    <style>
        /* ============================================
           PREMIUM DESIGN SYSTEM - Nike/Athletic Aesthetic
           ============================================ */

        :root {
            /* Color System */
            --bg-primary: #0A0A0A;
            --bg-secondary: #141414;
            --bg-surface: rgba(255, 255, 255, 0.06);
            --accent-volt: #CDFF00;
            --text-primary: #F5F5F5;
            --text-muted: #8A8A8A;
            --text-subtle: #666666;
            --danger: #FF3B30;
            --success: #32D74B;
            --warning: #FF9500;
            --border-subtle: rgba(255, 255, 255, 0.08);

            /* Glass Effect */
            --glass-bg: rgba(10, 10, 10, 0.75);
            --glass-blur: blur(20px);

            /* Typography */
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;

            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --radius-full: 9999px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            -webkit-font-smoothing: antialiased;
        }

        /* Noise/Grain Texture Overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 10000;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .camera-container {
            position: relative;
            flex: 1;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
        }

        #canvasElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* ============================================
           ONBOARDING SCREENS - Nike/W+K Premium
           ============================================ */

        /* System font stack - SF Pro Display */
        .onboarding-font {
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0A0A0A;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 24px;
            z-index: 1001;
            opacity: 1;
            transform: translateY(0);
            transition: opacity 400ms ease-out, transform 400ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
        }

        .screen.exiting {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        .screen.entering {
            opacity: 0;
            transform: translateY(20px);
        }

        .screen.entering.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Onboarding content container */
        .onboarding-content {
            width: 100%;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            justify-content: center;
        }

        /* Step Indicator - Fixed at bottom */
        .step-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        .step-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 300ms ease-out;
        }

        .step-dot.active {
            background: #CDFF00;
            border-color: #CDFF00;
        }

        /* Step 1: Welcome Screen */
        .hero-title {
            font-size: 72px;
            font-weight: 900;
            color: #F5F5F5;
            letter-spacing: -0.03em;
            line-height: 1;
            margin-bottom: 12px;
        }

        .hero-title .accent {
            color: #CDFF00;
        }

        .hero-subtitle {
            font-size: 12px;
            font-weight: 500;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 48px;
        }

        .hero-session-count {
            font-size: 11px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-top: 4px;
        }

        /* Feature Cards */
        .feature-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            margin-bottom: 32px;
        }

        .feature-card {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 18px 20px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 16px;
            opacity: 0;
            transform: translateY(12px);
            animation: featureCardIn 400ms ease-out forwards;
        }

        .feature-card:nth-child(1) { animation-delay: 0ms; }
        .feature-card:nth-child(2) { animation-delay: 80ms; }
        .feature-card:nth-child(3) { animation-delay: 160ms; }
        .feature-card:nth-child(4) { animation-delay: 240ms; }

        @keyframes featureCardIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .feature-icon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .feature-icon svg {
            width: 24px;
            height: 24px;
            stroke: #CDFF00;
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .feature-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .feature-title {
            font-size: 15px;
            font-weight: 600;
            color: #F5F5F5;
        }

        .feature-desc {
            font-size: 12px;
            font-weight: 400;
            color: #444;
        }

        /* Primary CTA Button */
        .btn-primary {
            width: 100%;
            height: 56px;
            background: #CDFF00;
            color: #0A0A0A;
            border: none;
            border-radius: 28px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            cursor: pointer;
            transition: transform 150ms ease-out, background 150ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            /* Haptic trigger point */
        }

        .btn-primary:active {
            transform: scale(0.97);
            background: #B8E600;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Step 2: Voice Coach Screen */
        .voice-header {
            width: 100%;
            text-align: left;
            margin-bottom: 32px;
        }

        .voice-title {
            font-size: 56px;
            font-weight: 900;
            color: #F5F5F5;
            letter-spacing: -0.02em;
            line-height: 0.95;
        }

        .voice-label {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            color: #0A0A0A;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            background: rgba(255, 255, 255, 0.12);
            padding: 6px 10px;
            border-radius: 4px;
            margin-top: 16px;
        }

        .voice-tagline {
            font-size: 14px;
            font-weight: 400;
            color: #555;
            margin-top: 12px;
            text-align: left;
        }

        /* API Input */
        .api-input-group {
            width: 100%;
            margin-bottom: 24px;
        }

        .api-label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 8px;
            text-align: left;
        }

        .api-input-wrapper {
            position: relative;
            width: 100%;
        }

        .api-input {
            width: 100%;
            height: 52px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 0 16px;
            font-size: 14px;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            color: #F5F5F5;
            transition: border-color 200ms ease-out, background 200ms ease-out;
        }

        .api-input:focus {
            outline: none;
            border-color: rgba(205, 255, 0, 0.4);
            background: rgba(255, 255, 255, 0.08);
        }

        .api-input::placeholder {
            color: #333;
        }

        .api-input.validated {
            padding-right: 44px;
        }

        .api-input.flash {
            animation: inputFlash 200ms ease-out;
        }

        @keyframes inputFlash {
            0%, 100% { border-color: rgba(205, 255, 0, 0.4); }
            50% { border-color: #CDFF00; }
        }

        .api-checkmark {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            display: none;
        }

        .api-checkmark.visible {
            display: block;
        }

        .api-checkmark svg {
            width: 16px;
            height: 16px;
            stroke: #CDFF00;
            fill: none;
            stroke-width: 2;
        }

        .api-link {
            display: inline-block;
            font-size: 12px;
            font-weight: 500;
            color: #555;
            text-decoration: none;
            margin-top: 12px;
            transition: color 200ms ease-out;
        }

        .api-link:hover {
            color: #CDFF00;
        }

        /* Skip Button */
        .btn-skip {
            background: transparent;
            border: none;
            font-size: 13px;
            font-weight: 500;
            color: #444;
            cursor: pointer;
            padding: 16px 24px;
            margin-top: 24px;
            transition: color 200ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
            min-height: 44px;
            /* Intentionally de-emphasized */
        }

        .btn-skip:hover {
            color: #666;
        }

        /* Step 3: Loading Screen */
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }

        .loading-logo {
            width: 64px;
            height: 64px;
            margin-bottom: 20px;
            animation: logoScale 2s ease-in-out infinite;
        }

        .loading-logo svg {
            width: 100%;
            height: 100%;
        }

        @keyframes logoScale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.04); }
        }

        .loading-phase {
            font-size: 14px;
            font-weight: 700;
            color: #F5F5F5;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 8px;
            min-height: 20px;
            transition: opacity 200ms ease-out;
        }

        .loading-phase.crossfade {
            opacity: 0;
        }

        .loading-detail {
            font-size: 12px;
            font-weight: 400;
            color: #444;
            margin-bottom: 24px;
            min-height: 16px;
            transition: opacity 200ms ease-out;
        }

        .loading-detail.crossfade {
            opacity: 0;
        }

        .loading-track {
            width: 100%;
            max-width: 360px;
            height: 3px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-fill {
            height: 100%;
            background: #CDFF00;
            width: 0%;
            transition: width 400ms ease-out;
            border-radius: 2px;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: rgba(255, 59, 48, 0.15);
            color: #FF3B30;
            font-size: 13px;
            font-weight: 500;
            padding: 12px 20px;
            border-radius: 12px;
            z-index: 9999;
            opacity: 0;
            transition: transform 300ms ease-out, opacity 300ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
        }

        .toast.visible {
            transform: translateX(-50%) translateY(20px);
            opacity: 1;
        }

        .toast.hiding {
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            background: var(--accent-volt);
            color: var(--bg-primary);
            border: none;
            padding: 16px 40px;
            border-radius: var(--radius-full);
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.15s ease;
            font-family: var(--font-family);
        }

        .btn:hover {
            opacity: 0.9;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn-secondary {
            background: var(--bg-surface);
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-muted);
            padding: 12px 24px;
        }

        .btn-ghost:hover {
            color: var(--text-primary);
        }

        /* ============================================
           INPUTS
           ============================================ */
        input[type="password"],
        input[type="text"] {
            width: 100%;
            max-width: 360px;
            padding: 16px 20px;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            background: var(--bg-surface);
            color: var(--text-primary);
            font-size: 15px;
            font-family: var(--font-family);
            margin: 20px 0;
            backdrop-filter: var(--glass-blur);
            transition: border-color 0.2s ease;
        }

        input[type="password"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-volt);
        }

        input[type="password"]::placeholder,
        input[type="text"]::placeholder {
            color: var(--text-subtle);
        }

        /* ============================================
           LOADING SCREEN
           ============================================ */
        .loading-screen {
            z-index: 1000;
        }

        .loading-text {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        .loading-progress {
            width: 200px;
            height: 2px;
            background: var(--bg-surface);
            border-radius: var(--radius-full);
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: var(--accent-volt);
            border-radius: var(--radius-full);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* ============================================
           STATUS BAR (Top HUD)
           ============================================ */
        .status-bar {
            position: absolute;
            top: var(--space-md);
            left: var(--space-md);
            right: var(--space-md);
            display: flex;
            justify-content: space-between;
            z-index: 100;
            background: var(--glass-bg);
            padding: 16px 20px;
            border-radius: var(--radius-lg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
        }

        .status-item {
            text-align: center;
            flex: 1;
        }

        .status-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-subtle);
            margin-bottom: 6px;
        }

        .status-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
        }

        .status-value.muted {
            color: var(--text-subtle);
        }

        .ai-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-subtle);
        }

        .status-dot.ready {
            background: var(--warning);
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: var(--accent-volt);
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 12px rgba(205, 255, 0, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* ============================================
           ANALYSIS CARD
           ============================================ */
        .analysis-card {
            position: absolute;
            top: 100px;
            right: var(--space-md);
            background: var(--glass-bg);
            border-radius: var(--radius-lg);
            padding: 20px;
            min-width: 180px;
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            transform: scale(0) translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            max-height: 320px;
            overflow-y: auto;
            z-index: 100;
        }

        .analysis-card.visible {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .stroke-type {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-volt);
            margin-bottom: 8px;
            text-align: center;
        }

        .technique-score {
            font-size: 48px;
            font-weight: 800;
            text-align: center;
            margin-bottom: 4px;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .score-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-subtle);
            text-align: center;
            margin-bottom: 16px;
        }

        .advanced-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            padding-top: 16px;
            border-top: 1px solid var(--border-subtle);
        }

        .metric-item {
            text-align: center;
        }

        .metric-label {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-subtle);
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* ============================================
           COACHING PANEL
           ============================================ */
        .coaching-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--glass-bg);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border-top: 1px solid var(--border-subtle);
            max-height: 30vh;
            overflow-y: auto;
            z-index: 100;
        }

        .coaching-drag-handle {
            width: 36px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-full);
            margin: 0 auto 16px;
        }

        .coaching-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .coaching-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-volt);
        }

        .coaching-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-volt);
            animation: pulse 1.5s infinite;
        }

        .coaching-text {
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-primary);
            font-weight: 400;
        }

        .phase-indicator {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
        }

        .phase-step {
            flex: 1;
            text-align: center;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 0.05em;
            padding: 4px 2px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.06);
            color: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .phase-step.active {
            background: rgba(205, 255, 0, 0.2);
            color: var(--accent-volt);
            box-shadow: 0 0 8px rgba(205, 255, 0, 0.15);
        }

        .phase-step.completed {
            background: rgba(205, 255, 0, 0.08);
            color: rgba(205, 255, 0, 0.5);
        }

        .fault-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .fault-chip {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(255, 59, 48, 0.15);
            color: #FF3B30;
            border: 1px solid rgba(255, 59, 48, 0.3);
        }

        .fault-chip.low-priority {
            background: rgba(255, 159, 10, 0.15);
            color: #FF9F0A;
            border-color: rgba(255, 159, 10, 0.3);
        }

        .strength-chip {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(48, 209, 88, 0.15);
            color: #30D158;
            border: 1px solid rgba(48, 209, 88, 0.3);
        }

        /* Old controls/mode-switcher removed — replaced by browse/live navigation */

        /* ============================================
           ERROR MESSAGE
           ============================================ */
        .error-message {
            background: var(--danger);
            color: white;
            padding: 16px 20px;
            border-radius: var(--radius-md);
            margin: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
        }

        /* ============================================
           STROKE FLASH OVERLAY
           ============================================ */
        .stroke-flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0;
        }

        .stroke-flash-overlay.flash {
            animation: borderFlash 0.5s ease-out forwards;
        }

        .stroke-flash-overlay.great {
            box-shadow: inset 0 0 120px 40px rgba(205, 255, 0, 0.6);
        }

        .stroke-flash-overlay.good {
            box-shadow: inset 0 0 120px 40px rgba(255, 149, 0, 0.5);
        }

        .stroke-flash-overlay.needs-work {
            box-shadow: inset 0 0 120px 40px rgba(255, 59, 48, 0.5);
        }

        @keyframes borderFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* ============================================
           GHOST OVERLAY STYLES
           ============================================ */
        .ghost-similarity {
            position: fixed;
            top: 140px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-lg);
            padding: 12px 16px;
            text-align: center;
            z-index: 100;
        }

        .ghost-similarity-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .ghost-similarity-value {
            font-size: 28px;
            font-weight: 800;
            color: var(--accent-volt);
        }

        .ghost-similarity-value.low {
            color: #f44336;
        }

        .ghost-similarity-value.medium {
            color: #FF9800;
        }

        .ghost-similarity-value.high {
            color: var(--accent-volt);
        }

        /* #ghostBtn styles removed — ghost toggle moved to settings */

        /* ============================================
           PRO COMPARISON STYLES
           ============================================ */
        .pro-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pro-card:hover {
            background: rgba(205, 255, 0, 0.1);
            border-color: var(--accent-volt);
        }

        .pro-card.selected {
            background: rgba(205, 255, 0, 0.15);
            border-color: var(--accent-volt);
        }

        .pro-name {
            font-weight: 700;
            color: white;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .pro-style {
            font-size: 11px;
            color: var(--text-muted);
        }

        .comparison-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .comparison-metric:last-child {
            border-bottom: none;
        }

        .comparison-metric-label {
            color: var(--text-muted);
            font-size: 13px;
        }

        .comparison-metric-values {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .comparison-you {
            color: white;
            font-weight: 600;
        }

        .comparison-vs {
            color: var(--text-muted);
            font-size: 11px;
        }

        .comparison-pro {
            color: var(--accent-volt);
            font-weight: 600;
        }

        .comparison-diff {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .comparison-diff.positive {
            background: rgba(205, 255, 0, 0.2);
            color: var(--accent-volt);
        }

        .comparison-diff.negative {
            background: rgba(255, 59, 48, 0.2);
            color: #f44336;
        }

        /* ============================================
           CHALLENGE MODE STYLES
           ============================================ */
        .active-challenge-bar {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-full);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 200;
        }

        .challenge-info {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .challenge-icon {
            font-size: 16px;
        }

        .challenge-name {
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .challenge-progress-bar {
            width: 80px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .challenge-progress-fill {
            height: 100%;
            background: var(--accent-volt);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .challenge-progress-text {
            font-size: 11px;
            color: var(--text-muted);
            min-width: 30px;
        }

        .challenge-complete-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000;
            animation: fadeIn 0.3s ease;
        }

        .challenge-complete-content {
            text-align: center;
            padding: 40px;
        }

        .challenge-complete-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounceIn 0.5s ease;
        }

        .challenge-complete-title {
            font-size: 28px;
            font-weight: 800;
            color: var(--accent-volt);
            margin-bottom: 12px;
        }

        .challenge-complete-name {
            font-size: 18px;
            color: white;
            margin-bottom: 8px;
        }

        .challenge-complete-reward {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* ============================================
           DRILL MODE STYLES
           ============================================ */
        .drill-hud {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 320px;
        }

        .drill-hud-header {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-full);
            padding: 6px 16px;
            pointer-events: auto;
        }

        .drill-hud-name {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .drill-hud-stop {
            font-size: 10px;
            font-weight: 700;
            color: var(--danger);
            background: rgba(255, 59, 48, 0.15);
            border: 1px solid rgba(255, 59, 48, 0.3);
            border-radius: 4px;
            padding: 3px 8px;
            cursor: pointer;
            letter-spacing: 0.5px;
        }

        .drill-hud-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .drill-hud-progress-bar {
            flex: 1;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .drill-hud-progress-fill {
            height: 100%;
            background: var(--accent-volt);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .drill-hud-progress-text {
            font-size: 11px;
            color: var(--text-muted);
            min-width: 30px;
            text-align: right;
        }

        .drill-hud-metric {
            text-align: center;
            animation: drillMetricPop 0.3s ease;
        }

        .drill-hud-metric-value {
            font-size: 56px;
            font-weight: 900;
            line-height: 1;
            color: var(--text-primary);
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            transition: color 0.2s ease;
        }

        .drill-hud-metric-value.at-target {
            color: var(--success);
            text-shadow: 0 0 20px rgba(50, 215, 75, 0.4);
        }

        .drill-hud-metric-value.close {
            color: var(--warning);
            text-shadow: 0 0 20px rgba(255, 149, 0, 0.4);
        }

        .drill-hud-metric-value.far {
            color: var(--danger);
            text-shadow: 0 0 20px rgba(255, 59, 48, 0.4);
        }

        .drill-hud-metric-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .drill-hud-metric-target {
            font-size: 10px;
            color: var(--text-subtle);
        }

        @keyframes drillMetricPop {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .drill-hud-reps {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .drill-rep-dot {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: 700;
            color: transparent;
            transition: all 0.3s ease;
        }

        .drill-rep-dot.hit {
            background: rgba(50, 215, 75, 0.25);
            border-color: var(--success);
            color: var(--success);
        }

        .drill-rep-dot.close {
            background: rgba(255, 149, 0, 0.2);
            border-color: var(--warning);
            color: var(--warning);
        }

        .drill-rep-dot.miss {
            background: rgba(255, 59, 48, 0.2);
            border-color: var(--danger);
            color: var(--danger);
        }

        .drill-hud-wrong-type {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 59, 48, 0.9);
            color: white;
            font-size: 16px;
            font-weight: 700;
            padding: 12px 24px;
            border-radius: var(--radius-md);
            z-index: 95;
            animation: drillWrongTypeFade 1.5s ease forwards;
            pointer-events: none;
        }

        @keyframes drillWrongTypeFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(0.9); }
        }

        .drill-summary-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000;
            animation: fadeIn 0.3s ease;
        }

        .drill-summary-content {
            text-align: center;
            padding: 32px;
            max-width: 400px;
            width: 100%;
        }

        .drill-summary-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .drill-summary-name {
            font-size: 24px;
            font-weight: 800;
            color: var(--accent-volt);
            margin-bottom: 24px;
        }

        .drill-summary-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 24px;
        }

        .drill-stat {
            text-align: center;
        }

        .drill-stat-value {
            font-size: 28px;
            font-weight: 800;
            color: var(--text-primary);
        }

        .drill-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .drill-summary-chart {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 4px;
            height: 100px;
            margin-bottom: 24px;
            padding: 0 8px;
        }

        .drill-chart-bar {
            flex: 1;
            max-width: 28px;
            border-radius: 3px 3px 0 0;
            position: relative;
            transition: height 0.3s ease;
        }

        .drill-chart-bar.hit {
            background: var(--success);
        }

        .drill-chart-bar.close {
            background: var(--warning);
        }

        .drill-chart-bar.miss {
            background: var(--danger);
        }

        .drill-chart-target-line {
            position: absolute;
            left: -8px;
            right: -8px;
            height: 2px;
            background: var(--accent-volt);
            opacity: 0.5;
        }

        .drill-summary-trend {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        .drill-summary-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .drill-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .drill-card:hover {
            border-color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.05);
        }

        .drill-card.recommended {
            border-color: rgba(205, 255, 0, 0.3);
            background: rgba(205, 255, 0, 0.05);
        }

        .drill-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .drill-card-name {
            font-weight: 700;
            color: white;
            font-size: 15px;
        }

        .drill-card-reps {
            font-size: 11px;
            color: var(--text-muted);
        }

        .drill-card-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .drill-card-meta {
            display: flex;
            gap: 12px;
            font-size: 11px;
        }

        .drill-card-stroke {
            color: var(--accent-volt);
            font-weight: 600;
        }

        .drill-card-target {
            color: var(--text-subtle);
        }

        .drill-card-badge {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: inline-block;
        }

        .challenge-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .challenge-card:hover {
            border-color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.05);
        }

        .challenge-card.completed {
            opacity: 0.6;
            border-color: var(--accent-volt);
        }

        .challenge-card.active {
            border-color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.1);
        }

        .challenge-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .challenge-card-icon {
            font-size: 24px;
        }

        .challenge-card-title {
            font-weight: 700;
            color: white;
            font-size: 15px;
        }

        .challenge-card-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .challenge-card-difficulty {
            font-size: 10px;
            text-transform: uppercase;
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .challenge-card-difficulty.easy {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .challenge-card-difficulty.medium {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }

        .challenge-card-difficulty.hard {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .challenge-card-badge {
            font-size: 11px;
            color: var(--accent-volt);
            margin-left: auto;
        }

        /* ============================================
           MODAL STYLES
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius-xl);
            padding: 28px;
            max-width: 480px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            transform: scale(0.95) translateY(20px);
            transition: transform 0.3s ease;
            border: 1px solid var(--border-subtle);
        }

        .modal-overlay.visible .modal {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            color: var(--text-primary);
        }

        .modal-close {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            color: var(--text-muted);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .summary-stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .summary-stat.highlight {
            grid-column: span 2;
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .summary-stat-value {
            font-size: 28px;
            font-weight: bold;
            color: white;
            margin-bottom: 4px;
        }

        .summary-stat-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
        }

        .summary-section {
            margin-bottom: 20px;
        }

        .summary-section-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--accent-volt, #CDFF00);
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .weakness-tag {
            display: inline-block;
            background: rgba(255, 152, 0, 0.3);
            color: #FFC107;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            margin: 4px 4px 4px 0;
        }

        .drill-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 12px;
            border-left: 4px solid var(--accent-volt, #CDFF00);
        }

        .drill-name {
            font-size: 16px;
            font-weight: bold;
            color: white;
            margin-bottom: 8px;
        }

        .drill-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .drill-duration {
            font-size: 12px;
            color: var(--accent-volt, #CDFF00);
        }

        .improvement-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
        }

        .improvement-badge.positive {
            background: rgba(76, 175, 80, 0.3);
            color: var(--accent-volt, #CDFF00);
        }

        .improvement-badge.negative {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        .improvement-badge.neutral {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        /* Duplicate mode-switcher removed — replaced by browse/live navigation */

        /* Analysis Mode Container */
        .analysis-mode-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            background: var(--bg-primary, #0A0A0A);
        }

        .analysis-mode-container.active {
            display: flex;
        }

        .video-upload-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--bg-secondary, #141414);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px dashed var(--border-subtle, rgba(255,255,255,0.1));
            margin: 16px;
            border-radius: var(--radius-lg, 16px);
        }

        .video-upload-zone.dragover {
            border-color: var(--accent-volt, #CDFF00);
            background: rgba(205, 255, 0, 0.05);
        }

        .video-upload-zone.has-video {
            display: none;
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }

        .upload-subtext {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
        }

        /* Video Player Area */
        .video-player-area {
            flex: 1;
            position: relative;
            display: none;
            background: #000;
        }

        .video-player-area.active {
            display: flex;
            flex-direction: column;
        }

        .video-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #analysisVideo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        #analysisCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Timeline */
        .timeline-container {
            background: rgba(0, 0, 0, 0.9);
            padding: 16px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 12px;
        }

        .timeline-time {
            font-size: 14px;
            color: white;
            font-family: monospace;
            min-width: 100px;
        }

        .timeline-playback-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: var(--accent-volt, #CDFF00);
            color: white;
            font-size: 16px;
            cursor: pointer;
        }

        .timeline-track {
            position: relative;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(76, 175, 80, 0.3);
            border-radius: 4px;
            pointer-events: none;
        }

        .timeline-playhead {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-volt, #CDFF00);
            border-radius: 2px;
            pointer-events: none;
        }

        .stroke-marker {
            position: absolute;
            top: 4px;
            bottom: 4px;
            width: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .stroke-marker:hover {
            transform: scaleY(1.2);
        }

        .stroke-marker.forehand {
            background: var(--accent-volt, #CDFF00);
        }

        .stroke-marker.backhand {
            background: var(--accent-volt, #CDFF00);
        }

        .stroke-marker.serve {
            background: #FF9800;
        }

        .stroke-marker.volley {
            background: #9C27B0;
        }

        .stroke-marker.selected {
            box-shadow: 0 0 0 2px white;
        }

        /* Stroke Details Panel */
        .stroke-details-panel {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 16px;
            padding: 16px;
            min-width: 200px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            transform: translateX(320px);
            transition: transform 0.3s ease;
            z-index: 100;
        }

        .stroke-details-panel.visible {
            transform: translateX(0);
        }

        #comparisonPanel {
            left: 20px;
            right: auto;
            transform: translateX(-320px);
        }

        #comparisonPanel.visible {
            transform: translateX(0);
        }

        .stroke-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .stroke-details-type {
            font-size: 16px;
            font-weight: bold;
            text-transform: capitalize;
        }

        .stroke-details-score {
            font-size: 24px;
            font-weight: bold;
        }

        .stroke-details-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stroke-metric {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stroke-metric-value {
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .stroke-metric-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Analysis Progress */
        .analysis-progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .analysis-progress-overlay.active {
            display: flex;
        }

        .analysis-progress-text {
            font-size: 18px;
            color: white;
            margin-bottom: 20px;
        }

        .analysis-progress-bar {
            width: 80%;
            max-width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .analysis-progress-fill {
            height: 100%;
            background: var(--accent-volt, #CDFF00);
            width: 0%;
            transition: width 0.2s;
        }

        @media (max-width: 480px) {
            .status-bar {
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 10px 12px;
            }

            .analysis-card {
                top: 120px;
                right: 10px;
                padding: 12px;
                min-width: 140px;
            }

            .coaching-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                padding: 12px;
                max-height: 160px;
            }

            .phase-step {
                font-size: 8px;
                padding: 3px 1px;
            }

            .fault-chip, .strength-chip {
                font-size: 9px;
                padding: 2px 6px;
            }

            /* Responsive controls removed — replaced by live session controls */
        }

        /* ============================================
           REPLAY OVERLAY
           ============================================ */
        .replay-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .replay-overlay.visible {
            display: flex;
        }

        .replay-canvas-wrap {
            position: relative;
            width: 100%;
            max-width: 640px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #replayCanvas {
            width: 100%;
            max-height: 80vh;
            border-radius: 8px;
        }

        .replay-controls {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .replay-ctrl-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #F5F5F5;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 600;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .replay-ctrl-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .replay-ctrl-btn.active {
            background: var(--accent-volt);
            color: #0A0A0A;
            border-color: var(--accent-volt);
        }

        .replay-ctrl-btn.close-btn {
            background: rgba(255, 59, 48, 0.2);
            border-color: rgba(255, 59, 48, 0.4);
            color: #FF3B30;
        }

        .coaches-eye-btn {
            background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05));
            border: 1px solid rgba(255,215,0,0.4);
            color: #FFD700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        .coaches-eye-btn.active {
            background: linear-gradient(135deg, rgba(255,215,0,0.35), rgba(255,215,0,0.15));
            border-color: #FFD700;
            box-shadow: 0 0 12px rgba(255,215,0,0.3);
        }

        .replay-btn {
            position: fixed;
            bottom: calc(220px + env(safe-area-inset-bottom));
            right: 16px;
            z-index: 200;
            background: var(--accent-volt);
            color: #0A0A0A;
            border: none;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 700;
            padding: 10px 16px;
            border-radius: 24px;
            cursor: pointer;
            display: none;
            box-shadow: 0 4px 12px rgba(205, 255, 0, 0.3);
            animation: replayPulse 1.5s ease-in-out infinite;
        }

        @keyframes replayPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .replay-btn.visible {
            display: block;
        }

        /* Session review stroke grid */
        .replay-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 6px;
            margin-top: 8px;
        }

        .replay-grid-item {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .replay-grid-item:hover {
            transform: scale(1.1);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ================================================
           ONBOARDING FLOW STYLES
           ================================================ */

        /* Selection cards (sport, skill, coach) */
        .ob-card-grid { display: flex; flex-direction: column; gap: 12px; width: 100%; margin-bottom: 32px; }
        .ob-card {
            display: flex; align-items: center; gap: 16px;
            padding: 18px 20px; background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06); border-radius: 16px;
            cursor: pointer; transition: all 200ms ease-out;
            opacity: 0; transform: translateY(12px);
            animation: featureCardIn 400ms ease-out forwards;
        }
        .ob-card:hover { background: rgba(205,255,0,0.04); border-color: rgba(205,255,0,0.15); }
        .ob-card.selected { background: rgba(205,255,0,0.08); border-color: rgba(205,255,0,0.4); }
        .ob-card-icon { font-size: 28px; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .ob-card-text { display: flex; flex-direction: column; gap: 2px; flex: 1; }
        .ob-card-title { font-size: 15px; font-weight: 600; color: #F5F5F5; }
        .ob-card-desc { font-size: 12px; color: #555; }
        .ob-card-check {
            width: 24px; height: 24px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.1);
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; transition: all 200ms ease-out;
        }
        .ob-card.selected .ob-card-check { background: #CDFF00; border-color: #CDFF00; }

        /* Multi-select chip grid */
        .ob-chip-grid { display: flex; flex-wrap: wrap; gap: 8px; width: 100%; margin-bottom: 24px; }
        .ob-chip {
            padding: 10px 16px; background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08); border-radius: 24px;
            font-size: 13px; color: #999; cursor: pointer; transition: all 200ms ease-out;
            font-family: inherit;
        }
        .ob-chip.selected { background: rgba(205,255,0,0.12); border-color: rgba(205,255,0,0.4); color: #CDFF00; }

        /* Coach personality cards */
        .ob-coach-card {
            display: flex; flex-direction: column; padding: 20px;
            background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06);
            border-radius: 16px; cursor: pointer; transition: all 200ms ease-out; gap: 8px;
        }
        .ob-coach-card.selected { background: rgba(205,255,0,0.08); border-color: rgba(205,255,0,0.4); }
        .ob-coach-header { display: flex; align-items: center; gap: 12px; }
        .ob-coach-avatar {
            width: 48px; height: 48px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 20px;
        }
        .ob-coach-name { font-size: 16px; font-weight: 700; color: #F5F5F5; }
        .ob-coach-tagline { font-size: 12px; color: #555; }
        .ob-preview-btn {
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px; padding: 6px 12px; font-size: 11px; color: #888;
            cursor: pointer; align-self: flex-start; margin-top: 4px;
            transition: all 200ms; font-family: inherit;
        }
        .ob-preview-btn:hover { color: #CDFF00; border-color: rgba(205,255,0,0.3); }

        /* Meet coach audio wave */
        .ob-coach-wave { width: 100%; height: 40px; display: flex; align-items: center; justify-content: center; gap: 3px; margin: 24px 0; }
        .ob-coach-wave .bar { width: 3px; background: #CDFF00; border-radius: 2px; animation: waveBar 1.2s ease-in-out infinite; }
        @keyframes waveBar {
            0%, 100% { height: 8px; opacity: 0.3; }
            50% { height: 28px; opacity: 1; }
        }

        /* Trial stroke counter */
        .ob-trial-counter {
            position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); backdrop-filter: blur(8px);
            padding: 8px 20px; border-radius: 20px; font-size: 13px; font-weight: 600;
            color: #CDFF00; z-index: 1100; border: 1px solid rgba(205,255,0,0.2);
        }

        /* Report card */
        .ob-report-card { width: 100%; display: flex; flex-direction: column; gap: 0; }
        .ob-report-stat {
            display: flex; justify-content: space-between; align-items: center;
            padding: 14px 0; border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .ob-report-stat:last-child { border-bottom: none; }
        .ob-report-stat-label { font-size: 13px; color: #666; }
        .ob-report-stat-value { font-size: 15px; font-weight: 600; color: #F5F5F5; }

        /* Pricing cards */
        .ob-pricing-grid { display: flex; flex-direction: column; gap: 12px; width: 100%; margin-bottom: 24px; }
        .ob-pricing-card {
            padding: 20px; background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06); border-radius: 16px; transition: all 200ms;
        }
        .ob-pricing-card.highlight { border-color: rgba(205,255,0,0.4); background: rgba(205,255,0,0.04); }
        .ob-pricing-badge {
            display: inline-block; background: #CDFF00; color: #0A0A0A;
            font-size: 10px; font-weight: 700; padding: 3px 8px; border-radius: 10px;
            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px;
        }
        .ob-pricing-name { font-size: 18px; font-weight: 700; color: #F5F5F5; margin-bottom: 4px; }
        .ob-pricing-price { font-size: 14px; color: #CDFF00; margin-bottom: 12px; }
        .ob-pricing-features { list-style: none; padding: 0; margin: 0; }
        .ob-pricing-features li {
            font-size: 12px; color: #777; padding: 4px 0 4px 16px; position: relative;
        }
        .ob-pricing-features li::before { content: '\2713'; position: absolute; left: 0; color: #CDFF00; font-size: 11px; }

        /* Onboarding text elements */
        .ob-question { font-size: 24px; font-weight: 700; color: #F5F5F5; text-align: center; margin-bottom: 32px; line-height: 1.3; }
        .ob-subtitle { font-size: 13px; color: #555; text-align: center; margin-top: -24px; margin-bottom: 32px; }

        /* Onboarding input fields */
        .ob-input {
            width: 100%; padding: 14px 16px; background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08); border-radius: 12px;
            color: #F5F5F5; font-size: 15px; font-family: inherit; outline: none;
            transition: border-color 200ms; box-sizing: border-box;
        }
        .ob-input:focus { border-color: rgba(205,255,0,0.4); }
        .ob-input::placeholder { color: #444; }

        /* Progress bar at bottom of onboarding screens */
        .ob-progress {
            position: absolute; bottom: 40px; left: 24px; right: 24px;
            height: 2px; background: rgba(255,255,255,0.06); border-radius: 1px;
        }
        .ob-progress-fill { height: 100%; background: #CDFF00; border-radius: 1px; transition: width 400ms ease-out; }

        /* ============================================
           BOTTOM TAB BAR
           ============================================ */
        #bottomTabBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 500;
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: calc(56px + env(safe-area-inset-bottom));
            padding-bottom: env(safe-area-inset-bottom);
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border-top: 1px solid rgba(255, 255, 255, 0.06);
        }

        .tab-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            background: none;
            border: none;
            color: var(--text-subtle);
            cursor: pointer;
            padding: 6px 12px;
            -webkit-tap-highlight-color: transparent;
            transition: color 0.2s;
            position: relative;
        }

        .tab-btn svg {
            width: 22px;
            height: 22px;
            stroke-width: 1.8;
        }

        .tab-btn span {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.02em;
            font-family: var(--font-family);
        }

        .tab-btn.active {
            color: var(--accent-volt);
        }

        .tab-btn:active {
            transform: scale(0.92);
        }

        /* ============================================
           TAB CONTENT PANELS
           ============================================ */
        #tabContent {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
            background: var(--bg-primary);
            display: none;
        }

        #tabContent.active {
            display: block;
        }

        .tab-panel {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: calc(env(safe-area-inset-top) + 20px) 20px calc(76px + env(safe-area-inset-bottom));
        }

        .tab-panel.active {
            display: block;
        }

        /* Home Tab */
        .home-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 28px;
        }

        .home-greeting {
            font-size: 28px;
            font-weight: 800;
            letter-spacing: -0.02em;
            color: var(--text-primary);
        }

        .home-greeting .accent {
            color: var(--accent-volt);
        }

        .home-greeting-coach {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .home-greeting-progress {
            font-size: 13px;
            color: var(--accent-volt);
            margin-top: 8px;
            font-weight: 500;
            line-height: 1.4;
        }

        .home-greeting-progress.muted {
            color: var(--text-muted);
            font-weight: 400;
        }

        .home-settings-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: var(--bg-surface);
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .home-settings-btn:active {
            transform: scale(0.92);
        }

        .home-cta {
            display: flex;
            align-items: center;
            gap: 16px;
            width: 100%;
            padding: 20px;
            border-radius: var(--radius-lg);
            border: none;
            cursor: pointer;
            text-align: left;
            font-family: var(--font-family);
            -webkit-tap-highlight-color: transparent;
            margin-bottom: 12px;
        }

        .home-cta:active {
            transform: scale(0.98);
        }

        .home-cta-primary {
            background: var(--accent-volt);
            color: #0A0A0A;
        }

        .home-cta-primary .cta-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .home-cta-primary .cta-icon svg {
            width: 22px;
            height: 22px;
        }

        .home-cta-title {
            font-size: 16px;
            font-weight: 700;
        }

        .home-cta-subtitle {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 2px;
        }

        .home-cta-secondary {
            background: var(--bg-surface);
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
        }

        .home-cta-secondary .cta-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .home-cta-secondary .cta-icon svg {
            width: 20px;
            height: 20px;
            color: var(--accent-volt);
        }

        .home-card {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 12px;
        }

        .home-card-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .home-stats-row {
            display: flex;
            gap: 12px;
        }

        .home-stat {
            flex: 1;
            text-align: center;
        }

        .home-stat-value {
            font-size: 22px;
            font-weight: 800;
            color: var(--text-primary);
        }

        .home-stat-label {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .home-plan-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
        }

        .home-plan-item + .home-plan-item {
            border-top: 1px solid var(--border-subtle);
        }

        .home-plan-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-volt);
            flex-shrink: 0;
        }

        .home-plan-text {
            font-size: 13px;
            color: var(--text-primary);
        }

        /* Drills / Challenges Tab cards */
        .tab-section-title {
            font-size: 22px;
            font-weight: 800;
            letter-spacing: -0.01em;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        .drill-card, .challenge-card-tab {
            display: flex;
            align-items: center;
            gap: 14px;
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 14px 16px;
            margin-bottom: 10px;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            transition: background 0.15s;
        }

        .drill-card:active, .challenge-card-tab:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .drill-card-icon, .challenge-card-tab-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 18px;
        }

        .drill-card-icon {
            background: rgba(205, 255, 0, 0.1);
            color: var(--accent-volt);
        }

        .challenge-card-tab-icon {
            background: rgba(255, 149, 0, 0.1);
            color: var(--warning);
        }

        .drill-card-info, .challenge-card-tab-info {
            flex: 1;
            min-width: 0;
        }

        .drill-card-name, .challenge-card-tab-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .drill-card-desc, .challenge-card-tab-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .drill-card-chevron, .challenge-card-tab-chevron {
            color: var(--text-subtle);
            flex-shrink: 0;
        }

        .challenge-card-tab.completed {
            opacity: 0.5;
        }

        .challenge-card-tab-badge {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            padding: 2px 8px;
            border-radius: var(--radius-full);
            background: rgba(50, 215, 75, 0.15);
            color: var(--success);
            flex-shrink: 0;
        }

        /* Profile Tab */
        .profile-section {
            margin-bottom: 24px;
        }

        .profile-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .profile-row {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 0;
            border-bottom: 1px solid var(--border-subtle);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .profile-row:last-child {
            border-bottom: none;
        }

        .profile-row:active {
            opacity: 0.7;
        }

        .profile-row-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: var(--bg-surface);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .profile-row-icon svg {
            width: 18px;
            height: 18px;
        }

        .profile-row-text {
            flex: 1;
            font-size: 15px;
            color: var(--text-primary);
        }

        .profile-row-value {
            font-size: 13px;
            color: var(--text-muted);
        }

        .profile-row-chevron {
            color: var(--text-subtle);
            flex-shrink: 0;
        }

        .profile-row-chevron svg {
            width: 16px;
            height: 16px;
        }

        .profile-row.danger .profile-row-text {
            color: var(--danger);
        }

        .profile-row.danger .profile-row-icon {
            color: var(--danger);
        }

        /* Profile header */
        .profile-header { display: flex; flex-direction: column; align-items: center; padding: 24px 0 20px; }
        .profile-avatar { width: 56px; height: 56px; border-radius: 16px; background: rgba(255,255,255,0.08); display: flex; align-items: center; justify-content: center; margin-bottom: 12px; }
        .profile-avatar svg { width: 28px; height: 28px; }
        .profile-name { font-size: 22px; font-weight: 800; color: var(--text-primary); }
        .profile-meta { font-size: 12px; color: var(--text-muted); margin-top: 4px; display: flex; gap: 8px; align-items: center; }

        /* Tier badge */
        .profile-tier-badge { padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .profile-tier-badge.pro { background: var(--accent-volt); color: #0A0A0A; }
        .profile-tier-badge.trial { background: rgba(79,195,247,0.2); color: #4FC3F7; }
        .profile-tier-badge.free { background: rgba(255,255,255,0.08); color: var(--text-muted); }

        /* Stroke proficiency */
        .profile-proficiency-row { padding: 12px 0; border-bottom: 1px solid var(--border-subtle); }
        .profile-proficiency-row:last-child { border-bottom: none; }
        .profile-proficiency-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .profile-proficiency-type { font-size: 15px; font-weight: 600; color: var(--text-primary); }
        .profile-proficiency-score { font-size: 18px; font-weight: 700; font-variant-numeric: tabular-nums; }
        .profile-proficiency-bar { height: 4px; background: rgba(255,255,255,0.08); border-radius: 2px; overflow: hidden; margin-bottom: 4px; }
        .profile-proficiency-bar-fill { height: 100%; border-radius: 2px; }
        .profile-proficiency-detail { font-size: 11px; color: var(--text-muted); }

        /* Milestones & Goals pills */
        .profile-milestones, .profile-goals { display: flex; flex-wrap: wrap; gap: 8px; }
        .profile-milestone-pill { padding: 6px 12px; border-radius: 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); font-size: 12px; color: var(--text-primary); font-weight: 500; }
        .profile-goal-chip { padding: 6px 12px; border-radius: 8px; background: rgba(205,255,0,0.08); border: 1px solid rgba(205,255,0,0.15); font-size: 12px; color: var(--accent-volt); font-weight: 500; }

        /* ============================================
           LIVE SESSION CONTROLS
           ============================================ */
        #liveSessionControls {
            position: fixed;
            bottom: calc(24px + env(safe-area-inset-bottom));
            left: 0;
            right: 0;
            z-index: 150;
            display: none;
            justify-content: center;
            align-items: center;
            gap: 28px;
            pointer-events: none;
        }

        #liveSessionControls.active {
            display: flex;
        }

        .live-ctrl {
            pointer-events: auto;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: transform 0.12s;
        }

        .live-ctrl:active {
            transform: scale(0.9);
        }

        .live-ctrl-sm {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .live-ctrl-sm svg {
            width: 20px;
            height: 20px;
        }

        #liveRecBtn {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .rec-inner {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--danger);
            transition: all 0.2s ease;
        }

        #liveRecBtn.recording .rec-inner {
            width: 22px;
            height: 22px;
            border-radius: 4px;
        }

        #liveRecBtn.recording {
            border-color: var(--accent-volt);
            box-shadow: 0 0 20px rgba(205, 255, 0, 0.25);
        }

        #liveRecLabel {
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            white-space: nowrap;
            font-family: var(--font-family);
        }

        /* ============================================
           SETTINGS BOTTOM SHEET
           ============================================ */
        #settingsSheet {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 600;
            display: none;
        }

        #settingsSheet.active {
            display: block;
        }

        .settings-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #settingsSheet.active .settings-backdrop {
            opacity: 1;
        }

        .settings-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-radius: 16px 16px 0 0;
            padding: 12px 20px calc(20px + env(safe-area-inset-bottom));
            transform: translateY(100%);
            transition: transform 0.35s cubic-bezier(0.32, 0.72, 0, 1);
        }

        #settingsSheet.active .settings-panel {
            transform: translateY(0);
        }

        .settings-drag-handle {
            width: 36px;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 auto 20px;
        }

        .settings-title {
            font-size: 17px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        /* Upload tab adjustments */
        .tab-panel .analysis-mode-container {
            position: relative;
            display: flex;
            flex: 1;
            height: calc(100vh - 160px);
        }

        .tab-panel .analysis-mode-container.active {
            display: flex;
        }

        /* ============================================
           SESSION RECAP — FULL-SCREEN OVERLAY
           ============================================ */
        .session-recap {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: #0A0A0A;
            transform: translateY(100%);
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
            overflow: hidden;
        }
        .session-recap.visible {
            transform: translateY(0);
            opacity: 1;
        }
        .recap-scroll {
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 20px calc(env(safe-area-inset-bottom, 20px) + 20px);
        }
        .recap-card {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 20px;
            margin-bottom: 16px;
            opacity: 0;
            animation: fadeSlideUp 0.5s ease forwards;
        }
        .recap-card-transparent {
            background: none;
            border: none;
            padding: 20px;
            margin-bottom: 16px;
            opacity: 0;
            animation: fadeSlideUp 0.5s ease forwards;
        }
        .recap-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255,255,255,0.45);
            margin-bottom: 14px;
            font-weight: 600;
        }

        /* Hero Score */
        .recap-hero {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
            padding-bottom: 10px;
        }
        .recap-score-ring-wrap {
            position: relative;
            width: 120px;
            height: 120px;
            margin-bottom: 16px;
        }
        .recap-score-ring {
            width: 120px;
            height: 120px;
            transform: rotate(-90deg);
        }
        .recap-score-ring .ring-bg {
            fill: none;
            stroke: rgba(255,255,255,0.08);
            stroke-width: 6;
        }
        .recap-score-ring .ring-fill {
            fill: none;
            stroke: var(--accent-volt);
            stroke-width: 6;
            stroke-linecap: round;
            stroke-dasharray: 339.292;
            stroke-dashoffset: 339.292;
            animation: ringDraw 1s cubic-bezier(0.16, 1, 0.3, 1) 0.3s forwards;
        }
        .recap-score-value {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            font-weight: 800;
            color: #fff;
            font-variant-numeric: tabular-nums;
            line-height: 1;
        }
        .recap-score-value small {
            font-size: 14px;
            font-weight: 400;
            color: rgba(255,255,255,0.4);
            margin-top: 2px;
        }
        .recap-meta {
            display: flex;
            gap: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 13px;
            margin-bottom: 14px;
        }
        .recap-improvement-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
        }
        .recap-improvement-pill.positive {
            background: rgba(50,215,75,0.15);
            color: #32D74B;
        }
        .recap-improvement-pill.negative {
            background: rgba(255,59,48,0.15);
            color: #FF3B30;
        }
        .recap-improvement-pill.neutral {
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.5);
        }
        .recap-milestones {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
            justify-content: center;
        }
        .recap-milestone {
            background: linear-gradient(135deg, var(--accent-volt), #a0cc00);
            color: #0A0A0A;
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 12px;
        }

        /* Sparkline */
        .recap-sparkline {
            width: 100%;
            overflow: hidden;
        }
        .recap-sparkline svg {
            display: block;
            width: 100%;
            height: 80px;
        }

        /* Insight */
        .recap-insight {
            background: linear-gradient(135deg, rgba(79,195,247,0.12), rgba(205,255,0,0.08));
            border: 1px solid rgba(79,195,247,0.25);
            border-radius: 14px;
            padding: 20px;
            margin-bottom: 16px;
            opacity: 0;
            animation: fadeSlideUp 0.5s ease forwards;
        }
        .recap-insight-headline {
            font-size: 17px;
            font-weight: 700;
            color: #fff;
            line-height: 1.35;
            margin-bottom: 6px;
        }
        .recap-insight-detail {
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            line-height: 1.45;
            margin-bottom: 8px;
        }
        .recap-insight-action {
            font-size: 13px;
            color: var(--accent-volt);
            font-weight: 600;
        }

        /* Stroke Breakdown */
        .recap-breakdown-row {
            padding: 12px 0;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .recap-breakdown-row:last-of-type {
            border-bottom: none;
        }
        .recap-breakdown-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .recap-breakdown-type {
            font-size: 15px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
        }
        .recap-breakdown-score {
            font-size: 18px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .recap-breakdown-bar-track {
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            overflow: hidden;
        }
        .recap-breakdown-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .recap-breakdown-count {
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            margin-top: 4px;
        }
        .recap-breakdown-detail {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .recap-breakdown-row.expanded .recap-breakdown-detail {
            max-height: 120px;
        }
        .recap-breakdown-detail-inner {
            padding: 10px 0 4px;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        .recap-detail-chip {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 6px;
            background: rgba(255,255,255,0.06);
            color: rgba(255,255,255,0.7);
        }
        .recap-detail-chip.fault {
            background: rgba(255,59,48,0.15);
            color: #FF6961;
        }
        .recap-rally-footer {
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid rgba(255,255,255,0.08);
            font-size: 13px;
            color: rgba(255,255,255,0.4);
        }

        /* Coach's Notes */
        .recap-coach {
            display: flex;
            gap: 14px;
            align-items: flex-start;
        }
        .recap-coach-avatar {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .recap-coach-avatar svg {
            width: 22px;
            height: 22px;
        }
        .recap-coach-name {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: rgba(255,255,255,0.45);
            font-weight: 600;
            margin-bottom: 6px;
        }
        .recap-coach-quote {
            font-size: 14px;
            font-style: italic;
            color: rgba(255,255,255,0.8);
            line-height: 1.6;
        }
        .recap-visual-progress {
            margin-top: 12px;
            font-size: 13px;
            color: rgba(255,215,0,0.85);
            line-height: 1.5;
            font-style: normal;
        }

        /* Best Moments */
        .recap-moments-scroll {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 4px;
            scrollbar-width: none;
        }
        .recap-moments-scroll::-webkit-scrollbar { display: none; }
        .recap-moment {
            flex: 0 0 90px;
            height: 140px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            scroll-snap-align: start;
            cursor: pointer;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        .recap-moment:active {
            border-color: var(--accent-volt);
        }
        .recap-moment canvas {
            width: 90px;
            height: 100px;
            display: block;
        }
        .recap-moment-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 4px 0;
            gap: 1px;
        }
        .recap-moment-score {
            font-size: 16px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .recap-moment-label {
            font-size: 9px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Progress */
        .recap-progress-section {
            margin-bottom: 14px;
        }
        .recap-progress-section:last-child {
            margin-bottom: 0;
        }
        .recap-progress-sublabel {
            font-size: 12px;
            color: rgba(255,255,255,0.35);
            margin-bottom: 8px;
            font-weight: 500;
        }
        .recap-progress-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: rgba(255,255,255,0.04);
            border-radius: 8px;
        }
        .recap-progress-type {
            color: rgba(255,255,255,0.8);
            font-size: 14px;
        }
        .recap-progress-delta {
            font-weight: 600;
            font-size: 14px;
            font-variant-numeric: tabular-nums;
        }

        /* Plan */
        .recap-plan-card {
            background: rgba(255,255,255,0.04);
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 10px;
        }
        .recap-plan-area {
            font-weight: 600;
            color: #4FC3F7;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .recap-plan-target {
            font-size: 13px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 10px;
        }
        .recap-plan-drill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid var(--accent-volt);
            border-radius: 8px;
            color: var(--accent-volt);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            background: rgba(205,255,0,0.06);
            transition: background 0.2s;
        }
        .recap-plan-drill:active {
            background: rgba(205,255,0,0.15);
        }
        .recap-plan-goal {
            margin-top: 10px;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            font-style: italic;
        }

        /* Actions */
        .recap-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .recap-btn-primary {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--accent-volt), #a0cc00);
            color: #0A0A0A;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            letter-spacing: 0.3px;
        }
        .recap-btn-secondary {
            width: 100%;
            padding: 16px;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            background: rgba(255,255,255,0.06);
            color: rgba(255,255,255,0.8);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
        }

        @keyframes fadeSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes ringDraw {
            to { stroke-dashoffset: var(--ring-target); }
        }

        /* ============================================
           RESPONSIVE — SMALL PHONES
           ============================================ */
        @media (max-width: 380px) {
            .recap-score-ring-wrap,
            .recap-score-ring {
                width: 100px;
                height: 100px;
            }
            .recap-score-value {
                font-size: 36px;
            }
            .recap-moment {
                flex: 0 0 80px;
                height: 120px;
            }
            .recap-moment canvas {
                width: 80px;
                height: 85px;
            }
            .tab-btn span {
                font-size: 9px;
            }
            .tab-btn svg {
                width: 20px;
                height: 20px;
            }
            #liveRecBtn {
                width: 64px;
                height: 64px;
            }
            .rec-inner {
                width: 24px;
                height: 24px;
            }
            .live-ctrl-sm {
                width: 40px;
                height: 40px;
            }
            .home-greeting {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Auth: Checking Session -->
        <div id="checkingAuthScreen" class="screen">
            <div class="onboarding-content">
                <div class="hero-title">ACE<span class="accent">.</span></div>
                <div class="hero-subtitle">AI TENNIS COACH</div>
                <div style="margin-top: 40px;">
                    <div class="loading-spinner" style="width:40px;height:40px;border:3px solid rgba(205,255,0,0.2);border-top-color:#CDFF00;border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto;"></div>
                    <div style="color:rgba(255,255,255,0.5);font-size:13px;margin-top:16px;">Checking session...</div>
                </div>
            </div>
        </div>

        <!-- Onboarding 1: Sport Selection -->
        <div id="obSportScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="ob-question">What sport do you play?</div>
                <div class="ob-card-grid">
                    <div class="ob-card selected" onclick="obSelectSport('tennis')">
                        <div class="ob-card-icon"><svg viewBox="0 0 24 24" width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M18.09 6.51c-2.07 2.82-3.18 6.13-3.18 9.49M5.91 17.49c2.07-2.82 3.18-6.13 3.18-9.49"/></svg></div>
                        <div class="ob-card-text">
                            <div class="ob-card-title">Tennis</div>
                            <div class="ob-card-desc">Singles &amp; doubles coaching</div>
                        </div>
                        <div class="ob-card-check"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#0A0A0A" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg></div>
                    </div>
                </div>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:9%"></div></div>
        </div>

        <!-- Onboarding 2: Skill Level (NTRP) -->
        <div id="obSkillScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="ob-question">What's your level?</div>
                <div class="ob-card-grid" id="obSkillCards">
                    <div class="ob-card" onclick="obSelectSkill('2.0-2.5', this)">
                        <div class="ob-card-text"><div class="ob-card-title">2.0 - 2.5</div><div class="ob-card-desc">Beginner &mdash; Learning fundamentals</div></div>
                        <div class="ob-card-check"></div>
                    </div>
                    <div class="ob-card" onclick="obSelectSkill('3.0-3.5', this)" style="animation-delay:80ms">
                        <div class="ob-card-text"><div class="ob-card-title">3.0 - 3.5</div><div class="ob-card-desc">Intermediate &mdash; Consistent rallies</div></div>
                        <div class="ob-card-check"></div>
                    </div>
                    <div class="ob-card" onclick="obSelectSkill('4.0-4.5', this)" style="animation-delay:160ms">
                        <div class="ob-card-text"><div class="ob-card-title">4.0 - 4.5</div><div class="ob-card-desc">Advanced &mdash; Strong all-court game</div></div>
                        <div class="ob-card-check"></div>
                    </div>
                    <div class="ob-card" onclick="obSelectSkill('5.0+', this)" style="animation-delay:240ms">
                        <div class="ob-card-text"><div class="ob-card-title">5.0+</div><div class="ob-card-desc">Elite &mdash; Tournament-level play</div></div>
                        <div class="ob-card-check"></div>
                    </div>
                </div>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:18%"></div></div>
        </div>

        <!-- Onboarding 3: Improvement Goals -->
        <div id="obGoalsScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="ob-question">What do you want to improve?</div>
                <div class="ob-subtitle">Select all that apply</div>
                <div class="ob-chip-grid" id="obGoalChips">
                    <div class="ob-chip" onclick="obToggleGoal('forehand', this)">Forehand</div>
                    <div class="ob-chip" onclick="obToggleGoal('backhand', this)">Backhand</div>
                    <div class="ob-chip" onclick="obToggleGoal('serve', this)">Serve</div>
                    <div class="ob-chip" onclick="obToggleGoal('volleys', this)">Volleys</div>
                    <div class="ob-chip" onclick="obToggleGoal('footwork', this)">Footwork</div>
                    <div class="ob-chip" onclick="obToggleGoal('consistency', this)">Consistency</div>
                    <div class="ob-chip" onclick="obToggleGoal('power', this)">Power</div>
                    <div class="ob-chip" onclick="obToggleGoal('strategy', this)">Strategy</div>
                </div>
                <input class="ob-input" id="obCustomGoal" placeholder="Something else? Tell us..." style="margin-bottom:24px;" />
                <button class="btn-primary" id="obGoalsContinue" onclick="obSubmitGoals()" disabled>
                    CONTINUE <span style="margin-left:4px;">&rarr;</span>
                </button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:27%"></div></div>
        </div>

        <!-- Onboarding 4: About You (skippable) -->
        <div id="obAboutScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="ob-question">Tell us about yourself</div>
                <div class="ob-subtitle">Optional &mdash; helps personalize coaching</div>
                <input class="ob-input" id="obNameInput" placeholder="Your name" style="margin-bottom:12px;" />
                <input class="ob-input" id="obAgeInput" placeholder="Age" type="number" min="5" max="99" style="margin-bottom:24px;" />
                <button class="btn-primary" onclick="obSubmitAbout()">
                    CONTINUE <span style="margin-left:4px;">&rarr;</span>
                </button>
                <button class="btn-skip" onclick="obSkipAbout()">Skip</button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:36%"></div></div>
        </div>

        <!-- Onboarding 5: Choose Your Coach -->
        <div id="obCoachScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="ob-question">Choose your coach</div>
                <div class="ob-card-grid" id="obCoachCards"></div>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:45%"></div></div>
        </div>

        <!-- Onboarding 6: Meet Your Coach (voice) -->
        <div id="obMeetScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div id="obMeetCoachName" style="font-size:12px;color:#555;text-transform:uppercase;letter-spacing:0.15em;margin-bottom:8px;">COACH ALEX</div>
                <div class="ob-question" style="margin-bottom:16px;">Let's chat!</div>
                <div class="ob-coach-wave" id="obCoachWave">
                    <div class="bar" style="animation-delay:0s;height:12px;"></div>
                    <div class="bar" style="animation-delay:0.15s;height:20px;"></div>
                    <div class="bar" style="animation-delay:0.3s;height:28px;"></div>
                    <div class="bar" style="animation-delay:0.45s;height:20px;"></div>
                    <div class="bar" style="animation-delay:0.6s;height:12px;"></div>
                </div>
                <div style="font-size:13px;color:#666;text-align:center;margin-bottom:32px;" id="obMeetStatus">Connecting...</div>
                <button class="btn-primary" id="obLetsHitBtn" onclick="obFinishMeetCoach()">
                    LET'S HIT! <span style="margin-left:4px;">&rarr;</span>
                </button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:54%"></div></div>
        </div>

        <!-- Onboarding 7: Camera Permission -->
        <div id="obCameraScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div style="margin-bottom:24px;color:var(--text-muted);"><svg viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></div>
                <div class="ob-question">I need to see your strokes</div>
                <div style="font-size:13px;color:#555;text-align:center;margin-bottom:32px;line-height:1.6;">
                    ACE uses your camera to analyze your technique in real time.<br>No video is stored or sent to servers.
                </div>
                <button class="btn-primary" onclick="obRequestTrialCamera()">
                    ALLOW CAMERA <span style="margin-left:4px;">&rarr;</span>
                </button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:63%"></div></div>
        </div>

        <!-- Onboarding 8: Trial overlay (shows on top of main app) -->
        <div id="obTrialOverlay" style="display:none;">
            <div class="ob-trial-counter" id="obTrialCounter">Stroke 0/5</div>
        </div>

        <!-- Onboarding 9: Report Card -->
        <div id="obReportScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div style="font-size:12px;color:#555;text-transform:uppercase;letter-spacing:0.15em;margin-bottom:8px;">YOUR REPORT CARD</div>
                <div class="ob-question" style="font-size:48px;margin-bottom:8px;" id="obReportScore">--</div>
                <div style="font-size:13px;color:#666;margin-bottom:24px;">Average Quality Score</div>
                <div class="ob-report-card" id="obReportDetails"></div>
                <div style="background:rgba(205,255,0,0.05);border:1px solid rgba(205,255,0,0.15);border-radius:12px;padding:16px;margin:24px 0;">
                    <div style="font-size:11px;color:#CDFF00;text-transform:uppercase;letter-spacing:0.1em;margin-bottom:8px;">Your coach says...</div>
                    <div style="font-size:14px;color:#ccc;line-height:1.5;" id="obCoachNoteText"></div>
                </div>
                <button class="btn-primary" onclick="obGoToSignup()">
                    SIGN UP TO KEEP IMPROVING <span style="margin-left:4px;">&rarr;</span>
                </button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:81%"></div></div>
        </div>

        <!-- Onboarding 10: Sign Up (magic link) -->
        <div id="obSignupScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="hero-title" style="font-size:48px;">ACE<span class="accent">.</span></div>
                <div class="ob-question" style="font-size:18px;">Create your account</div>
                <div class="api-input-group" style="width:100%;">
                    <label class="api-label">EMAIL ADDRESS</label>
                    <div class="api-input-wrapper">
                        <input type="email" id="obSignupEmail" class="api-input" placeholder="you@example.com" autocomplete="email" />
                    </div>
                </div>
                <button class="btn-primary" id="obSignupBtn" onclick="obSendMagicLink()" style="margin-top:16px;">
                    SEND MAGIC LINK <span style="margin-left:4px;">&rarr;</span>
                </button>
                <div id="obSignupStatus" style="color:rgba(255,255,255,0.5);font-size:13px;margin-top:12px;text-align:center;min-height:20px;"></div>
                <button class="btn-skip" onclick="obSkipSignup()">Continue without account</button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:90%"></div></div>
        </div>

        <!-- Onboarding 11: Pricing -->
        <div id="obPricingScreen" class="screen" style="display:none;">
            <div class="onboarding-content">
                <div class="ob-question">Choose your plan</div>
                <div class="ob-pricing-grid">
                    <div class="ob-pricing-card highlight">
                        <div class="ob-pricing-badge">RECOMMENDED</div>
                        <div class="ob-pricing-name">Pro</div>
                        <div class="ob-pricing-price">$14.99/mo or $99.99/yr</div>
                        <ul class="ob-pricing-features">
                            <li>Unlimited sessions</li>
                            <li>Unlimited stroke analysis</li>
                            <li>Full voice coaching</li>
                            <li>Improvement tracking &amp; plans</li>
                            <li>Instant replay</li>
                            <li>Drills &amp; curriculum</li>
                        </ul>
                    </div>
                    <div class="ob-pricing-card">
                        <div class="ob-pricing-name">Free</div>
                        <div class="ob-pricing-price">$0/mo</div>
                        <ul class="ob-pricing-features">
                            <li>1 session per month</li>
                            <li>10 strokes analyzed</li>
                            <li>2 coaching observations</li>
                        </ul>
                    </div>
                </div>
                <button class="btn-primary" onclick="obStartFreeTrial()">
                    START 7-DAY FREE TRIAL <span style="margin-left:4px;">&rarr;</span>
                </button>
                <div style="font-size:11px;color:#555;text-align:center;margin-top:8px;">No credit card required</div>
                <button class="btn-skip" onclick="obContinueWithFree()">Continue with Free</button>
            </div>
            <div class="ob-progress"><div class="ob-progress-fill" style="width:100%"></div></div>
        </div>

        <!-- Returning User Welcome -->
        <div id="permissionScreen" class="screen" style="display: none;">
            <div class="onboarding-content">
                <div class="hero-title">ACE<span class="accent">.</span></div>
                <div class="hero-subtitle" id="heroSubtitle">AI TENNIS COACH</div>
                <div class="hero-session-count" id="heroSessionCount" style="display: none;"></div>

                <div class="feature-list" id="featureList">
                    <div class="feature-card">
                        <div class="feature-icon"><svg viewBox="0 0 24 24"><polyline points="2 12 5 12 7 8 10 16 13 10 16 14 19 12 22 12"/></svg></div>
                        <div class="feature-content"><div class="feature-title">Real-Time Analysis</div><div class="feature-desc">30fps pose detection</div></div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon"><svg viewBox="0 0 24 24"><line x1="8" y1="8" x2="8" y2="16"/><line x1="12" y1="5" x2="12" y2="19"/><line x1="16" y1="8" x2="16" y2="16"/></svg></div>
                        <div class="feature-content"><div class="feature-title">Voice Coaching</div><div class="feature-desc">Real-time spoken feedback</div></div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon"><svg viewBox="0 0 24 24"><line x1="6" y1="20" x2="6" y2="14"/><line x1="12" y1="20" x2="12" y2="8"/><line x1="18" y1="20" x2="18" y2="11"/></svg></div>
                        <div class="feature-content"><div class="feature-title">Pro Comparison</div><div class="feature-desc">Match elite benchmarks</div></div>
                    </div>
                </div>

                <button class="btn-primary" onclick="requestCameraPermission()">
                    GET STARTED <span style="margin-left: 4px;">&rarr;</span>
                </button>
            </div>
        </div>

        <!-- Onboarding Step 3: Loading -->
        <div id="loadingScreen" class="screen" style="display: none;">
            <div class="onboarding-content">
                <div class="loading-content">
                    <div class="loading-logo">
                        <!-- ACE Logo Mark: Ball + Chevron -->
                        <svg viewBox="0 0 64 64" fill="none">
                            <circle cx="20" cy="32" r="10" fill="#CDFF00"/>
                            <path d="M38 16L54 32L38 48L42 48L58 32L42 16Z" fill="#CDFF00"/>
                        </svg>
                    </div>
                    <div class="loading-phase" id="loadingPhase">LOADING</div>
                    <div class="loading-detail" id="loadingDetail">Initializing pose detection model</div>
                    <div class="loading-track">
                        <div class="loading-fill" id="loadingFill"></div>
                    </div>
                </div>
            </div>

            <div class="step-indicator">
                <div class="step-dot active"></div>
                <div class="step-dot active"></div>
                <div class="step-dot active"></div>
            </div>
        </div>

        <!-- Toast Notification Container -->
        <div class="toast" id="toast"></div>

        <!-- Main Camera Interface -->
        <div class="camera-container" style="display: none;" id="cameraContainer">
            <video id="videoElement" playsinline autoplay muted></video>
            <canvas id="canvasElement"></canvas>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-label">STROKES</div>
                    <div class="status-value" id="strokeCount">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">AVG SCORE</div>
                    <div class="status-value muted" id="avgScore">--</div>
                </div>
                <div class="status-item">
                    <div class="status-label">CONSISTENCY</div>
                    <div class="status-value muted" id="consistencyScore">--</div>
                </div>
                <div class="status-item">
                    <div class="status-label">AI COACH</div>
                    <div class="ai-status">
                        <div id="aiStatusDot" class="status-dot"></div>
                    </div>
                </div>
                <div class="status-item" id="rallyStatus" style="display: none;">
                    <div class="status-label">RALLY</div>
                    <div class="status-value" id="rallyStateValue" style="font-size: 11px;">--</div>
                </div>
            </div>

            <!-- Analysis Card -->
            <div id="analysisCard" class="analysis-card">
                <div id="strokeType" class="stroke-type">FOREHAND</div>
                <div id="techniqueScore" class="technique-score">85</div>
                <div class="score-label">SCORE</div>

                <div class="advanced-metrics">
                    <div class="metric-item">
                        <div class="metric-label">ELBOW</div>
                        <div class="metric-value" id="elbowAngleMetric">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">ROTATION</div>
                        <div class="metric-value" id="hipSepMetric">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">STANCE</div>
                        <div class="metric-value" id="stanceMetric">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">WEIGHT</div>
                        <div class="metric-value" id="weightMetric">--</div>
                    </div>

                    <div class="metric-item" style="grid-column: span 2;">
                        <div class="metric-label">LEVEL</div>
                        <div class="metric-value" id="skillLevelMetric" style="color: var(--accent-volt);">--</div>
                    </div>
                </div>
            </div>

            <!-- Ghost Similarity Display -->
            <div id="ghostSimilarityDisplay" class="ghost-similarity" style="display: none;">
                <div class="ghost-similarity-label">GHOST MATCH</div>
                <div class="ghost-similarity-value" id="ghostSimilarityValue">--</div>
            </div>

            <!-- Old controls removed — replaced by live session controls -->

            <!-- Coaching Panel -->
            <div class="coaching-panel">
                <div class="coaching-drag-handle"></div>
                <div class="coaching-header">
                    <span class="coaching-label">AI COACH</span>
                    <span class="coaching-dot"></span>
                </div>
                <div id="phaseIndicator" class="phase-indicator" style="display: none;">
                    <div class="phase-step" data-phase="preparation">PREP</div>
                    <div class="phase-step" data-phase="loading">LOAD</div>
                    <div class="phase-step" data-phase="acceleration">ACCEL</div>
                    <div class="phase-step" data-phase="contact">HIT</div>
                    <div class="phase-step" data-phase="followThrough">FINISH</div>
                </div>
                <div id="faultChips" class="fault-chips"></div>
                <div id="coachingText" class="coaching-text">
                    Ready. Stand in frame and swing to begin analysis.
                </div>
            </div>

            <!-- Old mode-switcher removed — replaced by bottom tab bar -->

            <!-- Analysis Mode Container -->
            <div class="analysis-mode-container" id="analysisModeContainer">
                <!-- Video Upload Zone -->
                <div class="video-upload-zone" id="videoUploadZone">
                    <div class="upload-icon" style="font-size: 24px; font-weight: bold; letter-spacing: 2px;">VIDEO</div>
                    <div class="upload-text">Drop a video here or click to upload</div>
                    <div class="upload-subtext">Supports MP4, MOV, WebM</div>
                    <input type="file" id="videoFileInput" accept="video/*" style="display: none;">
                </div>

                <!-- Video Player Area -->
                <div class="video-player-area" id="videoPlayerArea">
                    <div class="video-container">
                        <video id="analysisVideo" playsinline></video>
                        <canvas id="analysisCanvas"></canvas>
                    </div>

                    <!-- Timeline -->
                    <div class="timeline-container">
                        <div class="timeline-controls">
                            <button class="timeline-playback-btn" id="timelinePlayBtn" onclick="toggleVideoPlayback()">PLAY</button>
                            <span class="timeline-time" id="timelineTime">0:00 / 0:00</span>
                            <div style="margin-left: auto; display: flex; gap: 8px;">
                                <button class="btn btn-secondary" onclick="exportHighlightReel()" style="padding: 8px 12px; font-size: 11px;" title="Export best 5 strokes">
                                    Best 5
                                </button>
                                <button class="btn btn-secondary" onclick="exportBlooperReel()" style="padding: 8px 12px; font-size: 11px;" title="Export worst 5 for learning">
                                    Learn 5
                                </button>
                                <button class="btn btn-secondary" onclick="clearAnalysisVideo()" style="padding: 8px 12px; font-size: 11px;">
                                    New
                                </button>
                            </div>
                        </div>
                        <div class="timeline-track" id="timelineTrack">
                            <div class="timeline-progress" id="timelineProgress"></div>
                            <div class="timeline-playhead" id="timelinePlayhead"></div>
                            <!-- Stroke markers will be inserted here -->
                        </div>
                    </div>

                    <!-- Stroke Details Panel -->
                    <div class="stroke-details-panel" id="strokeDetailsPanel">
                        <div class="stroke-details-header">
                            <span class="stroke-details-type" id="strokeDetailType">Forehand</span>
                            <span class="stroke-details-score" id="strokeDetailScore" style="color: var(--accent-volt, #CDFF00);">85</span>
                        </div>
                        <div class="stroke-details-metrics">
                            <div class="stroke-metric">
                                <div class="stroke-metric-value" id="strokeDetailTime">0:00</div>
                                <div class="stroke-metric-label">Time</div>
                            </div>
                            <div class="stroke-metric">
                                <div class="stroke-metric-value" id="strokeDetailVelocity">--</div>
                                <div class="stroke-metric-label">Velocity</div>
                            </div>
                        </div>
                        <div style="margin-top: 12px; display: flex; gap: 8px;">
                            <button class="btn btn-secondary" onclick="addToComparison()" style="flex: 1; padding: 8px; font-size: 11px;" id="compareBtn">
                                + Compare
                            </button>
                            <button class="btn btn-secondary" onclick="hideStrokeDetails()" style="padding: 8px 12px; font-size: 11px;">
                                ×
                            </button>
                        </div>
                    </div>

                    <!-- Comparison Panel -->
                    <div class="stroke-details-panel" id="comparisonPanel" style="left: 20px; right: auto; transform: translateX(-320px);">
                        <div style="font-size: 12px; font-weight: bold; text-transform: uppercase; margin-bottom: 12px; color: var(--accent-volt);">
                            Comparing 2 Strokes
                        </div>
                        <div id="comparisonContent">
                            <!-- Dynamic comparison content -->
                        </div>
                        <button class="btn btn-secondary" onclick="clearComparison()" style="width: 100%; margin-top: 12px; padding: 8px; font-size: 11px;">
                            Clear Comparison
                        </button>
                    </div>

                    <!-- Analysis Progress Overlay -->
                    <div class="analysis-progress-overlay" id="analysisProgressOverlay">
                        <div class="analysis-progress-text">Analyzing video...</div>
                        <div class="analysis-progress-bar">
                            <div class="analysis-progress-fill" id="analysisProgressFill"></div>
                        </div>
                        <div style="margin-top: 12px; font-size: 14px; color: rgba(255,255,255,0.6);" id="analysisProgressPercent">0%</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================
             BOTTOM TAB BAR
             ============================================ -->
        <nav id="bottomTabBar" style="display:none;">
            <button class="tab-btn active" data-tab="home" onclick="switchTab('home')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>
                <span>Home</span>
            </button>
            <button class="tab-btn" data-tab="upload" onclick="switchTab('upload')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                <span>Upload</span>
            </button>
            <button class="tab-btn" data-tab="drills" onclick="switchTab('drills')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
                <span>Drills</span>
            </button>
            <button class="tab-btn" data-tab="challenges" onclick="switchTab('challenges')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5C7 4 6 9 6 9z"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5C17 4 18 9 18 9z"/><path d="M4 22h16"/><path d="M10 22V8h4v14"/><path d="M6 9h12v4H6z"/></svg>
                <span>Challenges</span>
            </button>
            <button class="tab-btn" data-tab="profile" onclick="switchTab('profile')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                <span>Profile</span>
            </button>
        </nav>

        <!-- ============================================
             TAB CONTENT PANELS
             ============================================ -->
        <div id="tabContent">
            <!-- Home Tab -->
            <div class="tab-panel active" id="tabHome">
                <div class="home-header">
                    <div>
                        <div class="home-greeting" id="homeGreetingText">ACE<span class="accent">.</span></div>
                        <div class="home-greeting-coach" id="homeCoachLine"></div>
                        <div class="home-greeting-progress" id="homeProgressTidbit"></div>
                    </div>
                    <button class="home-settings-btn" onclick="openSettings()">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1.08-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1.08 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1.08 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c.26.604.852.997 1.51 1H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1.08z"/></svg>
                    </button>
                </div>

                <!-- Start Live Session CTA -->
                <button class="home-cta home-cta-primary" onclick="startLiveSession()">
                    <div class="cta-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4" fill="currentColor" stroke="none"/></svg>
                    </div>
                    <div>
                        <div class="home-cta-title">Start Live Session</div>
                        <div class="home-cta-subtitle">Camera coaching on court</div>
                    </div>
                </button>

                <!-- Upload Video CTA -->
                <button class="home-cta home-cta-secondary" onclick="switchTab('upload')">
                    <div class="cta-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                    </div>
                    <div>
                        <div class="home-cta-title">Upload Video</div>
                        <div class="home-cta-subtitle">Analyze recorded footage</div>
                    </div>
                </button>

                <!-- Quick Stats -->
                <div class="home-card" id="homeStatsCard" style="display:none;">
                    <div class="home-card-title">Last Session</div>
                    <div class="home-stats-row" id="homeStatsRow">
                        <div class="home-stat">
                            <div class="home-stat-value" id="homeStatAvg">--</div>
                            <div class="home-stat-label">Avg Quality</div>
                        </div>
                        <div class="home-stat">
                            <div class="home-stat-value" id="homeStatStrokes">--</div>
                            <div class="home-stat-label">Strokes</div>
                        </div>
                        <div class="home-stat">
                            <div class="home-stat-value" id="homeStatSessions">--</div>
                            <div class="home-stat-label">Sessions</div>
                        </div>
                    </div>
                </div>

                <!-- Improvement Plan Preview -->
                <div class="home-card" id="homePlanCard" style="display:none;">
                    <div class="home-card-title">Improvement Plan</div>
                    <div id="homePlanItems"></div>
                </div>

                <!-- Pro Comparison CTA -->
                <button class="home-cta home-cta-secondary" onclick="showProComparison()">
                    <div class="cta-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                    </div>
                    <div>
                        <div class="home-cta-title">Pro Comparison</div>
                        <div class="home-cta-subtitle">Compare to Federer, Nadal & more</div>
                    </div>
                </button>
            </div>

            <!-- Upload Tab -->
            <div class="tab-panel" id="tabUpload">
                <div class="tab-section-title">Upload Video</div>
                <div id="uploadTabContent">
                    <!-- Analysis mode container relocated here dynamically by JS -->
                </div>
            </div>

            <!-- Drills Tab -->
            <div class="tab-panel" id="tabDrills">
                <div class="tab-section-title">Drills</div>
                <div id="drillTabCards"></div>
            </div>

            <!-- Challenges Tab -->
            <div class="tab-panel" id="tabChallenges">
                <div class="tab-section-title">Challenges</div>
                <div id="challengeTabCards"></div>
            </div>

            <!-- Profile Tab -->
            <div class="tab-panel" id="tabProfile">
                <div id="profileTabContent"></div>
            </div>
        </div>

        <!-- ============================================
             LIVE SESSION CONTROLS
             ============================================ -->
        <div id="liveSessionControls">
            <button class="live-ctrl live-ctrl-sm" onclick="endLiveSession()" title="End Session">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
            </button>
            <button class="live-ctrl" id="liveRecBtn" onclick="toggleAnalysis()">
                <span id="liveRecLabel">REC</span>
                <div class="rec-inner"></div>
            </button>
            <button class="live-ctrl live-ctrl-sm" onclick="flipCamera()" title="Flip Camera">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 19H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h5"/><path d="M13 5h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-5"/><polyline points="16 3 19 1 22 3"/><polyline points="8 21 5 23 2 21"/></svg>
            </button>
        </div>

        <!-- ============================================
             SETTINGS BOTTOM SHEET
             ============================================ -->
        <div id="settingsSheet">
            <div class="settings-backdrop" onclick="closeSettings()"></div>
            <div class="settings-panel">
                <div class="settings-drag-handle"></div>
                <div class="settings-title">Settings</div>

                <!-- Ghost Overlay toggle -->
                <div class="profile-row" onclick="toggleGhost(); closeSettings();">
                    <div class="profile-row-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/><line x1="12" y1="2" x2="12" y2="4"/><line x1="12" y1="20" x2="12" y2="22"/><line x1="2" y1="12" x2="4" y2="12"/><line x1="20" y1="12" x2="22" y2="12"/></svg>
                    </div>
                    <div class="profile-row-text">Ghost Overlay</div>
                    <div class="profile-row-value" id="settingsGhostStatus">Off</div>
                </div>

                <!-- Calibration -->
                <div class="profile-row" onclick="openCalibrationModal(); closeSettings();">
                    <div class="profile-row-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                    </div>
                    <div class="profile-row-text">Calibration</div>
                    <div class="profile-row-chevron">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
                    </div>
                </div>

                <!-- Sign Out (only visible when authenticated) -->
                <div class="profile-row danger" id="settingsSignOut" style="display:none;" onclick="handleSignOut()">
                    <div class="profile-row-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
                    </div>
                    <div class="profile-row-text">Sign Out</div>
                </div>
            </div>
        </div>

        <!-- Error Container -->
        <div id="errorContainer"></div>

        <!-- Stroke Quality Flash Overlay -->
        <div id="strokeFlashOverlay" class="stroke-flash-overlay"></div>

        <!-- Session Recap (full-screen overlay) -->
        <div id="sessionRecap" class="session-recap">
            <div class="recap-scroll" id="recapScroll">
                <!-- Dynamic content from showSessionSummary() -->
            </div>
        </div>

        <!-- Export Modal (reused from old session summary modal) -->
        <div id="exportModal" class="modal-overlay">
            <div class="modal">
                <div class="modal-header">
                    <div class="modal-title">Export</div>
                    <button class="modal-close" onclick="document.getElementById('exportModal').classList.remove('visible')">&times;</button>
                </div>
                <div id="exportModalContent">
                </div>
            </div>
        </div>

        <!-- Drill Selection Modal -->
        <div id="drillModal" class="modal-overlay">
            <div class="modal" style="max-width: 500px;">
                <div class="modal-header">
                    <div class="modal-title">Select Drill</div>
                    <button class="modal-close" onclick="closeDrillModal()">&times;</button>
                </div>
                <div id="drillListContent"></div>
            </div>
        </div>

        <!-- Drill Mode HUD -->
        <div id="drillHUD" class="drill-hud" style="display: none;">
            <div class="drill-hud-header">
                <div class="drill-hud-name" id="drillHudName"></div>
                <button class="drill-hud-stop" onclick="stopDrill()">STOP</button>
            </div>
            <div class="drill-hud-progress">
                <div class="drill-hud-progress-bar">
                    <div class="drill-hud-progress-fill" id="drillProgressFill" style="width: 0%"></div>
                </div>
                <div class="drill-hud-progress-text" id="drillProgressText">0/10</div>
            </div>
            <div class="drill-hud-metric" id="drillMetricDisplay" style="display: none;">
                <div class="drill-hud-metric-value" id="drillMetricValue">--</div>
                <div class="drill-hud-metric-label" id="drillMetricLabel"></div>
                <div class="drill-hud-metric-target" id="drillMetricTarget"></div>
            </div>
            <div class="drill-hud-reps" id="drillRepDots"></div>
        </div>

        <!-- Drill Summary Overlay -->
        <div id="drillSummaryOverlay" class="drill-summary-overlay" style="display: none;">
            <div class="drill-summary-content">
                <div class="drill-summary-title">Drill Complete</div>
                <div class="drill-summary-name" id="drillSummaryName"></div>
                <div class="drill-summary-stats" id="drillSummaryStats"></div>
                <div class="drill-summary-chart" id="drillSummaryChart"></div>
                <div class="drill-summary-actions">
                    <button class="btn" onclick="closeDrillSummary()">Done</button>
                    <button class="btn" onclick="repeatDrill()" style="background: transparent; border: 1px solid var(--text-muted); color: var(--text-primary);">Repeat</button>
                </div>
            </div>
        </div>

        <!-- Analytics Modal -->
        <div id="analyticsModal" class="modal-overlay">
            <div class="modal" style="max-width: 560px;">
                <div class="modal-header">
                    <div class="modal-title">Session History</div>
                    <button class="modal-close" onclick="closeAnalytics()">&times;</button>
                </div>
                <div id="analyticsContent">
                    <!-- Dynamic content inserted here -->
                </div>
            </div>
        </div>

        <!-- Active Challenge Display -->
        <div id="activeChallengeBar" class="active-challenge-bar" style="display: none;">
            <div class="challenge-info">
                <span class="challenge-icon" id="activeChallengeIcon" style="font-weight: bold; font-size: 14px;"></span>
                <span class="challenge-name" id="activeChallengeName">Challenge</span>
            </div>
            <div class="challenge-progress-bar">
                <div class="challenge-progress-fill" id="activeChallengeProgress"></div>
            </div>
            <div class="challenge-progress-text" id="activeChallengeText">0/10</div>
        </div>

        <!-- Challenge Completion Celebration -->
        <div id="challengeCompleteOverlay" class="challenge-complete-overlay" style="display: none;">
            <div class="challenge-complete-content">
                <div class="challenge-complete-icon" style="font-size: 32px; font-weight: bold; letter-spacing: 3px;">DONE</div>
                <div class="challenge-complete-title">Challenge Complete!</div>
                <div class="challenge-complete-name" id="completedChallengeName">Consistency King</div>
                <div class="challenge-complete-reward" id="completedChallengeReward">Unlocked: Advanced Analytics</div>
                <button class="btn" onclick="closeChallengeComplete()">Continue</button>
            </div>
        </div>

        <!-- Challenges Modal -->
        <div id="challengesModal" class="modal-overlay">
            <div class="modal" style="max-width: 500px;">
                <div class="modal-header">
                    <div class="modal-title">Challenges</div>
                    <button class="modal-close" onclick="closeChallenges()">&times;</button>
                </div>
                <div id="challengesContent">
                    <!-- Dynamic challenge list -->
                </div>
            </div>
        </div>

        <!-- Pro Comparison Modal -->
        <div id="proComparisonModal" class="modal-overlay">
            <div class="modal" style="max-width: 500px;">
                <div class="modal-header">
                    <div class="modal-title">Compare to Pro</div>
                    <button class="modal-close" onclick="closeProComparison()">&times;</button>
                </div>
                <div id="proComparisonContent">
                    <!-- Pro selector -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 12px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 8px;">Select a Pro</div>
                        <div class="pro-selector" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                            <button class="pro-card" onclick="selectPro('federer')" id="pro-federer">
                                <div class="pro-name">Roger Federer</div>
                                <div class="pro-style">Forehand, Serve, Volley</div>
                            </button>
                            <button class="pro-card" onclick="selectPro('djokovic')" id="pro-djokovic">
                                <div class="pro-name">Novak Djokovic</div>
                                <div class="pro-style">Backhand, Return, Defense</div>
                            </button>
                            <button class="pro-card" onclick="selectPro('nadal')" id="pro-nadal">
                                <div class="pro-name">Rafael Nadal</div>
                                <div class="pro-style">Forehand, Topspin, Defense</div>
                            </button>
                            <button class="pro-card" onclick="selectPro('serena')" id="pro-serena">
                                <div class="pro-name">Serena Williams</div>
                                <div class="pro-style">Serve, Power, Forehand</div>
                            </button>
                        </div>
                    </div>

                    <!-- Comparison results -->
                    <div id="proComparisonResults" style="display: none;">
                        <div class="summary-stats" style="margin-bottom: 16px;">
                            <div class="summary-stat highlight">
                                <div class="summary-stat-value" id="proSimilarityScore">--</div>
                                <div class="summary-stat-label">Similarity</div>
                            </div>
                        </div>

                        <div id="proComparisonDetails">
                            <!-- Dynamic comparison details -->
                        </div>

                        <div id="proCoachingTip" style="margin-top: 16px; padding: 12px; background: rgba(205, 255, 0, 0.1); border-radius: 8px; border-left: 3px solid var(--accent-volt);">
                            <!-- GPT coaching insight -->
                        </div>
                    </div>

                    <div id="proComparisonEmpty" style="text-align: center; padding: 30px; color: var(--text-muted);">
                        <div style="font-size: 14px;">Complete some strokes first to compare your technique with a pro.</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calibration Modal -->
        <div id="calibrationModal" class="modal-overlay">
            <div class="modal" style="max-width: 600px;">
                <div class="modal-header">
                    <div class="modal-title">Calibration Tool</div>
                    <button class="modal-close" onclick="closeCalibrationModal()">&times;</button>
                </div>
                <div id="calibrationContent">
                    <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">
                        Upload professional tennis videos to calibrate the analysis thresholds.
                        Use slow-motion court-level footage for best results.
                    </p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                        <div>
                            <label style="font-size: 12px; color: rgba(255,255,255,0.6);">Skill Level</label>
                            <select id="calibrationLabel" style="width: 100%; padding: 8px; border-radius: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white;">
                                <option value="professional">Professional</option>
                                <option value="advanced">Advanced</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="beginner">Beginner</option>
                            </select>
                        </div>
                        <div>
                            <label style="font-size: 12px; color: rgba(255,255,255,0.6);">Player Name</label>
                            <input type="text" id="calibrationPlayer" placeholder="e.g., Djokovic" style="width: 100%; padding: 8px; border-radius: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white;">
                        </div>
                    </div>

                    <div id="calibrationUploadZone" style="border: 2px dashed rgba(255,255,255,0.3); border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; margin-bottom: 20px;">
                        <div style="font-size: 18px; font-weight: bold; letter-spacing: 2px; margin-bottom: 12px;">UPLOAD</div>
                        <div>Drop video here or click to upload</div>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.5); margin-top: 8px;">MP4, MOV, WebM supported</div>
                        <input type="file" id="calibrationFileInput" accept="video/*" style="display: none;">
                    </div>

                    <div id="calibrationProgress" style="display: none; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span id="calibrationStatus">Processing...</span>
                            <span id="calibrationStrokeCount">0 strokes</span>
                        </div>
                        <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                            <div id="calibrationProgressBar" style="height: 100%; background: var(--accent-volt, #CDFF00); width: 0%; transition: width 0.3s;"></div>
                        </div>
                    </div>

                    <div id="calibrationResults" style="display: none;">
                        <!-- Results will be inserted here -->
                    </div>

                    <div style="display: flex; gap: 12px; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="showCalibrationStats()" style="flex: 1;">
                            View All Stats
                        </button>
                        <button class="btn btn-secondary" onclick="exportCalibrationData()" style="flex: 1;">
                            Export Data
                        </button>
                    </div>

                    <!-- Threshold Update Actions -->
                    <div id="thresholdUpdateSection" style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 14px; font-weight: bold; margin-bottom: 12px;">Apply Calibration</div>
                        <p style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 16px;">
                            Apply calibrated thresholds to improve stroke detection accuracy.
                        </p>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn" onclick="applyThresholdsToApp()" style="flex: 1; background: var(--accent-volt, #CDFF00);">
                                Apply Now
                            </button>
                            <button class="btn btn-secondary" onclick="exportThresholdUpdates()" style="flex: 1;">
                                Export Code
                            </button>
                        </div>
                        <div id="thresholdApplyStatus" style="margin-top: 12px; font-size: 12px; color: rgba(255,255,255,0.6);"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Replay Button (fixed, bottom-right) -->
    <button id="replayBtn" class="replay-btn" onclick="openReplay(this.dataset.index)">REPLAY</button>

    <!-- Replay Overlay -->
    <div id="replayOverlay" class="replay-overlay">
        <div class="replay-canvas-wrap">
            <canvas id="replayCanvas" width="640" height="480"></canvas>
        </div>
        <div class="replay-controls">
            <button class="replay-ctrl-btn" onclick="toggleReplayPlayback()" id="replayPlayPauseBtn">PAUSE</button>
            <button class="replay-ctrl-btn" onclick="setReplaySpeed(0.25)" data-speed="0.25">0.25x</button>
            <button class="replay-ctrl-btn active" onclick="setReplaySpeed(0.5)" data-speed="0.5">0.5x</button>
            <button class="replay-ctrl-btn" onclick="setReplaySpeed(1)" data-speed="1">1x</button>
            <button class="replay-ctrl-btn" onclick="replayStepFrame(-1)">&lt;</button>
            <button class="replay-ctrl-btn" onclick="replayStepFrame(1)">&gt;</button>
            <button class="replay-ctrl-btn coaches-eye-btn" onclick="toggleCoachesEye()" id="coachesEyeBtn" style="display:none">COACH'S EYE</button>
            <button class="replay-ctrl-btn close-btn" onclick="closeReplay()">CLOSE</button>
        </div>
    </div>

    <script>
        // Tennis AI Application
        class TennisAI {
            constructor() {
                this.pose = null;
                this.camera = null;
                this.isReady = false;
                this.isAnalyzing = false;
                this.currentFacingMode = 'environment';

                // Signal processing: adaptive low-pass filter + bone constraints
                this.landmarkFilter = new LandmarkFilter({
                    frequency: 30,
                    minCutoff: 1.0,
                    beta: 80.0,
                    dCutoff: 1.0,
                    enableBoneConstraints: true,
                    boneDeviationThreshold: 0.15,
                    calibrationFrames: 30
                });

                // Enhanced Analysis Engine
                this.enhancedAnalyzer = new EnhancedTennisAnalyzer();
                this.enhancedAnalyzer.setLandmarkFilter(this.landmarkFilter);
                this.enhancedAnalyzer.onStrokeCallback = (strokeData, historySnapshot) => {
                    this.freezeTrail(historySnapshot, strokeData);
                    // Show replay button after each stroke
                    if (this.replayManager && this.replayManager.getReplayCount() > 0) {
                        showReplayButton(this.replayManager.getReplayCount() - 1);
                    }
                    // Track stroke in rally
                    if (this.rallyTracker) {
                        this.rallyTracker.addStroke(strokeData);
                        this.updateRallyIndicator();
                    }
                    // Notify scene analyzer of serve detection
                    if (this.sceneAnalyzer && this.sceneAnalyzer.enabled &&
                        (strokeData.type === 'serve' || strokeData.strokeType === 'serve')) {
                        this.sceneAnalyzer.onServeDetected();
                    }
                };

                // Stroke Replay Manager
                this.replayManager = new StrokeReplayManager();
                window.strokeReplayManager = this.replayManager;

                // Corrected Pose Engine (Coach's Eye ghost skeleton)
                this.correctedPoseEngine = new CorrectedPoseEngine();
                this.replayManager.correctedPoseEngine = this.correctedPoseEngine;

                // Ball Tracking (in-browser color detection, no server needed)
                this.ballTracker = new BallTrackingClient({
                    onShotAnalyzed: this.onShotAnalyzed.bind(this)
                });

                // Scene Analyzer (Gemini multimodal) + Rally Tracker + Visual Merger + Live Feedback + Court Position
                this.sceneAnalyzer = new SceneAnalyzer();
                this.visualMerger = new VisualAnalysisMerger();
                this.liveFeedbackOverlay = new LiveFeedbackOverlay();
                this.courtPositionAnalyzer = new CourtPositionAnalyzer();
                this.speechGate = new SpeechGate();
                this.batchAccumulator = new BatchCoachingAccumulator({ batchThreshold: 10, trialThreshold: 3 });
                this.insightMiner = new InsightMiner();
                this.proactiveTriggers = new ProactiveTriggers();
                this.curriculumEngine = new CurriculumEngine();
                // Init from Supabase if authenticated
                if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                    this.curriculumEngine.init();
                }
                this.shareCardGenerator = new ShareCardGenerator();
                this.sessionVideoManager = new SessionVideoManager();
                this.rallyTracker = new RallyTracker();
                this.sceneAnalyzer.onStateChange = (oldState, newState, sceneData) => {
                    this.rallyTracker.onStateChange(oldState, newState, sceneData);
                    if (this.courtPositionAnalyzer && sceneData) {
                        this.courtPositionAnalyzer.update(sceneData);
                    }
                    if (this.speechGate) {
                        this.speechGate.updateGameState(newState);
                    }
                    this.updateRallyIndicator();
                };

                // Batch coaching flush: deliver ready batches at natural breaks
                this.speechGate.onBatchFlush = () => {
                    if (!this.batchAccumulator) return;
                    const ready = this.batchAccumulator.getReadyBatches();
                    if (ready.length === 0) return;
                    const summaries = ready.map(t => this.batchAccumulator.buildBatchSummary(t));
                    const triggers = this.batchAccumulator.pendingTriggers.splice(0);
                    const rallyAnalyses = this.batchAccumulator.pendingRallyAnalyses.splice(0);
                    const prompt = this.buildBatchPrompt(summaries, triggers, rallyAnalyses);
                    if (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.isConnected) {
                        gptVoiceCoach.analyzeBatch(prompt);
                    }
                    ready.forEach(t => this.batchAccumulator.markDelivered(t));
                };

                // Speech gate flush: send queued coaching only during drill mode
                this.speechGate.onFlush = (coachingContext) => {
                    if (typeof drillMode !== 'undefined' && drillMode.isActive) {
                        if (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.isConnected) {
                            gptVoiceCoach.analyzeStroke(coachingContext);
                        }
                    }
                };

                // Set Gemini key: try Supabase Edge Function first, then localStorage
                if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                    this.sceneAnalyzer.initializeWithAuth();
                } else {
                    const savedGeminiKey = localStorage.getItem('ace_gemini_key');
                    if (savedGeminiKey) {
                        this.sceneAnalyzer.setApiKey(savedGeminiKey);
                    }
                }

                // Fault-to-landmark mapping for visual highlighting
                this.faultLandmarkMap = {
                    latePreparation: [11, 12],
                    armOnlySwing: [11, 12, 23, 24],
                    collapsingElbow: [13, 14],
                    hittingOffBackFoot: [27, 28],
                    abbreviatedFollowThrough: [15, 16],
                    inconsistentContactPoint: [15, 16],
                    noKneeBend: [25, 26],
                    rushingTheSwing: [11, 12, 23, 24],
                    narrowBase: [27, 28],
                    noStepIn: [27, 28],
                    poorRecovery: [23, 24, 27, 28],
                    wrongStanceForStroke: [23, 24, 27, 28],
                    // Serve faults
                    noLegDrive: [25, 26, 27, 28],
                    noTrophyPosition: [11, 12, 15, 16],
                    lowServeContactPoint: [15, 16],
                    flatServeNoTilt: [11, 12]
                };
                this.faultHighlightDuration = 3000;

                // Enhanced swing trail state
                this.frozenTrail = null;
                this.frozenTrailTimestamp = 0;
                this.frozenTrailFadeMs = 1500;
                this.contactPointMarker = null;
                this.phaseColors = {
                    preparation:   { r: 60,  g: 130, b: 246 },
                    loading:       { r: 250, g: 204, b: 21  },
                    acceleration:  { r: 249, g: 115, b: 22  },
                    contact:       { r: 255, g: 59,  b: 48  },
                    followThrough: { r: 50,  g: 215, b: 75  },
                    unknown:       { r: 0,   g: 255, b: 255 }
                };

                // DOM elements
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('canvasElement');
                this.ctx = this.canvas.getContext('2d');

                this.initializeLoadingSequence();
            }

            async initializeLoadingSequence() {
                try {
                    this.updateLoadingProgress(10, 'Loading MediaPipe libraries...');
                    await this.sleep(500);
                    
                    this.updateLoadingProgress(30, 'Initializing pose detection...');
                    await this.initializeMediaPipe();
                    
                    this.updateLoadingProgress(60, 'Setting up tennis analysis...');
                    await this.sleep(500);
                    
                    this.updateLoadingProgress(80, 'Configuring camera...');
                    await this.setupCamera();
                    
                    this.updateLoadingProgress(90, 'Connecting ball tracking...');
                    this.ballTracker.startCapture(this.video);
                    await this.sleep(300);

                    this.updateLoadingProgress(100, 'Ready to coach!');
                    await this.sleep(500);

                    this.completeInitialization();
                    
                } catch (error) {
                    this.showError('Failed to initialize: ' + error.message);
                }
            }

            async initializeMediaPipe() {
                this.pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });

                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.pose.onResults(this.onResults.bind(this));
                this.isReady = true;
            }
            async setupCamera() {
                // Stop existing tracks before switching
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }

                // getUserMedia first — reliably triggers loadedmetadata so we
                // can size the canvas from the actual stream resolution.
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: this.currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                this.video.srcObject = stream;

                return new Promise((resolve) => {
                    this.video.onloadedmetadata = () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;

                        // Camera class provides the frame loop for MediaPipe.
                        // facingMode ensures it reopens the same camera.
                        this.camera = new Camera(this.video, {
                            onFrame: async () => {
                                if (this.pose) {
                                    await this.pose.send({ image: this.video });
                                }
                            },
                            width: 1280,
                            height: 720,
                            facingMode: this.currentFacingMode
                        });

                        this.camera.start();
                        resolve();
                    };
                });
            }
            onResults(results) {
                // Clear and draw camera feed
                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(results.image, 0, 0, this.canvas.width, this.canvas.height);

                if (results.poseLandmarks) {

                // Draw pose overlay
                // Volt accent skeleton with glow effect
                this.ctx.shadowColor = 'rgba(205, 255, 0, 0.4)';
                this.ctx.shadowBlur = 8;
                drawConnectors(this.ctx, results.poseLandmarks, POSE_CONNECTIONS, {
                    color: 'rgba(205, 255, 0, 0.7)',
                    lineWidth: 2
                });
                this.ctx.shadowBlur = 0;
                drawLandmarks(this.ctx, results.poseLandmarks, {
                    color: '#FFFFFF',
                    fillColor: 'rgba(205, 255, 0, 0.9)',
                    lineWidth: 1,
                    radius: 3
                });

                // Draw fault highlights on affected joints
                if (this.isAnalyzing) {
                    this.drawFaultHighlights(results.poseLandmarks);
                }

                // Only analyze pose when user has pressed play
                if (this.isAnalyzing) {
                    // Filter landmarks for analysis (raw landmarks still used above for skeleton drawing)
                    const timestamp = Date.now();
                    const filteredLandmarks = this.landmarkFilter.filterLandmarks(results.poseLandmarks, timestamp);
                    const poseData = this.enhancedAnalyzer.analyzePose(filteredLandmarks, timestamp);

                    // Capture high-res frame for Gemini visual analysis (rolling buffer)
                    if (this.sceneAnalyzer && this.sceneAnalyzer.enabled) {
                        this.sceneAnalyzer.captureHighResFrame(this.video);
                    }

                    // Capture frame for ball tracking (runs in background)
                    this.ballTracker.onFrame();

                    // Draw swing trail
                    if (this.enhancedAnalyzer.poseHistory.length > 2) {
                        this.drawSwingTrail();
                    }

                    // Continuously record frames for ghost (we'll extract stroke when detected)
                    if (typeof ghostOverlay !== 'undefined') {
                        ghostOverlay.recordFrame(results.poseLandmarks, Date.now());
                    }
                }

                // Draw ghost overlay (behind current pose for visibility)
                if (typeof ghostOverlay !== 'undefined' && ghostOverlay.isEnabled()) {
                    ghostOverlay.draw(this.ctx, results.poseLandmarks);

                    // Update similarity display
                    const similarity = ghostOverlay.getSimilarityScore();
                    if (similarity !== null) {
                        this.updateGhostSimilarity(similarity);
                    }
                }

                // Draw live feedback overlay (stroke flash, floating score, word label)
                if (this.liveFeedbackOverlay && this.liveFeedbackOverlay.isActive()) {
                    this.liveFeedbackOverlay.draw(this.ctx, this.canvas.width, this.canvas.height);
                }
            }

                this.ctx.restore();
            }

            drawSwingTrail() {
                const now = Date.now();

                // Draw frozen trail (post-stroke, phase-colored) if available
                if (this.frozenTrail) {
                    const age = now - this.frozenTrailTimestamp;
                    if (age > this.frozenTrailFadeMs) {
                        this.frozenTrail = null;
                        this.contactPointMarker = null;
                    } else {
                        const fadeAlpha = age < 1000 ? 1.0 : 1.0 - ((age - 1000) / 500);
                        this.drawPhaseColoredTrail(this.frozenTrail, fadeAlpha);
                        this.drawContactPointMarker(fadeAlpha);
                        return;
                    }
                }

                // Draw live real-time trail
                this.drawLiveTrail();
            }

            drawLiveTrail() {
                const history = this.enhancedAnalyzer.poseHistory;
                if (history.length < 3) return;

                this.ctx.save();

                const points = history.map(p => {
                    const wrist = p.joints.dominantWrist || p.joints.rightWrist;
                    return {
                        x: wrist.x * this.canvas.width,
                        y: wrist.y * this.canvas.height,
                        velocity: p.velocity?.magnitude || 0
                    };
                });

                const velocities = points.map(p => p.velocity);
                const maxVel = Math.max(...velocities);
                const minVel = Math.min(...velocities);
                const velRange = maxVel - minVel || 1;
                const peakIdx = velocities.indexOf(maxVel);

                for (let i = 1; i < points.length; i++) {
                    const t = i / points.length;
                    const velNorm = (points[i].velocity - minVel) / velRange;
                    const isPastPeak = i > peakIdx && peakIdx > points.length * 0.3;
                    const color = this.velocityToColor(velNorm, isPastPeak);
                    const lineWidth = 2 + velNorm * 6;

                    this.ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${t * 0.5})`;
                    this.ctx.shadowBlur = 6 + velNorm * 8;
                    this.ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${t * 0.8})`;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.lineCap = 'round';

                    this.ctx.beginPath();
                    this.ctx.moveTo(points[i - 1].x, points[i - 1].y);
                    this.ctx.lineTo(points[i].x, points[i].y);
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            velocityToColor(velNorm, isPastPeak) {
                if (isPastPeak) return this.phaseColors.followThrough;
                if (velNorm < 0.2) return this.phaseColors.preparation;
                if (velNorm < 0.45) return this.phaseColors.loading;
                if (velNorm < 0.7) return this.phaseColors.acceleration;
                return this.phaseColors.contact;
            }

            freezeTrail(poseHistory, strokeData) {
                const phases = this.enhancedAnalyzer.lastDetectedPhase;
                const phaseDetector = this.enhancedAnalyzer.phaseDetector;

                const velocities = poseHistory.map(p => p.velocity?.magnitude || 0);
                const maxVel = Math.max(...velocities);
                const minVel = Math.min(...velocities);
                const velRange = maxVel - minVel || 1;

                this.frozenTrail = poseHistory.map((p, i) => {
                    const wrist = p.joints.dominantWrist || p.joints.rightWrist;
                    const velNorm = (velocities[i] - minVel) / velRange;

                    let phase = 'unknown';
                    if (phases && phaseDetector) {
                        phase = phaseDetector.getPhaseAtFrame(phases, i);
                    }

                    return {
                        x: wrist.x * this.canvas.width,
                        y: wrist.y * this.canvas.height,
                        velNorm,
                        phase
                    };
                });

                this.frozenTrailTimestamp = Date.now();

                // Set contact point marker
                if (phases && phases.contactFrame != null && poseHistory[phases.contactFrame]) {
                    const contactPose = poseHistory[phases.contactFrame];
                    const wrist = contactPose.joints.dominantWrist || contactPose.joints.rightWrist;
                    this.contactPointMarker = {
                        x: wrist.x * this.canvas.width,
                        y: wrist.y * this.canvas.height,
                        timestamp: Date.now()
                    };
                }
            }

            drawPhaseColoredTrail(trailData, globalAlpha) {
                if (trailData.length < 2) return;
                this.ctx.save();

                for (let i = 1; i < trailData.length; i++) {
                    const seg = trailData[i];
                    const color = this.phaseColors[seg.phase] || this.phaseColors.unknown;
                    const t = i / trailData.length;

                    this.ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${globalAlpha * 0.5})`;
                    this.ctx.shadowBlur = 8 + seg.velNorm * 10;
                    this.ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${globalAlpha * t})`;
                    this.ctx.lineWidth = 2 + seg.velNorm * 6;
                    this.ctx.lineCap = 'round';

                    this.ctx.beginPath();
                    this.ctx.moveTo(trailData[i - 1].x, trailData[i - 1].y);
                    this.ctx.lineTo(seg.x, seg.y);
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            drawContactPointMarker(alpha) {
                if (!this.contactPointMarker) return;
                const { x, y, timestamp } = this.contactPointMarker;
                const age = Date.now() - timestamp;
                const pulse = 1.0 + 0.3 * Math.sin(age / 100);
                const radius = 10 * pulse;

                this.ctx.save();
                this.ctx.shadowColor = `rgba(255, 59, 48, ${alpha * 0.8})`;
                this.ctx.shadowBlur = 20;

                // Outer ring
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.stroke();

                // Inner dot
                this.ctx.fillStyle = `rgba(255, 59, 48, ${alpha * 0.9})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            drawFaultHighlights(landmarks) {
                const now = Date.now();
                const faults = this.enhancedAnalyzer.activeFaults;
                if (!faults || faults.length === 0) return;

                const highlighted = new Set();

                this.ctx.save();
                for (const fault of faults) {
                    const age = now - fault.timestamp;
                    if (age > this.faultHighlightDuration) continue;

                    const indices = this.faultLandmarkMap[fault.id];
                    if (!indices) continue;

                    const alpha = 1 - (age / this.faultHighlightDuration);
                    const pulse = 0.5 + 0.5 * Math.sin(now / 150);

                    for (const idx of indices) {
                        if (highlighted.has(idx)) continue;
                        highlighted.add(idx);

                        const lm = landmarks[idx];
                        if (!lm) continue;

                        const x = lm.x * this.canvas.width;
                        const y = lm.y * this.canvas.height;
                        const radius = 8 + pulse * 4;

                        // Outer glow
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 59, 48, ${alpha * pulse * 0.3})`;
                        this.ctx.fill();

                        // Inner circle
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 59, 48, ${alpha * 0.8})`;
                        this.ctx.fill();
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }
                this.ctx.restore();
            }

            updateGhostSimilarity(similarity) {
                const display = document.getElementById('ghostSimilarityDisplay');
                const valueEl = document.getElementById('ghostSimilarityValue');

                if (!display || !valueEl) return;

                valueEl.textContent = `${similarity}%`;

                // Color code based on similarity
                valueEl.classList.remove('low', 'medium', 'high');
                if (similarity >= 80) {
                    valueEl.classList.add('high');
                } else if (similarity >= 50) {
                    valueEl.classList.add('medium');
                } else {
                    valueEl.classList.add('low');
                }
            }

            updateUI(context) {
                // Update status bar
                document.getElementById('strokeCount').textContent = context.session.strokeCount;
                document.getElementById('avgScore').textContent = context.quality.overall.toFixed(0);
                document.getElementById('consistencyScore').textContent = context.session.consistency;
                
                // Update analysis card
                document.getElementById('strokeType').textContent = 
                    context.strokeType.charAt(0).toUpperCase() + context.strokeType.slice(1);
                document.getElementById('techniqueScore').textContent = 
                    `${context.quality.overall.toFixed(0)}/100`;
                
                // Update metrics
                document.getElementById('elbowAngleMetric').textContent = 
                    `${context.technique.elbowAngleAtContact.toFixed(0)}°`;
                document.getElementById('hipSepMetric').textContent = 
                    `${context.technique.hipShoulderSeparation.toFixed(0)}°`;
                document.getElementById('stanceMetric').textContent = context.technique.stance;
                document.getElementById('weightMetric').textContent = context.technique.weightTransfer;
                
                if (context.comparison && context.comparison.skillLevel) {
        const skillLevel = context.comparison.skillLevel;
        const skillDisplay = skillLevel.charAt(0).toUpperCase() + skillLevel.slice(1);
        document.getElementById('skillLevelMetric').textContent = 
            `${skillDisplay} (${context.comparison.percentile}%)`;
    }
    
                // Show card
                const card = document.getElementById('analysisCard');
                card.classList.add('visible');
                setTimeout(() => card.classList.remove('visible'), 4000);
        }   
            

            startAnalysis() {
                if (!this.isReady) return;

                this.isAnalyzing = true;

                document.getElementById('aiStatusDot').className = 'status-dot active';
                const recBtn = document.getElementById('liveRecBtn');
                const recLabel = document.getElementById('liveRecLabel');
                if (recBtn) recBtn.classList.add('recording');
                if (recLabel) recLabel.textContent = 'STOP';
                document.getElementById('coachingText').textContent =
                    'AI analyzing your strokes. Make tennis swings to get feedback!';
            }

            stopAnalysis() {
                this.isAnalyzing = false;

                document.getElementById('aiStatusDot').className = 'status-dot ready';
                const recBtn = document.getElementById('liveRecBtn');
                const recLabel = document.getElementById('liveRecLabel');
                if (recBtn) recBtn.classList.remove('recording');
                if (recLabel) recLabel.textContent = 'REC';
                document.getElementById('coachingText').textContent =
                    'Analysis paused. Tap play to resume.';
            }

            async resetSession() {
                // End current session and show summary if strokes were recorded
                if (typeof sessionStorage !== 'undefined' && sessionStorage.endSession) {
                    const endedSession = await sessionStorage.endSession();
                    if (endedSession && endedSession.summary && endedSession.summary.totalStrokes > 0) {
                        // Record session in player profile for cross-session tracking
                        if (typeof playerProfile !== 'undefined') {
                            const milestones = await playerProfile.recordSession(endedSession.summary);
                            // Show milestones if any achieved
                            if (milestones && milestones.length > 0) {
                                endedSession.summary.milestones = milestones;
                            }
                        }

                        // Record metrics in improvement tracker
                        if (typeof improvementTracker !== 'undefined') {
                            await improvementTracker.recordSession(endedSession.strokes, endedSession.summary);
                        }

                        // Force-flush all batch coaching at session end
                        if (this.batchAccumulator && typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.isConnected) {
                            const endSummaries = this.batchAccumulator.getAllBatchSummaries();
                            if (endSummaries.length > 0) {
                                const triggers = this.batchAccumulator.pendingTriggers.splice(0);
                                const rallyAnalyses = this.batchAccumulator.pendingRallyAnalyses.splice(0);
                                let prompt = this.buildBatchPrompt(endSummaries, triggers, rallyAnalyses);
                                prompt += '\n\nThis is END OF SESSION. Always respond with option A or B, not silence. Summarize what you observed and give them something specific to work on next time.';
                                gptVoiceCoach.analyzeBatch(prompt);
                                endSummaries.forEach(s => this.batchAccumulator.markDelivered(s.strokeType));
                            }
                        }

                        // Synthesize notebook entry (while GPT connection still alive)
                        if (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.synthesizeNotebookEntry) {
                            try {
                                const coachNotes = await gptVoiceCoach.synthesizeNotebookEntry(endedSession.summary);
                                if (typeof coachNotebook !== 'undefined' && coachNotes) {
                                    await coachNotebook.saveEntry({
                                        date: Date.now(),
                                        sessionNumber: playerProfile?.profile?.totalSessions || 0,
                                        summary: {
                                            totalStrokes: endedSession.summary.totalStrokes,
                                            avgScore: endedSession.summary.averageScore,
                                            weaknesses: endedSession.summary.weaknesses,
                                            improvement: endedSession.summary.improvement,
                                            skillLevel: endedSession.summary.skillLevel,
                                            strokeTypeBreakdowns: endedSession.summary.strokeTypeBreakdowns
                                        },
                                        coachNotes: coachNotes,
                                        transcriptSnippets: gptVoiceCoach.sessionTranscript?.length || 0
                                    });
                                }
                                endedSession.summary.coachNotes = coachNotes;
                            } catch (e) {
                                console.error('Notebook synthesis failed:', e);
                            }
                        }

                        // Synthesize coaching plan update
                        if (typeof improvementTracker !== 'undefined' && typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.synthesizeCoachingPlan) {
                            try {
                                const plan = await gptVoiceCoach.synthesizeCoachingPlan(
                                    endedSession.summary,
                                    improvementTracker
                                );
                                if (plan) {
                                    await improvementTracker.updateCoachingPlan(plan);
                                    endedSession.summary.coachingPlan = plan;
                                }
                            } catch (e) {
                                console.error('Plan synthesis failed:', e);
                            }
                        }

                        // Add rally stats and last Gemini tactical analysis to summary
                        if (this.rallyTracker) {
                            endedSession.summary.rallyStats = this.rallyTracker.getSessionStats();
                            const lastAnalysis = this.rallyTracker.getLastRallyAnalysis();
                            if (lastAnalysis) {
                                endedSession.summary.lastRallyAnalysis = lastAnalysis;
                            }
                        }

                        // Mine patterns and insights
                        if (this.insightMiner && endedSession.strokes) {
                            const crossSessionData = typeof improvementTracker !== 'undefined' ? improvementTracker : null;
                            endedSession.summary.insights = this.insightMiner.minePatterns(
                                endedSession.strokes, crossSessionData
                            );
                        }

                        // Record curriculum session
                        if (this.curriculumEngine?.isActive()) {
                            await this.curriculumEngine.recordSession();
                        }

                        // Speak top insight via GPT at session end
                        if (endedSession.summary.insights?.length > 0 && this.insightMiner) {
                            const topInsightPrompt = this.insightMiner.formatTopInsightForGPT();
                            if (topInsightPrompt && typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.isConnected) {
                                gptVoiceCoach.analyzeStroke({
                                    type: 'proactive_trigger',
                                    message: `SESSION ENDING — share this insight with the player: ${topInsightPrompt}`
                                });
                            }
                        }

                        // Visual progress analysis (Gemini text-only comparison of best vs worst)
                        if (this.sceneAnalyzer?.enabled && this.sessionVideoManager) {
                            const best = this.sessionVideoManager.sessionBest;
                            const worst = this.sessionVideoManager.sessionWorst;
                            if (best?.visualAnalysisText && worst?.visualAnalysisText) {
                                try {
                                    const focusAreas = typeof improvementTracker !== 'undefined'
                                        ? improvementTracker.getCoachingPlan?.()?.focusAreas?.map(f => f.area) || []
                                        : [];
                                    const progress = await this.sceneAnalyzer.analyzeSessionProgress({
                                        bestType: best.type, bestQuality: best.quality, bestVisual: best.visualAnalysisText,
                                        worstType: worst.type, worstQuality: worst.quality, worstVisual: worst.visualAnalysisText,
                                        focusAreas
                                    });
                                    if (progress) endedSession.summary.visualProgress = progress;
                                } catch (e) { console.error('Visual progress analysis failed:', e); }
                            }
                        }

                        showSessionSummary(endedSession.summary);
                    }
                    // Create new session
                    sessionStorage.createSession();
                }

                // Reset GPT coach session state
                if (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.resetSession) {
                    gptVoiceCoach.resetSession();
                }

                this.enhancedAnalyzer.resetSession();
                this.landmarkFilter.reset();

                // Reset rally tracker, scene analyzer, visual merger, and court position
                if (this.rallyTracker) this.rallyTracker.reset();
                if (this.visualMerger) this.visualMerger.reset();
                if (this.courtPositionAnalyzer) this.courtPositionAnalyzer.reset();
                if (this.speechGate) this.speechGate.reset();
                if (this.batchAccumulator) this.batchAccumulator.reset();
                if (this.proactiveTriggers) this.proactiveTriggers.reset();
                if (this.sessionVideoManager) this.sessionVideoManager.reset();
                if (this.sceneAnalyzer) {
                    this.sceneAnalyzer.reset();
                    // Restart scene analysis for new session
                    if (this.sceneAnalyzer.enabled && this.video) {
                        this.sceneAnalyzer.start(this.video);
                    }
                }

                document.getElementById('strokeCount').textContent = '0';
                document.getElementById('avgScore').textContent = '--';
                document.getElementById('consistencyScore').textContent = '--';
                document.getElementById('elbowAngleMetric').textContent = '--';
                document.getElementById('hipSepMetric').textContent = '--';
                document.getElementById('stanceMetric').textContent = '--';
                document.getElementById('weightMetric').textContent = '--';
                document.getElementById('coachingText').textContent =
                    'Session reset! Ready to analyze your technique.';
                document.getElementById('analysisCard').classList.remove('visible');
                this.updateRallyIndicator();
            }

            /**
             * Build text prompt for batch coaching from aggregated summaries.
             */
            buildBatchPrompt(summaries, triggers, rallyAnalyses) {
                let prompt = 'BATCH OBSERVATION REPORT\n';
                prompt += `You observed the following strokes at a natural break. Choose your response: A) Full coaching, B) Brief encouragement, or C) [SILENCE].\n\n`;

                for (const s of summaries) {
                    prompt += `--- ${s.strokeType.toUpperCase()} (${s.count} strokes) ---\n`;
                    prompt += `Quality: avg ${s.avgQuality}, range ${s.minQuality}-${s.maxQuality}`;
                    if (s.trend > 2) prompt += ` (IMPROVING +${s.trend})`;
                    else if (s.trend < -2) prompt += ` (DECLINING ${s.trend})`;
                    prompt += '\n';
                    if (s.avgForm != null) prompt += `Form: ${s.avgForm} | Power: ${s.avgPower}\n`;

                    if (s.topFaults.length > 0) {
                        prompt += 'Top faults: ' + s.topFaults.map(f =>
                            `${f.name} (${f.count}/${s.count})${f.fix ? ' — fix: ' + f.fix : ''}`
                        ).join('; ') + '\n';
                    }

                    if (s.topIssue) {
                        prompt += `Primary coaching issue: ${s.topIssue.name} (${s.topIssue.count}/${s.count})`;
                        if (s.topIssue.cue) prompt += ` — cue: "${s.topIssue.cue}"`;
                        prompt += '\n';
                    }

                    if (s.consistentStrengths.length > 0) {
                        prompt += `Consistent strengths: ${s.consistentStrengths.join(', ')}\n`;
                    }

                    // Metric averages
                    const mKeys = Object.entries(s.metricAvgs).filter(([, v]) => v != null);
                    if (mKeys.length > 0) {
                        prompt += 'Metrics: ' + mKeys.map(([k, v]) => `${k}=${v}`).join(', ') + '\n';
                    }

                    // Visual insights
                    if (s.visualInsights) {
                        const vi = s.visualInsights;
                        const parts = [];
                        if (vi.commonRacketFace) parts.push(`racket face: ${vi.commonRacketFace}`);
                        if (vi.commonGrip) parts.push(`grip: ${vi.commonGrip}`);
                        if (vi.recurringVisualFaults?.length > 0) {
                            parts.push('visual faults: ' + vi.recurringVisualFaults.map(f => `${f.name}(${f.count}x)`).join(', '));
                        }
                        if (parts.length > 0) prompt += `Visual: ${parts.join(' | ')}\n`;
                    }

                    // Footwork
                    if (s.footwork) {
                        prompt += `Footwork: score ${s.footwork.avgScore}`;
                        if (s.footwork.commonStance) prompt += `, common stance: ${s.footwork.commonStance}`;
                        prompt += '\n';
                    }

                    // Serve
                    if (s.serve) {
                        const sv = s.serve;
                        const parts = [];
                        if (sv.avgScore != null) parts.push(`score=${sv.avgScore}`);
                        if (sv.avgTrophy != null) parts.push(`trophy=${sv.avgTrophy}`);
                        if (sv.avgLegDrive != null) parts.push(`legDrive=${sv.avgLegDrive}`);
                        if (sv.avgContactHeight != null) parts.push(`contactHeight=${sv.avgContactHeight}`);
                        if (parts.length > 0) prompt += `Serve: ${parts.join(', ')}\n`;
                    }

                    prompt += '\n';
                }

                // Triggers
                if (triggers.length > 0) {
                    prompt += 'ALERTS:\n';
                    triggers.forEach(t => {
                        prompt += `- [${t.type || 'alert'}] ${t.message}\n`;
                    });
                    prompt += '\n';
                }

                // Rally analyses
                if (rallyAnalyses.length > 0) {
                    prompt += 'RALLY OBSERVATIONS:\n';
                    rallyAnalyses.forEach(r => {
                        const a = r.analysis || r;
                        prompt += `- Rally #${r.rallyNumber || '?'} (${r.strokeCount || '?'} strokes): `;
                        if (a.overallAssessment) prompt += a.overallAssessment;
                        if (a.suggestion) prompt += ` Suggestion: ${a.suggestion}`;
                        prompt += '\n';
                    });
                    prompt += '\n';
                }

                // Improvement plan context
                if (typeof improvementTracker !== 'undefined') {
                    const planContext = improvementTracker.formatForSystemPrompt?.();
                    if (planContext) prompt += planContext + '\n';
                }

                prompt += 'Choose ONE response: A) Full coaching (under 20 sec), B) Brief encouragement (under 5 sec), or C) respond with exactly "[SILENCE]".\n';
                return prompt;
            }

            /**
             * Called asynchronously when ball tracking backend returns shot outcome
             */
            onShotAnalyzed(shotOutcome, originalStroke) {
                const outcome = shotOutcome.outcome;
                if (!outcome || outcome.confidence < 0.2) return;

                // Build follow-up coaching based on shot outcome
                const outcomeContext = {
                    type: 'shot_outcome',
                    in_court: outcome.in_court,
                    ball_direction: outcome.ball_direction,
                    net_clearance: outcome.net_clearance,
                    landed_position: outcome.landed_position,
                    confidence: outcome.confidence,
                    strokeType: shotOutcome.strokeType,
                    ballDetectionRate: shotOutcome.ballDetectionRate
                };

                // Send outcome to GPT coach as follow-up context
                if (typeof gptVoiceCoach !== 'undefined' && outcome.confidence >= 0.4) {
                    const followUp = this.buildOutcomeCoachingMessage(outcomeContext, originalStroke);
                    if (followUp) {
                        gptVoiceCoach.analyzeStroke({
                            type: 'shot_outcome_followup',
                            ...followUp
                        });
                    }
                }

                // Update coaching panel with outcome
                const panel = document.getElementById('coachingText');
                if (panel && outcome?.in_court !== null && outcome?.in_court !== undefined) {
                    const tag = outcome.in_court ? 'IN' : 'OUT';
                    const current = panel.textContent;
                    panel.textContent = `[${tag}] ${current}`;
                }
            }

            /**
             * Build coaching follow-up message based on shot outcome
             */
            buildOutcomeCoachingMessage(outcomeContext, stroke) {
                // Only follow up if there's something notable to say
                const quality = stroke.quality?.overall || 0;

                // Good form but ball went out = important coaching moment
                if (quality >= 70 && outcomeContext.in_court === false) {
                    return {
                        strokeType: outcomeContext.strokeType,
                        message: 'Good technique but the ball went out. Consider reducing swing speed slightly or adjusting contact angle.',
                        quality: { overall: quality },
                        shotOutcome: outcomeContext
                    };
                }

                // Bad form but ball went in = acknowledge but keep coaching form
                if (quality < 50 && outcomeContext.in_court === true) {
                    return {
                        strokeType: outcomeContext.strokeType,
                        message: 'The ball landed in, but the technique needs work for consistency. Keep focusing on form.',
                        quality: { overall: quality },
                        shotOutcome: outcomeContext
                    };
                }

                // Great form + ball in = positive reinforcement
                if (quality >= 80 && outcomeContext.in_court === true) {
                    return {
                        strokeType: outcomeContext.strokeType,
                        message: 'Great shot! Technique and placement both excellent.',
                        quality: { overall: quality },
                        shotOutcome: outcomeContext
                    };
                }

                return null; // Don't follow up for unremarkable outcomes
            }

            completeInitialization() {
                const loadingScreen = document.getElementById('loadingScreen');
                const cameraContainer = document.getElementById('cameraContainer');
                const isTrialSession = typeof onboardingState !== 'undefined' && onboardingState.trialSessionActive;

                // Cinematic exit: Hold at READY for 1s, then enter appropriate mode
                setTimeout(() => {
                    loadingScreen.style.transition = 'opacity 300ms ease-out, transform 300ms ease-out';
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.transform = 'translateY(-30px)';

                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        document.getElementById('aiStatusDot').className = 'status-dot ready';

                        if (isTrialSession) {
                            // During onboarding trial — show camera directly (live mode)
                            cameraContainer.style.display = 'block';
                            cameraContainer.style.opacity = '1';
                        } else {
                            // Normal flow — enter browse mode, camera stays hidden
                            cameraContainer.style.display = 'none';
                            document.getElementById('bottomTabBar').style.display = 'flex';
                            document.getElementById('tabContent').classList.add('active');
                            populateHomeStats();
                        }

                        // Start scene analysis if Gemini key is configured
                        if (this.sceneAnalyzer && this.sceneAnalyzer.enabled && this.video) {
                            this.sceneAnalyzer.start(this.video);
                        }

                        // Welcome coaching message ready for live mode
                        const gptStatus = (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.isConnected)
                            ? 'Voice coach connected.'
                            : (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.useFallback)
                                ? 'Voice coach unavailable — using text fallback.'
                                : 'Connecting voice coach...';
                        document.getElementById('coachingText').textContent =
                            gptStatus + ' Tap REC to start.';
                    }, 300);
                }, 1000);
            }

            updateRallyIndicator() {
                const container = document.getElementById('rallyStatus');
                const value = document.getElementById('rallyStateValue');
                if (!container || !value) return;

                if (!this.sceneAnalyzer || !this.sceneAnalyzer.enabled) {
                    container.style.display = 'none';
                    return;
                }

                container.style.display = '';
                const state = this.sceneAnalyzer.gameState;
                const rallyStrokes = this.rallyTracker?.currentRally?.strokes?.length || 0;

                switch (state) {
                    case 'serving':
                        value.textContent = 'SERVING';
                        value.style.color = '#CDFF00';
                        break;
                    case 'rallying':
                        value.textContent = `RALLY (${rallyStrokes})`;
                        value.style.color = '#32D74B';
                        break;
                    case 'between_points':
                        value.textContent = 'BETWEEN';
                        value.style.color = 'rgba(255,255,255,0.4)';
                        break;
                    case 'warmup':
                        value.textContent = 'WARMUP';
                        value.style.color = '#4FC3F7';
                        break;
                    case 'idle':
                        value.textContent = 'IDLE';
                        value.style.color = 'rgba(255,255,255,0.3)';
                        break;
                    default:
                        value.textContent = '--';
                        value.style.color = 'rgba(255,255,255,0.4)';
                }
            }

            // Premium loading phase management
            updateLoadingProgress(percent, status) {
                const phaseEl = document.getElementById('loadingPhase');
                const detailEl = document.getElementById('loadingDetail');
                const fillEl = document.getElementById('loadingFill');

                // Phase mapping with spec-compliant details
                const phases = {
                    'Loading MediaPipe libraries...': { phase: 'LOADING', detail: 'Initializing pose detection model', progress: 10 },
                    'Initializing pose detection...': { phase: 'DETECTING', detail: 'Configuring MediaPipe Holistic', progress: 30 },
                    'Setting up tennis analysis...': { phase: 'ANALYZING', detail: 'Loading stroke analysis engine', progress: 60 },
                    'Configuring camera...': { phase: 'CAMERA', detail: 'Requesting camera access', progress: 80 },
                    'Connecting ball tracking...': { phase: 'TRACKING', detail: 'Connecting to ball detection server', progress: 90 },
                    'Ready to coach!': { phase: 'READY', detail: "Let's go.", progress: 100 }
                };

                const mapped = phases[status] || { phase: 'LOADING', detail: status, progress: percent };

                // Crossfade phase text
                if (phaseEl && phaseEl.textContent !== mapped.phase) {
                    phaseEl.classList.add('crossfade');
                    detailEl.classList.add('crossfade');

                    setTimeout(() => {
                        phaseEl.textContent = mapped.phase;
                        detailEl.textContent = mapped.detail;
                        phaseEl.classList.remove('crossfade');
                        detailEl.classList.remove('crossfade');
                    }, 200);
                }

                // Smooth progress bar - never jumps, always eases
                if (fillEl) {
                    fillEl.style.width = mapped.progress + '%';
                }
            }

            showError(message) {
                showToast(message);
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Global application state
        let tennisAI = null;
        window.tennisAI = null; // Exposed for cross-module access (ball tracking)

        // ============================================
        // PREMIUM SCREEN TRANSITIONS
        // Vertical motion only, 400ms ease-out
        // ============================================

        function transitionScreens(fromId, toId, callback) {
            const fromScreen = document.getElementById(fromId);
            const toScreen = document.getElementById(toId);

            // Exit animation: fade out + move up
            fromScreen.classList.add('exiting');

            setTimeout(() => {
                fromScreen.style.display = 'none';
                fromScreen.classList.remove('exiting');

                // Enter animation: start below, fade in while moving up
                toScreen.style.display = 'flex';
                toScreen.classList.add('entering');

                // Trigger reflow
                toScreen.offsetHeight;

                // Activate enter animation
                toScreen.classList.add('active');

                setTimeout(() => {
                    toScreen.classList.remove('entering', 'active');
                    if (callback) callback();
                }, 400);
            }, 400);
        }

        // ============================================
        // PREMIUM ONBOARDING STATE MACHINE
        // ============================================

        const onboardingState = {
            sport: 'tennis',
            ntrpLevel: null,
            goals: [],
            customGoal: '',
            displayName: null,
            age: null,
            coachPreference: 'alex',
            trialStrokes: [],
            trialSessionActive: false,
            meetCoachTimer: null,
        };

        const NTRP_TO_SKILL = {
            '2.0-2.5': 'beginner',
            '3.0-3.5': 'intermediate',
            '4.0-4.5': 'advanced',
            '5.0+': 'elite'
        };

        // --- Returning user flow (post-onboarding) ---
        async function requestCameraPermission() {
            if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                transitionScreens('permissionScreen', 'loadingScreen', async () => {
                    const profile = await supabaseClient.loadProfile();
                    const coachKey = profile?.coachPreference || 'alex';
                    const configs = GPTVoiceCoach.getCoachConfigs();
                    const coach = configs[coachKey] || configs.alex;
                    await gptVoiceCoach.initialize(null, {
                        voice: coach.voice,
                        coachName: coach.name,
                        coachPersonality: coach.personality
                    });
                    tennisAI = new TennisAI();
                    window.tennisAI = tennisAI;
                });
            } else {
                // No Supabase auth — use local onboarding data
                transitionScreens('permissionScreen', 'loadingScreen', async () => {
                    const localOb = JSON.parse(localStorage.getItem('ace_onboarding') || '{}');
                    const coachKey = localOb.coachPreference || 'alex';
                    const configs = GPTVoiceCoach.getCoachConfigs();
                    const coach = configs[coachKey] || configs.alex;
                    const apiKey = localStorage.getItem('ace_openai_key');
                    if (apiKey) {
                        await gptVoiceCoach.initialize(apiKey, {
                            voice: coach.voice,
                            coachName: coach.name,
                            coachPersonality: coach.personality
                        });
                    } else {
                        gptVoiceCoach.fallbackToSpeechSynthesis();
                    }
                    tennisAI = new TennisAI();
                    window.tennisAI = tennisAI;
                });
            }
        }

        // --- Screen 1: Sport Selection ---
        function obSelectSport(sport) {
            onboardingState.sport = sport;
            setTimeout(() => transitionScreens('obSportScreen', 'obSkillScreen'), 400);
        }

        // --- Screen 2: Skill Level ---
        function obSelectSkill(level, el) {
            onboardingState.ntrpLevel = level;
            document.querySelectorAll('#obSkillCards .ob-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            setTimeout(() => transitionScreens('obSkillScreen', 'obGoalsScreen'), 400);
        }

        // --- Screen 3: Goals ---
        function obToggleGoal(goal, el) {
            el.classList.toggle('selected');
            const idx = onboardingState.goals.indexOf(goal);
            if (idx >= 0) onboardingState.goals.splice(idx, 1);
            else onboardingState.goals.push(goal);
            // Enable continue when custom text entered OR at least 1 goal selected
            const hasCustom = document.getElementById('obCustomGoal').value.trim().length > 0;
            document.getElementById('obGoalsContinue').disabled = onboardingState.goals.length === 0 && !hasCustom;
        }

        // Also enable continue button on custom goal text input
        document.addEventListener('DOMContentLoaded', () => {
            const customGoalInput = document.getElementById('obCustomGoal');
            if (customGoalInput) {
                customGoalInput.addEventListener('input', () => {
                    const hasCustom = customGoalInput.value.trim().length > 0;
                    document.getElementById('obGoalsContinue').disabled = onboardingState.goals.length === 0 && !hasCustom;
                });
            }
        });

        function obSubmitGoals() {
            onboardingState.customGoal = document.getElementById('obCustomGoal').value.trim();
            transitionScreens('obGoalsScreen', 'obAboutScreen');
        }

        // --- Screen 4: About You ---
        function obSubmitAbout() {
            onboardingState.displayName = document.getElementById('obNameInput').value.trim() || null;
            const ageVal = parseInt(document.getElementById('obAgeInput').value);
            onboardingState.age = (ageVal && ageVal >= 5 && ageVal <= 99) ? ageVal : null;
            transitionScreens('obAboutScreen', 'obCoachScreen');
            obPopulateCoachCards();
        }

        function obSkipAbout() {
            transitionScreens('obAboutScreen', 'obCoachScreen');
            obPopulateCoachCards();
        }

        // --- Screen 5: Choose Coach ---
        function obPopulateCoachCards() {
            const container = document.getElementById('obCoachCards');
            if (container.children.length > 0) return;
            const configs = GPTVoiceCoach.getCoachConfigs();
            const colors = { alex: '#4CAF50', jordan: '#2196F3', sam: '#FF9800' };
            const coachIcons = {
                alex: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
                jordan: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>',
                sam: '<svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>'
            };

            for (const [key, config] of Object.entries(configs)) {
                const card = document.createElement('div');
                card.className = 'ob-coach-card' + (key === 'alex' ? ' selected' : '');
                card.dataset.coachKey = key;
                card.onclick = () => obSelectCoach(key);
                card.innerHTML = `
                    <div class="ob-coach-header">
                        <div class="ob-coach-avatar" style="background:${colors[key]}20;color:${colors[key]}">${coachIcons[key]}</div>
                        <div>
                            <div class="ob-coach-name">${config.name}</div>
                            <div class="ob-coach-tagline">${config.tagline} &mdash; ${config.description}</div>
                        </div>
                    </div>
                    <button class="ob-preview-btn" onclick="event.stopPropagation(); obPreviewVoice('${key}')"><svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor" stroke="none"><polygon points="5 3 19 12 5 21 5 3"/></svg> Preview voice</button>
                `;
                container.appendChild(card);
            }
        }

        function obSelectCoach(key) {
            onboardingState.coachPreference = key;
            document.querySelectorAll('#obCoachCards .ob-coach-card').forEach(c => c.classList.remove('selected'));
            document.querySelector(`[data-coach-key="${key}"]`).classList.add('selected');
            setTimeout(() => {
                transitionScreens('obCoachScreen', 'obMeetScreen');
                obInitMeetCoach();
            }, 500);
        }

        function obPreviewVoice(key) {
            const configs = GPTVoiceCoach.getCoachConfigs();
            const config = configs[key];
            if (!config || !('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(config.previewText);
            utterance.rate = 1.0;
            utterance.pitch = key === 'sam' ? 1.1 : key === 'jordan' ? 0.9 : 1.0;
            window.speechSynthesis.speak(utterance);
        }

        // --- Screen 6: Meet Your Coach ---
        async function obInitMeetCoach() {
            const configs = GPTVoiceCoach.getCoachConfigs();
            const coach = configs[onboardingState.coachPreference] || configs.alex;

            document.getElementById('obMeetCoachName').textContent = coach.name.toUpperCase();
            document.getElementById('obMeetStatus').textContent = 'Connecting...';

            const skillLabel = onboardingState.ntrpLevel || '3.0-3.5';
            const goalsStr = onboardingState.goals.join(', ') || 'general improvement';
            const nameStr = onboardingState.displayName ? ` Their name is ${onboardingState.displayName}.` : '';

            const meetInstructions = `You are ${coach.name}, an AI tennis coach. ${coach.personality}
This is your first time meeting this player.${nameStr}
They are a ${skillLabel} NTRP player who wants to improve: ${goalsStr}.${onboardingState.customGoal ? ' They also mentioned: ' + onboardingState.customGoal + '.' : ''}
Introduce yourself conversationally (2-3 sentences). Be warm, reference their goals, and get them excited to hit.
Keep it under 15 seconds. Do NOT mention being AI.`;

            try {
                const tokenData = await supabaseClient.getGuestToken(meetInstructions, coach.voice);
                if (!tokenData?.ephemeralKey) {
                    document.getElementById('obMeetStatus').textContent = 'Ready to go!';
                    return;
                }

                gptVoiceCoach.voice = coach.voice;
                gptVoiceCoach.coachName = coach.name;
                gptVoiceCoach.coachPersonality = coach.personality;

                // Ensure audio element exists
                if (!gptVoiceCoach.audioElement) {
                    gptVoiceCoach.audioElement = document.createElement('audio');
                    gptVoiceCoach.audioElement.autoplay = true;
                    gptVoiceCoach.audioElement.playsInline = true;
                    document.body.appendChild(gptVoiceCoach.audioElement);
                }

                await gptVoiceCoach.connectWebRTC(tokenData.ephemeralKey);
                gptVoiceCoach.isConnected = true;
                document.getElementById('obMeetStatus').textContent = 'Listening...';

                // Override greeting to use meet-coach prompt instead of normal session greeting
                gptVoiceCoach.dataChannel.send(JSON.stringify({
                    type: 'session.update',
                    session: { instructions: meetInstructions, turn_detection: { type: 'server_vad' } }
                }));
                setTimeout(() => {
                    gptVoiceCoach.dataChannel.send(JSON.stringify({
                        type: 'conversation.item.create',
                        item: { type: 'message', role: 'user', content: [{ type: 'input_text', text: 'Introduce yourself to this new player. Keep it to 2-3 sentences.' }] }
                    }));
                    gptVoiceCoach.dataChannel.send(JSON.stringify({ type: 'response.create' }));
                }, 500);

                // Auto-advance after 30s
                onboardingState.meetCoachTimer = setTimeout(() => obFinishMeetCoach(), 30000);
            } catch (e) {
                console.error('Meet coach connection failed:', e);
                document.getElementById('obMeetStatus').textContent = 'Ready to go!';
            }
        }

        function obFinishMeetCoach() {
            if (onboardingState.meetCoachTimer) {
                clearTimeout(onboardingState.meetCoachTimer);
                onboardingState.meetCoachTimer = null;
            }
            // Disconnect meet-coach session (will reconnect for trial)
            if (gptVoiceCoach.pc) {
                gptVoiceCoach.pc.close();
                gptVoiceCoach.pc = null;
                gptVoiceCoach.isConnected = false;
            }
            transitionScreens('obMeetScreen', 'obCameraScreen');
        }

        // --- Screen 7: Camera Permission ---
        async function obRequestTrialCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                stream.getTracks().forEach(t => t.stop());
                transitionScreens('obCameraScreen', 'loadingScreen', async () => {
                    await obStartTrialSession();
                });
            } catch (e) {
                showToast('Camera permission is required for stroke analysis');
            }
        }

        // --- Screen 8: Trial Session ---
        async function obStartTrialSession() {
            onboardingState.trialSessionActive = true;
            onboardingState.trialStrokes = [];

            const configs = GPTVoiceCoach.getCoachConfigs();
            const coach = configs[onboardingState.coachPreference] || configs.alex;

            // Get a new guest token for the trial
            const trialInstructions = `You are ${coach.name}, an AI tennis coach. ${coach.personality}
You are coaching a ${onboardingState.ntrpLevel || '3.0-3.5'} NTRP player in their first trial session.
Give quick, encouraging feedback on each stroke. Keep it to 1-2 sentences.
This is a demo — make them feel excited about the coaching experience.`;

            const tokenData = await supabaseClient.getGuestToken(trialInstructions, coach.voice);

            if (tokenData?.ephemeralKey) {
                gptVoiceCoach.voice = coach.voice;
                gptVoiceCoach.coachName = coach.name;
                gptVoiceCoach.coachPersonality = coach.personality;

                if (!gptVoiceCoach.audioElement) {
                    gptVoiceCoach.audioElement = document.createElement('audio');
                    gptVoiceCoach.audioElement.autoplay = true;
                    gptVoiceCoach.audioElement.playsInline = true;
                    document.body.appendChild(gptVoiceCoach.audioElement);
                }

                await gptVoiceCoach.connectWebRTC(tokenData.ephemeralKey);
                gptVoiceCoach.isConnected = true;
                gptVoiceCoach.sessionStartTime = Date.now();
            }

            // Initialize TennisAI (camera + pose detection)
            tennisAI = new TennisAI();
            window.tennisAI = tennisAI;

            // Enable Gemini visual analysis for guests if key available
            if (tokenData?.geminiKey && tennisAI.sceneAnalyzer) {
                tennisAI.sceneAnalyzer.setApiKey(tokenData.geminiKey);
            }

            // Show trial counter overlay
            document.getElementById('obTrialOverlay').style.display = 'block';
            obUpdateTrialCounter(0);

            // Hook into stroke detection for trial counting
            const checkTrialHook = setInterval(() => {
                if (tennisAI?.enhancedAnalyzer) {
                    const originalCallback = tennisAI.enhancedAnalyzer.onStrokeCallback;
                    tennisAI.enhancedAnalyzer.onStrokeCallback = (strokeData, historySnapshot) => {
                        if (originalCallback) originalCallback(strokeData, historySnapshot);

                        if (onboardingState.trialSessionActive) {
                            onboardingState.trialStrokes.push(strokeData);
                            obUpdateTrialCounter(onboardingState.trialStrokes.length);
                            if (onboardingState.trialStrokes.length >= 5) {
                                obEndTrialSession();
                            }
                        }
                    };
                    clearInterval(checkTrialHook);
                }
            }, 200);
        }

        function obUpdateTrialCounter(count) {
            const el = document.getElementById('obTrialCounter');
            if (el) el.textContent = `Stroke ${count}/5`;
        }

        function obEndTrialSession() {
            onboardingState.trialSessionActive = false;
            document.getElementById('obTrialOverlay').style.display = 'none';

            // Stop camera
            if (tennisAI?.camera) {
                tennisAI.camera.stop();
            }

            // Disconnect voice
            if (gptVoiceCoach.pc) {
                gptVoiceCoach.pc.close();
                gptVoiceCoach.pc = null;
                gptVoiceCoach.isConnected = false;
            }

            obBuildReportCard();

            // Hide camera, show report screen
            document.getElementById('cameraContainer').style.display = 'none';
            document.querySelector('.container').style.display = 'flex';
            document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
            const reportScreen = document.getElementById('obReportScreen');
            reportScreen.style.display = 'flex';
            reportScreen.classList.add('entering');
            reportScreen.offsetHeight;
            reportScreen.classList.add('active');
            setTimeout(() => reportScreen.classList.remove('entering', 'active'), 400);
        }

        // --- Screen 9: Report Card ---
        function obBuildReportCard() {
            const strokes = onboardingState.trialStrokes;
            if (strokes.length === 0) {
                document.getElementById('obReportScore').textContent = '--';
                document.getElementById('obCoachNoteText').textContent = 'Hit some strokes next time and I\'ll give you a full breakdown!';
                return;
            }

            const scores = strokes.map(s => s.quality?.overall || s.quality || 0);
            const avgScore = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
            const bestScore = Math.round(Math.max(...scores));

            const types = {};
            strokes.forEach(s => { const t = s.type || s.strokeType || 'Unknown'; types[t] = (types[t] || 0) + 1; });
            const dominantType = Object.entries(types).sort((a, b) => b[1] - a[1])[0]?.[0] || 'Unknown';

            let topStrength = avgScore >= 70 ? 'Strong fundamentals' : avgScore >= 50 ? 'Solid technique basics' : 'Good effort';
            let topImprovement = 'Keep practicing';

            const allFaults = strokes.flatMap(s =>
                (s.biomechanicalEvaluation?.detectedFaults || s.biomechanical?.faults || []).map(f => typeof f === 'string' ? f : f.name)
            ).filter(Boolean);
            const faultCounts = {};
            allFaults.forEach(f => { faultCounts[f] = (faultCounts[f] || 0) + 1; });
            const topFault = Object.entries(faultCounts).sort((a, b) => b[1] - a[1])[0];
            if (topFault) topImprovement = topFault[0].replace(/([A-Z])/g, ' $1').trim();

            document.getElementById('obReportScore').textContent = avgScore;
            document.getElementById('obReportDetails').innerHTML = `
                <div class="ob-report-stat"><div class="ob-report-stat-label">Strokes Analyzed</div><div class="ob-report-stat-value">${strokes.length}</div></div>
                <div class="ob-report-stat"><div class="ob-report-stat-label">Best Stroke</div><div class="ob-report-stat-value">${bestScore}/100</div></div>
                <div class="ob-report-stat"><div class="ob-report-stat-label">Most Hit</div><div class="ob-report-stat-value">${dominantType}</div></div>
                <div class="ob-report-stat"><div class="ob-report-stat-label">Top Strength</div><div class="ob-report-stat-value" style="color:#CDFF00">${topStrength}</div></div>
                <div class="ob-report-stat"><div class="ob-report-stat-label">Focus Area</div><div class="ob-report-stat-value" style="color:#FF9800">${topImprovement}</div></div>
            `;

            const nameRef = onboardingState.displayName ? `, ${onboardingState.displayName}` : '';
            document.getElementById('obCoachNoteText').textContent =
                `Great first session${nameRef}! I can see you have a solid ${dominantType.toLowerCase()}. ` +
                `Let's work on your ${topImprovement.toLowerCase()} together - I know we can take your game to the next level.`;
        }

        // --- Screen 10: Sign Up ---
        function obGoToSignup() {
            transitionScreens('obReportScreen', 'obSignupScreen');
        }

        async function obSendMagicLink() {
            const emailInput = document.getElementById('obSignupEmail');
            const statusEl = document.getElementById('obSignupStatus');
            const sendBtn = document.getElementById('obSignupBtn');

            const email = emailInput.value.trim();
            if (!email || !email.includes('@')) {
                statusEl.textContent = 'Please enter a valid email address.';
                statusEl.style.color = '#ff6b6b';
                return;
            }

            sendBtn.disabled = true;
            sendBtn.textContent = 'SENDING...';

            const { error } = await supabaseClient.signInWithMagicLink(email);
            if (error) {
                statusEl.textContent = error;
                statusEl.style.color = '#ff6b6b';
                sendBtn.disabled = false;
                sendBtn.innerHTML = 'SEND MAGIC LINK <span style="margin-left:4px;">&rarr;</span>';
            } else {
                statusEl.textContent = 'Check your email for the magic link!';
                statusEl.style.color = '#CDFF00';
                sendBtn.textContent = 'EMAIL SENT \u2713';
            }
        }

        function obSkipSignup() {
            // Continue without account
            obFinishOnboarding(false);
        }

        // --- Screen 11: Pricing ---
        function obStartFreeTrial() {
            if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                supabaseClient.updateProfile({
                    subscriptionTier: 'trial',
                    trialStartDate: new Date().toISOString(),
                });
            }
            obFinishOnboarding(true);
        }

        function obContinueWithFree() {
            if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                supabaseClient.updateProfile({ subscriptionTier: 'free' });
            }
            obFinishOnboarding(true);
        }

        // --- Finish Onboarding ---
        async function obFinishOnboarding(isAuthenticated) {
            const skillLevel = NTRP_TO_SKILL[onboardingState.ntrpLevel] || 'intermediate';

            if (isAuthenticated && typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                await supabaseClient.updateProfile({
                    sport: onboardingState.sport,
                    ntrpLevel: onboardingState.ntrpLevel,
                    skillLevel: skillLevel,
                    improvementGoals: onboardingState.goals,
                    customGoalText: onboardingState.customGoal || null,
                    coachPreference: onboardingState.coachPreference,
                    displayName: onboardingState.displayName,
                    age: onboardingState.age,
                    onboardingCompleted: true,
                });
                await loadUserData();
            } else {
                localStorage.setItem('ace_onboarding', JSON.stringify(onboardingState));
            }

            // Update playerProfile in memory
            if (typeof playerProfile !== 'undefined') {
                playerProfile.profile.currentSkillLevel = skillLevel;
                playerProfile.profile.coachPreference = onboardingState.coachPreference;
                playerProfile.profile.improvementGoals = onboardingState.goals;
                playerProfile.profile.displayName = onboardingState.displayName;
                playerProfile.profile.onboardingCompleted = true;
            }

            // Transition to full app
            const visibleScreen = document.querySelector('.screen[style*="display: flex"], .screen:not([style*="display: none"])');
            const fromId = visibleScreen?.id || 'obPricingScreen';

            transitionScreens(fromId, 'loadingScreen', async () => {
                const configs = GPTVoiceCoach.getCoachConfigs();
                const coach = configs[onboardingState.coachPreference] || configs.alex;

                // Set observation limit based on tier
                if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                    const sub = supabaseClient.getSubscriptionStatus();
                    gptVoiceCoach.observationLimit = sub.observationLimit;
                }

                await gptVoiceCoach.initialize(null, {
                    voice: coach.voice,
                    coachName: coach.name,
                    coachPersonality: coach.personality
                });

                tennisAI = new TennisAI();
                window.tennisAI = tennisAI;
            });
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // Slides down from top, auto-dismiss
        // ============================================

        function showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;

            // Clear any existing state
            toast.classList.remove('visible', 'hiding');
            toast.textContent = message;

            // Show toast
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });

            // Auto-dismiss after 3s
            setTimeout(() => {
                toast.classList.add('hiding');
                toast.classList.remove('visible');
            }, 3000);
        }

        function toggleAnalysis() {
            if (!tennisAI || !tennisAI.isReady) return;
            
            if (tennisAI.isAnalyzing) {
                tennisAI.stopAnalysis();
            } else {
                tennisAI.startAnalysis();
            }
        }

        function resetSession() {
            if (tennisAI) {
                tennisAI.resetSession();
            }
            // Reset ghost session tracking
            if (typeof ghostOverlay !== 'undefined') {
                ghostOverlay.resetSession();
            }
            // Clear replay recordings
            if (tennisAI?.replayManager) {
                tennisAI.replayManager.clearReplays();
            }
        }

        async function flipCamera() {
            if (!tennisAI) return;
            const wasAnalyzing = tennisAI.isAnalyzing;
            if (wasAnalyzing) tennisAI.stopAnalysis();

            // Stop MediaPipe camera loop
            if (tennisAI.camera) {
                tennisAI.camera.stop();
            }

            tennisAI.currentFacingMode = tennisAI.currentFacingMode === 'user' ? 'environment' : 'user';
            await tennisAI.setupCamera();

            if (wasAnalyzing) tennisAI.startAnalysis();
        }

        // Ghost Overlay Toggle
        function toggleGhost() {
            if (typeof ghostOverlay === 'undefined') return;

            const enabled = ghostOverlay.toggle();
            const display = document.getElementById('ghostSimilarityDisplay');

            if (enabled) {
                // Check if we have a ghost to show
                if (!ghostOverlay.ghostStroke) {
                    if (!ghostOverlay.useBestStroke()) {
                        showToast('No ghost available yet. Complete some strokes first.');
                        ghostOverlay.toggle(); // Turn back off
                        return;
                    }
                }

                if (display) display.style.display = 'block';
                ghostOverlay.play();
                showToast('Ghost overlay ON');

                const info = ghostOverlay.getGhostInfo();
                if (info) {
                    console.log(`Ghost active: ${info.name} (${info.frameCount} frames)`);
                }
            } else {
                if (display) display.style.display = 'none';
                ghostOverlay.pause();
                showToast('Ghost overlay OFF');
            }
            // Update settings sheet status
            const gs = document.getElementById('settingsGhostStatus');
            if (gs) gs.textContent = enabled ? 'On' : 'Off';
            const ps = document.getElementById('profileGhostStatus');
            if (ps) ps.textContent = enabled ? 'On' : 'Off';
        }

        // Lock current best stroke as ghost reference
        function lockCurrentGhost() {
            if (typeof ghostOverlay === 'undefined' || !ghostOverlay.bestStrokeThisSession) {
                showToast('No stroke to lock. Complete some strokes first.');
                return;
            }

            const stroke = ghostOverlay.lockStroke(ghostOverlay.bestStrokeThisSession);
            showToast(`Locked "${stroke.name}" as ghost reference`);
        }

        // Session Recap — Full-Screen Overlay
        function showSessionSummary(summary) {
            if (!summary) return;
            window._lastSessionSummary = summary;

            const cards = [];
            let cardIndex = 0;

            // --- Card 1: Hero Score ---
            const duration = formatDuration(summary.duration);
            const avgScore = summary.averageScore || 0;
            const ringCircumference = 339.292; // 2 * PI * 54
            const ringTarget = ringCircumference - (avgScore / 100) * ringCircumference;
            const improvementClass = summary.improvement > 0 ? 'positive' : summary.improvement < 0 ? 'negative' : 'neutral';
            const improvementArrow = summary.improvement > 0 ? '↑' : summary.improvement < 0 ? '↓' : '→';
            const improvementText = summary.improvement > 0 ? `+${summary.improvement}` : summary.improvement < 0 ? `${summary.improvement}` : '0';

            let heroHtml = `
                <div class="recap-hero">
                    <div class="recap-score-ring-wrap">
                        <svg class="recap-score-ring" viewBox="0 0 120 120">
                            <circle class="ring-bg" cx="60" cy="60" r="54"/>
                            <circle class="ring-fill" cx="60" cy="60" r="54" style="--ring-target: ${ringTarget}"/>
                        </svg>
                        <div class="recap-score-value">
                            <span id="recapScoreNum">0</span>
                            <small>/100</small>
                        </div>
                    </div>
                    <div class="recap-meta">
                        <span>${summary.totalStrokes} strokes</span>
                        <span>${duration}</span>
                        <span>Best ${summary.bestScore || 0}</span>
                    </div>
                    <span class="recap-improvement-pill ${improvementClass}">
                        ${improvementArrow} ${improvementText} from start
                    </span>`;
            if (summary.milestones && summary.milestones.length > 0) {
                heroHtml += `<div class="recap-milestones">
                    ${summary.milestones.map(m => `<span class="recap-milestone">${m.label}</span>`).join('')}
                </div>`;
            }
            heroHtml += `</div>`;
            cards.push({ html: heroHtml, cls: 'recap-card-transparent' });

            // --- Card 2: Quality Sparkline ---
            if (summary.totalStrokes >= 5) {
                const currentSession = typeof sessionStorage !== 'undefined' ? sessionStorage.getCurrentSession() : null;
                const strokes = currentSession?.strokes;
                if (strokes && strokes.length >= 5) {
                    const scores = strokes.map(s => s.quality);
                    const maxS = Math.max(...scores);
                    const minS = Math.min(...scores);
                    const range = maxS - minS || 1;
                    const svgW = 300, svgH = 70, padY = 8;

                    const pts = scores.map((s, i) => {
                        const x = (i / (scores.length - 1)) * svgW;
                        const y = padY + (svgH - 2 * padY) - ((s - minS) / range) * (svgH - 2 * padY);
                        return { x, y, score: s };
                    });
                    const polyPoints = pts.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
                    const fillPoints = `0,${svgH} ${polyPoints} ${svgW},${svgH}`;

                    // Best and worst
                    const bestIdx = scores.indexOf(Math.max(...scores));
                    const worstIdx = scores.indexOf(Math.min(...scores));
                    const avgY = padY + (svgH - 2 * padY) - ((avgScore - minS) / range) * (svgH - 2 * padY);

                    cards.push({ html: `
                        <div class="recap-label">QUALITY OVER TIME</div>
                        <div class="recap-sparkline">
                            <svg viewBox="0 0 ${svgW} ${svgH + 14}" preserveAspectRatio="none">
                                <defs>
                                    <linearGradient id="sparkFill" x1="0" y1="0" x2="0" y2="1">
                                        <stop offset="0%" stop-color="var(--accent-volt)" stop-opacity="0.2"/>
                                        <stop offset="100%" stop-color="var(--accent-volt)" stop-opacity="0"/>
                                    </linearGradient>
                                </defs>
                                <polygon points="${fillPoints}" fill="url(#sparkFill)"/>
                                <polyline points="${polyPoints}" fill="none" stroke="var(--accent-volt)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <line x1="0" y1="${avgY.toFixed(1)}" x2="${svgW}" y2="${avgY.toFixed(1)}" stroke="rgba(255,255,255,0.15)" stroke-width="1" stroke-dasharray="4,4"/>
                                <text x="${svgW}" y="${avgY - 3}" text-anchor="end" fill="rgba(255,255,255,0.35)" font-size="9">avg ${avgScore}</text>
                                <circle cx="${pts[bestIdx].x.toFixed(1)}" cy="${pts[bestIdx].y.toFixed(1)}" r="3.5" fill="var(--accent-volt)"/>
                                <text x="${pts[bestIdx].x.toFixed(1)}" y="${pts[bestIdx].y - 6}" text-anchor="middle" fill="var(--accent-volt)" font-size="9" font-weight="700">${scores[bestIdx]}</text>
                                ${worstIdx !== bestIdx ? `
                                <circle cx="${pts[worstIdx].x.toFixed(1)}" cy="${pts[worstIdx].y.toFixed(1)}" r="3" fill="#FF3B30"/>
                                <text x="${pts[worstIdx].x.toFixed(1)}" y="${pts[worstIdx].y + 12}" text-anchor="middle" fill="#FF3B30" font-size="9">${scores[worstIdx]}</text>` : ''}
                            </svg>
                        </div>
                    ` });
                }
            }

            // --- Card 3: Session Insight ---
            let insightSource = null;
            if (summary.insights && summary.insights.length > 0) {
                insightSource = summary.insights[0];
            } else if (summary.lastRallyAnalysis?.overallAssessment) {
                insightSource = {
                    headline: 'Tactical Summary',
                    detail: summary.lastRallyAnalysis.overallAssessment,
                    actionable: summary.lastRallyAnalysis.suggestion || ''
                };
            }
            if (insightSource) {
                cards.push({ html: `
                    <div class="recap-label" style="color: #4FC3F7;">SESSION INSIGHT</div>
                    <div class="recap-insight-headline">${insightSource.headline}</div>
                    ${insightSource.detail ? `<div class="recap-insight-detail">${insightSource.detail}</div>` : ''}
                    ${insightSource.actionable ? `<div class="recap-insight-action">${insightSource.actionable}</div>` : ''}
                `, cls: 'recap-insight' });
            }

            // --- Card 4: Stroke Breakdown ---
            if (summary.strokeTypeBreakdowns && Object.keys(summary.strokeTypeBreakdowns).length > 0) {
                const breakdowns = summary.strokeTypeBreakdowns;
                const maxCount = Math.max(...Object.values(breakdowns).map(b => b.count));
                // Within-session progress
                let withinProgress = {};
                if (tennisAI?.sessionVideoManager?.bookmarks?.length >= 3) {
                    try { withinProgress = tennisAI.sessionVideoManager.getWithinSessionProgress(); } catch(e) {}
                }

                let breakdownHtml = `<div class="recap-label">YOUR STROKES</div>`;
                for (const [type, bd] of Object.entries(breakdowns)) {
                    const score = bd.avgQuality || 0;
                    const barColor = score >= 75 ? '#32D74B' : score >= 60 ? 'var(--accent-volt)' : '#FF3B30';
                    const barWidth = maxCount > 0 ? Math.round((bd.count / maxCount) * 100) : 0;
                    const wp = withinProgress[type];
                    const topFault = bd.topFault || null;
                    breakdownHtml += `
                        <div class="recap-breakdown-row" onclick="this.classList.toggle('expanded')">
                            <div class="recap-breakdown-header">
                                <span class="recap-breakdown-type">${type}</span>
                                <span class="recap-breakdown-score" style="color:${barColor}">${Math.round(score)}</span>
                            </div>
                            <div class="recap-breakdown-bar-track">
                                <div class="recap-breakdown-bar" style="width:${barWidth}%; background:${barColor}"></div>
                            </div>
                            <div class="recap-breakdown-count">${bd.count} stroke${bd.count !== 1 ? 's' : ''}</div>
                            <div class="recap-breakdown-detail">
                                <div class="recap-breakdown-detail-inner">
                                    ${bd.avgFormScore ? `<span class="recap-detail-chip">Form ${Math.round(bd.avgFormScore)}</span>` : ''}
                                    ${bd.avgRotation ? `<span class="recap-detail-chip">Power ${Math.round(bd.avgRotation)}</span>` : ''}
                                    ${topFault ? `<span class="recap-detail-chip fault">${topFault}</span>` : ''}
                                    ${wp && wp.delta !== 0 ? `<span class="recap-detail-chip" style="color:${wp.delta > 0 ? '#32D74B' : '#FF3B30'}">${wp.firstQuality} → ${wp.lastQuality}</span>` : ''}
                                </div>
                            </div>
                        </div>`;
                }

                // Rally stats footer
                if (summary.rallyStats && summary.rallyStats.totalRallies > 0) {
                    const rs = summary.rallyStats;
                    breakdownHtml += `<div class="recap-rally-footer">${rs.totalRallies} rallies · avg ${rs.avgRallyLength} strokes · longest ${rs.longestRally}</div>`;
                }

                cards.push({ html: breakdownHtml });
            }

            // --- Card 5: Coach's Notes ---
            const coachPref = (typeof onboardingState !== 'undefined' && onboardingState.coachPreference) || 'alex';
            const coachConfigs = { alex: { name: 'Coach Alex', icon: 'star' }, jordan: { name: 'Coach Jordan', icon: 'target' }, sam: { name: 'Coach Sam', icon: 'lightning' } };
            const coach = coachConfigs[coachPref] || coachConfigs.alex;
            const coachIcons = {
                star: `<svg viewBox="0 0 24 24" fill="none" stroke="var(--accent-volt)" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>`,
                target: `<svg viewBox="0 0 24 24" fill="none" stroke="#4FC3F7" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>`,
                lightning: `<svg viewBox="0 0 24 24" fill="none" stroke="#FFD60A" stroke-width="2"><polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>`
            };
            if (summary.coachNotes || summary.visualProgress) {
                let coachHtml = `<div class="recap-coach">
                    <div class="recap-coach-avatar">${coachIcons[coach.icon] || coachIcons.star}</div>
                    <div>
                        <div class="recap-coach-name">${coach.name}</div>`;
                if (summary.coachNotes) {
                    coachHtml += `<div class="recap-coach-quote">"${summary.coachNotes}"</div>`;
                }
                if (summary.visualProgress) {
                    coachHtml += `<div class="recap-visual-progress">${summary.visualProgress}</div>`;
                }
                coachHtml += `</div></div>`;
                cards.push({ html: coachHtml });
            }

            // --- Card 6: Best Moments ---
            const replays = typeof window.strokeReplayManager !== 'undefined' ? window.strokeReplayManager.getAllReplays() : [];
            let notableStrokes = [];
            if (tennisAI?.sessionVideoManager?.getNotableStrokes) {
                try { notableStrokes = tennisAI.sessionVideoManager.getNotableStrokes(); } catch(e) {}
            }
            if (replays.length > 0 || notableStrokes.length > 0) {
                // Merge: use notables first (they have labels), fill with replays sorted by quality
                const momentCards = [];
                const usedReplayIndices = new Set();
                for (const n of notableStrokes) {
                    if (n.replayIndex >= 0 && n.replayIndex < replays.length) {
                        momentCards.push({ replayIndex: n.replayIndex, quality: n.quality, label: n.label, type: n.type });
                        usedReplayIndices.add(n.replayIndex);
                    }
                }
                // Add remaining replays sorted by quality
                const remaining = replays.map((r, i) => ({ replayIndex: i, quality: r.quality || 0, label: '', type: r.strokeType || '' }))
                    .filter(r => !usedReplayIndices.has(r.replayIndex))
                    .sort((a, b) => b.quality - a.quality);
                for (const r of remaining) {
                    if (momentCards.length >= 10) break;
                    momentCards.push(r);
                }

                if (momentCards.length > 0) {
                    let momentsHtml = `<div class="recap-label">BEST MOMENTS</div><div class="recap-moments-scroll">`;
                    for (const m of momentCards) {
                        const qColor = m.quality >= 80 ? '#32D74B' : m.quality >= 60 ? 'var(--accent-volt)' : '#FF3B30';
                        momentsHtml += `
                            <div class="recap-moment" onclick="playNotableReplay(${m.replayIndex})">
                                <canvas width="180" height="200" data-replay-index="${m.replayIndex}"></canvas>
                                <div class="recap-moment-info">
                                    <span class="recap-moment-score" style="color:${qColor}">${Math.round(m.quality)}</span>
                                    <span class="recap-moment-label">${m.label || m.type}</span>
                                </div>
                            </div>`;
                    }
                    momentsHtml += `</div>`;
                    cards.push({ html: momentsHtml });
                }
            }

            // --- Card 7: Progress ---
            let progressHtml = '';
            // Within-session
            if (tennisAI?.sessionVideoManager?.bookmarks?.length >= 3) {
                try {
                    const progress = tennisAI.sessionVideoManager.getWithinSessionProgress();
                    const entries = Object.entries(progress).filter(([, d]) => d.delta !== 0);
                    if (entries.length > 0) {
                        progressHtml += `<div class="recap-progress-section">
                            <div class="recap-progress-sublabel">This Session</div>
                            ${entries.map(([type, d]) => {
                                const color = d.delta > 0 ? '#32D74B' : '#FF3B30';
                                const arrow = d.delta > 0 ? '↑' : '↓';
                                return `<div class="recap-progress-row">
                                    <span class="recap-progress-type">${type}</span>
                                    <span class="recap-progress-delta" style="color:${color}">${d.firstQuality} → ${d.lastQuality} ${arrow}${Math.abs(d.delta)}</span>
                                </div>`;
                            }).join('')}
                        </div>`;
                    }
                } catch(e) {}
            }
            // Cross-session
            if (typeof improvementTracker !== 'undefined' && improvementTracker.data) {
                const types = Object.keys(improvementTracker.data.strokeTypes || {});
                const crossDeltas = [];
                for (const type of types) {
                    const history = improvementTracker.data.strokeTypes[type];
                    if (history?.quality?.length >= 2) {
                        const prev = history.quality[history.quality.length - 2];
                        const current = history.quality[history.quality.length - 1];
                        const delta = Math.round(current - prev);
                        if (delta !== 0) crossDeltas.push({ type, prev: Math.round(prev), current: Math.round(current), delta });
                    }
                }
                if (crossDeltas.length > 0) {
                    progressHtml += `<div class="recap-progress-section">
                        <div class="recap-progress-sublabel">vs Last Session</div>
                        ${crossDeltas.map(d => {
                            const color = d.delta > 0 ? '#32D74B' : '#FF3B30';
                            const arrow = d.delta > 0 ? '↑' : '↓';
                            return `<div class="recap-progress-row">
                                <span class="recap-progress-type">${d.type}</span>
                                <span class="recap-progress-delta" style="color:${color}">${d.prev} → ${d.current} ${arrow}${Math.abs(d.delta)}</span>
                            </div>`;
                        }).join('')}
                    </div>`;
                }
            }
            if (progressHtml) {
                cards.push({ html: `<div class="recap-label">PROGRESS</div>${progressHtml}` });
            }

            // --- Card 8: Your Plan ---
            const plan = summary.coachingPlan || (typeof improvementTracker !== 'undefined' ? improvementTracker.getCoachingPlan() : null);
            if (plan?.focusAreas?.length > 0) {
                let planHtml = `<div class="recap-label">YOUR PLAN</div>`;
                for (const f of plan.focusAreas.slice(0, 3)) {
                    planHtml += `<div class="recap-plan-card">
                        <div class="recap-plan-area">${f.area}</div>
                        ${f.target ? `<div class="recap-plan-target">Target: ${f.target}</div>` : (f.why ? `<div class="recap-plan-target">${f.why}</div>` : '')}
                        ${f.drill ? `<div class="recap-plan-drill" onclick="closeSessionSummary(); setTimeout(() => startDrillFromTab('${(f.drill || '').replace(/'/g, '')}'), 300);">
                            ${f.drill} ▸
                        </div>` : ''}
                    </div>`;
                }
                if (plan.sessionGoal) {
                    planHtml += `<div class="recap-plan-goal">"${plan.sessionGoal}"</div>`;
                }
                cards.push({ html: planHtml });
            }

            // --- Card 9: Actions ---
            cards.push({ html: `
                <div class="recap-actions">
                    <button class="recap-btn-primary" onclick="shareSessionCard()">Share Session Card</button>
                    <button class="recap-btn-secondary" onclick="closeSessionSummary()">Done</button>
                </div>
            `, cls: 'recap-card-transparent' });

            // --- Render ---
            const recapScroll = document.getElementById('recapScroll');
            recapScroll.innerHTML = '';
            cards.forEach((card, i) => {
                const div = document.createElement('div');
                div.className = card.cls || 'recap-card';
                div.style.animationDelay = `${i * 100}ms`;
                div.innerHTML = card.html;
                recapScroll.appendChild(div);
            });

            // Show overlay
            document.getElementById('sessionRecap').classList.add('visible');
            recapScroll.scrollTop = 0;

            // Post-DOM: animated score count-up
            animateScoreCountUp(document.getElementById('recapScoreNum'), avgScore);

            // Post-DOM: render mini skeletons
            requestAnimationFrame(() => renderMiniSkeletons());
        }

        function closeSessionSummary() {
            document.getElementById('sessionRecap').classList.remove('visible');
            // Force profile tab to re-populate with fresh data next visit
            _profileTabPopulated = false;
            // Return to browse mode if we're in live mode
            if (appMode === 'live') {
                appMode = 'browse';
                document.getElementById('liveSessionControls').classList.remove('active');
                document.getElementById('cameraContainer').style.display = 'none';
                document.getElementById('bottomTabBar').style.display = 'flex';
                document.getElementById('tabContent').classList.add('active');
                switchTab('home');
            }
        }

        // Animated score count-up (0 → target over 800ms, ease-out)
        function animateScoreCountUp(el, target) {
            if (!el || !target) return;
            const duration = 800;
            const start = performance.now();
            function tick(now) {
                const t = Math.min((now - start) / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3); // ease-out cubic
                el.textContent = Math.round(eased * target);
                if (t < 1) requestAnimationFrame(tick);
            }
            requestAnimationFrame(tick);
        }

        // Render mini skeleton on a small canvas from replay data
        function renderMiniSkeleton(canvas, replay) {
            if (!canvas || !replay?.frames?.length) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            // Find contact frame or middle frame
            let frameIdx = Math.floor(replay.frames.length / 2);
            for (let i = 0; i < replay.frames.length; i++) {
                if (replay.frames[i].phase === 'contact' || replay.frames[i].phase === 'acceleration') {
                    frameIdx = i;
                    break;
                }
            }
            const frame = replay.frames[frameIdx];
            if (!frame?.landmarks) return;
            const lm = frame.landmarks;

            const connections = [
                [11, 12], [11, 23], [12, 24], [23, 24],
                [12, 14], [14, 16], [11, 13], [13, 15],
                [24, 26], [26, 28], [23, 25], [25, 27]
            ];

            // Phase colors
            const phaseColors = {
                preparation: '#4FC3F7', loading: '#FFD60A',
                acceleration: '#FF9500', contact: '#FF3B30',
                followThrough: '#32D74B'
            };
            const color = phaseColors[frame.phase] || 'rgba(205,255,0,0.8)';

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            for (const [a, b] of connections) {
                if (lm[a] && lm[b]) {
                    ctx.beginPath();
                    ctx.moveTo(lm[a].x * w, lm[a].y * h);
                    ctx.lineTo(lm[b].x * w, lm[b].y * h);
                    ctx.stroke();
                }
            }

            // Joint dots
            ctx.fillStyle = color;
            for (const idx of [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28]) {
                if (lm[idx]) {
                    ctx.beginPath();
                    ctx.arc(lm[idx].x * w, lm[idx].y * h, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Render all mini skeletons in the recap moments row
        function renderMiniSkeletons() {
            const canvases = document.querySelectorAll('.recap-moment canvas');
            const allReplays = typeof window.strokeReplayManager !== 'undefined' ? window.strokeReplayManager.getAllReplays() : [];
            canvases.forEach(canvas => {
                const idx = parseInt(canvas.dataset.replayIndex);
                if (!isNaN(idx) && allReplays[idx]) {
                    renderMiniSkeleton(canvas, allReplays[idx]);
                }
            });
        }

        function shareSessionCard() {
            if (!tennisAI?.shareCardGenerator || !window._lastSessionSummary) return;
            tennisAI.shareCardGenerator.share(
                window._lastSessionSummary,
                window._lastSessionSummary.insights || []
            );
        }

        function playNotableReplay(replayIndex) {
            if (typeof window.strokeReplayManager === 'undefined') return;
            if (typeof openReplay === 'function') {
                openReplay(replayIndex);
            }
        }

        // Analytics Modal
        function showAnalytics() {
            if (typeof sessionStorage === 'undefined' || !sessionStorage.getAggregatedStats) {
                showToast('Session history not available');
                return;
            }

            const stats = sessionStorage.getAggregatedStats();
            const history = sessionStorage.getSessionHistory();

            // Get player profile stats
            let profileStats = null;
            if (typeof playerProfile !== 'undefined') {
                profileStats = playerProfile.getPlayerStats();
            }

            let html = '';

            if (!stats || stats.totalSessions === 0) {
                html = `
                    <div style="text-align: center; padding: 40px 20px; color: rgba(255,255,255,0.7);">
                        <div style="font-size: 24px; font-weight: bold; margin-bottom: 16px; letter-spacing: 2px;">STATS</div>
                        <div style="font-size: 16px;">No session history yet</div>
                        <div style="font-size: 14px; margin-top: 8px;">Complete a practice session to see your stats</div>
                    </div>
                `;
            } else {
                const trendIcon = stats.trend === 'improving' ? '↑' :
                                  stats.trend === 'declining' ? '↓' : '→';
                const trendClass = stats.trend === 'improving' ? 'positive' :
                                   stats.trend === 'declining' ? 'negative' : 'neutral';

                html = `
                    <div class="summary-stats">
                        <div class="summary-stat highlight">
                            <div class="summary-stat-value">${stats.overallAverage}</div>
                            <div class="summary-stat-label">Avg Score (All Time)</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${stats.totalSessions}</div>
                            <div class="summary-stat-label">Sessions</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${stats.totalStrokes}</div>
                            <div class="summary-stat-label">Total Strokes</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value" style="text-transform: capitalize;">${stats.mostPracticed}</div>
                            <div class="summary-stat-label">Most Practiced</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">
                                <span class="improvement-badge ${trendClass}">${trendIcon} ${stats.trend}</span>
                            </div>
                            <div class="summary-stat-label">Trend</div>
                        </div>
                    </div>
                `;

                if (stats.bestSession) {
                    const bestDate = new Date(stats.bestSession.date).toLocaleDateString();
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Personal Best</div>
                            <div class="drill-card">
                                <div class="drill-name">${stats.bestSession.score} Average Score</div>
                                <div class="drill-description">Achieved on ${bestDate}</div>
                            </div>
                        </div>
                    `;
                }

                // Player Profile: Milestones
                if (profileStats && profileStats.milestones && profileStats.milestones.length > 0) {
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Milestones</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${profileStats.milestones.slice(0, 6).map(m => `
                                    <span style="background: rgba(205, 255, 0, 0.2); color: var(--accent-volt); padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: 600;">
                                        ${m.label}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // Player Profile: Areas to Improve
                if (profileStats && profileStats.weaknesses && profileStats.weaknesses.length > 0) {
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Focus Areas</div>
                            ${profileStats.weaknesses.slice(0, 3).map(w => `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-bottom: 6px;">
                                    <span style="color: white;">${w.name}</span>
                                    <span style="font-size: 12px; color: ${w.improving ? 'var(--accent-volt)' : 'rgba(255,255,255,0.5)'};">
                                        ${w.improving ? '↑ Improving' : `${w.count} sessions`}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // Player Profile: Stroke Proficiency
                if (profileStats && profileStats.strokeProficiency) {
                    const strokes = Object.entries(profileStats.strokeProficiency)
                        .filter(([_, data]) => data.attempts > 0)
                        .sort((a, b) => b[1].avgScore - a[1].avgScore);

                    if (strokes.length > 0) {
                        html += `
                            <div class="summary-section">
                                <div class="summary-section-title">Stroke Proficiency</div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    ${strokes.map(([type, data]) => `
                                        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; text-align: center;">
                                            <div style="font-size: 20px; font-weight: bold; color: var(--accent-volt);">${Math.round(data.avgScore)}</div>
                                            <div style="font-size: 12px; color: white;">${type}</div>
                                            <div style="font-size: 10px; color: rgba(255,255,255,0.5);">${data.attempts} strokes</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                }

                // Recent Sessions
                if (history.length > 0) {
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Recent Sessions</div>
                            <div style="max-height: 200px; overflow-y: auto;">
                    `;

                    history.slice(0, 10).forEach(session => {
                        const date = new Date(session.date).toLocaleDateString();
                        const time = new Date(session.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        const s = session.summary;

                        if (s) {
                            html += `
                                <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <div style="font-weight: bold; color: white;">${date} ${time}</div>
                                            <div style="font-size: 12px; color: rgba(255,255,255,0.6);">
                                                ${s.totalStrokes} strokes • ${formatDuration(s.duration)}
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 24px; font-weight: bold; color: var(--accent-volt, #CDFF00);">${s.averageScore}</div>
                                            <div style="font-size: 10px; color: rgba(255,255,255,0.6);">${s.consistency}</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    });

                    html += `</div></div>`;
                }
            }

            document.getElementById('analyticsContent').innerHTML = html;
            document.getElementById('analyticsModal').classList.add('visible');
        }

        function closeAnalytics() {
            document.getElementById('analyticsModal').classList.remove('visible');
        }

        // ========================================
        // Challenge Mode Functions
        // ========================================

        function showChallenges() {
            renderChallengesList();
            document.getElementById('challengesModal').classList.add('visible');
        }

        function closeChallenges() {
            document.getElementById('challengesModal').classList.remove('visible');
        }

        function renderChallengesList() {
            if (typeof challengeMode === 'undefined') return;

            const challenges = challengeMode.getAvailableChallenges();
            const stats = challengeMode.getStats();

            let html = `
                <div style="margin-bottom: 16px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 800; color: var(--accent-volt);">${stats.completed}/${stats.total}</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Challenges Completed</div>
                </div>
            `;

            challenges.forEach(challenge => {
                const statusClass = challenge.isCompleted ? 'completed' : (challenge.isActive ? 'active' : '');
                const badge = challenge.isCompleted ? 'DONE' : (challenge.isActive ? 'Active' : '');

                html += `
                    <div class="challenge-card ${statusClass}" onclick="startChallenge('${challenge.id}')">
                        <div class="challenge-card-header">
                            <span class="challenge-card-icon">${challenge.icon}</span>
                            <span class="challenge-card-title">${challenge.name}</span>
                            ${badge ? `<span class="challenge-card-badge">${badge}</span>` : ''}
                        </div>
                        <div class="challenge-card-desc">${challenge.description}</div>
                        <span class="challenge-card-difficulty ${challenge.difficulty}">${challenge.difficulty}</span>
                    </div>
                `;
            });

            document.getElementById('challengesContent').innerHTML = html;
        }

        function startChallenge(challengeId) {
            if (typeof challengeMode === 'undefined') return;

            // Don't start if already completed
            if (challengeMode.isCompleted(challengeId)) {
                return;
            }

            const challenge = challengeMode.startChallenge(challengeId);
            if (challenge) {
                closeChallenges();
                // Enter live mode if not already
                if (appMode !== 'live') {
                    startLiveSession();
                }
                updateActiveChallengeBar();
            }
        }

        function updateActiveChallengeBar() {
            if (typeof challengeMode === 'undefined') return;

            const challengeBar = document.getElementById('activeChallengeBar');
            const info = challengeMode.getActiveChallengeInfo();

            if (!info) {
                challengeBar.style.display = 'none';
                return;
            }

            challengeBar.style.display = 'flex';
            document.getElementById('activeChallengeIcon').textContent = info.icon;
            document.getElementById('activeChallengeName').textContent = info.name;
            document.getElementById('activeChallengeText').textContent = `${info.progress}/${info.target}`;

            const progressPercent = (info.progress / info.target) * 100;
            document.getElementById('activeChallengeProgress').style.width = `${progressPercent}%`;
        }

        function recordChallengeStroke(strokeData) {
            if (typeof challengeMode === 'undefined' || !challengeMode.activeChallenge) return;

            const result = challengeMode.recordStroke(strokeData);

            if (result) {
                updateActiveChallengeBar();

                if (result.complete) {
                    showChallengeComplete(result.challenge);
                }
            }
        }

        function showChallengeComplete(challenge) {
            document.getElementById('completedChallengeName').textContent = challenge.name;
            document.getElementById('completedChallengeReward').textContent = `Reward: ${challenge.reward}`;
            document.getElementById('challengeCompleteOverlay').style.display = 'flex';

            // Hide challenge bar
            document.getElementById('activeChallengeBar').style.display = 'none';
        }

        function closeChallengeComplete() {
            document.getElementById('challengeCompleteOverlay').style.display = 'none';
        }

        // ========================================
        // Drill Mode Functions
        // ========================================

        let lastDrillId = null;

        function showDrillSelection() {
            renderDrillList();
            document.getElementById('drillModal').classList.add('visible');
        }

        function closeDrillModal() {
            document.getElementById('drillModal').classList.remove('visible');
        }

        function renderDrillList() {
            if (typeof drillMode === 'undefined') return;

            const skillLevel = tennisAI?.playerProfile?.skillLevel || 'intermediate';
            let html = '';

            // Auto drill from improvement plan
            const autoDrill = drillMode.buildAutoDrill(skillLevel);
            if (autoDrill) {
                html += `
                    <div class="drill-card-badge">Recommended from your plan</div>
                    <div class="drill-card recommended" onclick="startDrill('auto')">
                        <div class="drill-card-header">
                            <span class="drill-card-name">${autoDrill.name}</span>
                            <span class="drill-card-reps">${autoDrill.totalReps} reps</span>
                        </div>
                        <div class="drill-card-desc">${autoDrill.description}</div>
                        <div class="drill-card-meta">
                            ${autoDrill.strokeType ? `<span class="drill-card-stroke">${autoDrill.strokeType}</span>` : '<span class="drill-card-stroke">Any stroke</span>'}
                            <span class="drill-card-target">Target: ${autoDrill.target}${autoDrill.unit ? ' ' + autoDrill.unit : ''}</span>
                        </div>
                    </div>
                `;
            }

            // Predefined drills
            Object.values(drillMode.drills).forEach(drill => {
                const target = drill.targets?.[skillLevel] || drill.targets?.intermediate;
                const strokeLabel = drill.strokeType || (drill.acceptedTypes ? drill.acceptedTypes.join('/') : 'Any');
                html += `
                    <div class="drill-card" onclick="startDrill('${drill.id}')">
                        <div class="drill-card-header">
                            <span class="drill-card-name">${drill.name}</span>
                            <span class="drill-card-reps">${drill.totalReps} reps</span>
                        </div>
                        <div class="drill-card-desc">${drill.description}</div>
                        <div class="drill-card-meta">
                            <span class="drill-card-stroke">${strokeLabel}</span>
                            <span class="drill-card-target">Target: ${target}${drill.unit ? ' ' + drill.unit : ''}</span>
                        </div>
                    </div>
                `;
            });

            document.getElementById('drillListContent').innerHTML = html;
        }

        function startDrill(drillId) {
            if (typeof drillMode === 'undefined') return;

            const skillLevel = tennisAI?.playerProfile?.skillLevel || 'intermediate';
            const drill = drillMode.startDrill(drillId, skillLevel);
            if (!drill) return;

            lastDrillId = drillId;
            closeDrillModal();

            // Enter live mode if not already
            if (appMode !== 'live') {
                startLiveSession();
            }

            // Auto-start analysis if not running
            if (tennisAI && !tennisAI.isAnalyzing) {
                tennisAI.startAnalysis();
            }

            showDrillHUD(drill);
        }

        function showDrillHUD(drill) {
            const hud = document.getElementById('drillHUD');
            document.getElementById('drillHudName').textContent = drill.name;
            document.getElementById('drillProgressText').textContent = `0/${drill.totalReps}`;
            document.getElementById('drillProgressFill').style.width = '0%';
            document.getElementById('drillMetricDisplay').style.display = 'none';
            document.getElementById('drillMetricLabel').textContent = drill.metricLabel;
            document.getElementById('drillMetricTarget').textContent = `Target: ${drill.target}${drill.unit ? ' ' + drill.unit : ''}`;
            renderRepDots(drill);
            hud.style.display = 'flex';

            // Hide challenge bar if active
            document.getElementById('activeChallengeBar').style.display = 'none';
        }

        function renderRepDots(drill) {
            let html = '';
            for (let i = 0; i < drill.totalReps; i++) {
                html += `<div class="drill-rep-dot" id="drillDot${i}"></div>`;
            }
            document.getElementById('drillRepDots').innerHTML = html;
        }

        function recordDrillStroke(strokeData) {
            if (typeof drillMode === 'undefined' || !drillMode.isActive) return;

            const result = drillMode.recordStroke(strokeData);
            if (!result) return;

            if (result.wrongType) {
                showDrillWrongType(result.expectedType);
                return;
            }

            if (result.error) return;

            updateDrillHUD(result);

            if (result.isComplete) {
                setTimeout(() => showDrillSummary(), 800);
            }
        }

        function updateDrillHUD(result) {
            // Update progress
            const pct = (result.rep / result.totalReps) * 100;
            document.getElementById('drillProgressFill').style.width = `${pct}%`;
            document.getElementById('drillProgressText').textContent = `${result.rep}/${result.totalReps}`;

            // Show big metric value with pop animation
            const metricDisplay = document.getElementById('drillMetricDisplay');
            const metricValue = document.getElementById('drillMetricValue');
            const valueStr = result.metricValue < 10 ? result.metricValue.toFixed(1) : Math.round(result.metricValue);

            metricDisplay.style.display = 'block';
            metricValue.textContent = valueStr;

            // Color based on distance from target
            metricValue.classList.remove('at-target', 'close', 'far');
            if (result.hitTarget) {
                metricValue.classList.add('at-target');
            } else if (result.metricValue >= result.target * 0.8) {
                metricValue.classList.add('close');
            } else {
                metricValue.classList.add('far');
            }

            // Re-trigger pop animation
            metricDisplay.style.animation = 'none';
            metricDisplay.offsetHeight; // force reflow
            metricDisplay.style.animation = 'drillMetricPop 0.3s ease';

            // Update rep dot
            const dotIdx = result.rep - 1;
            const dot = document.getElementById(`drillDot${dotIdx}`);
            if (dot) {
                const dotValue = result.metricValue < 10 ? result.metricValue.toFixed(0) : Math.round(result.metricValue);
                dot.textContent = dotValue;
                if (result.hitTarget) {
                    dot.classList.add('hit');
                } else if (result.metricValue >= result.target * 0.8) {
                    dot.classList.add('close');
                } else {
                    dot.classList.add('miss');
                }
            }

            // Auto-hide metric after 3s
            clearTimeout(window._drillMetricTimeout);
            window._drillMetricTimeout = setTimeout(() => {
                metricDisplay.style.display = 'none';
            }, 3000);
        }

        function showDrillWrongType(expectedType) {
            // Remove any existing wrong-type indicator
            const existing = document.querySelector('.drill-hud-wrong-type');
            if (existing) existing.remove();

            const indicator = document.createElement('div');
            indicator.className = 'drill-hud-wrong-type';
            indicator.textContent = `Need: ${expectedType}`;
            document.body.appendChild(indicator);

            setTimeout(() => indicator.remove(), 1500);
        }

        function showDrillSummary() {
            const summary = drillMode.stopDrill();
            if (!summary) return;

            document.getElementById('drillHUD').style.display = 'none';

            // Populate summary
            document.getElementById('drillSummaryName').textContent = summary.drillName;

            // Stats row
            const hitPct = summary.totalReps > 0 ? Math.round((summary.repsAtTarget / summary.totalReps) * 100) : 0;
            document.getElementById('drillSummaryStats').innerHTML = `
                <div class="drill-stat">
                    <div class="drill-stat-value">${summary.average < 10 ? summary.average.toFixed(1) : Math.round(summary.average)}</div>
                    <div class="drill-stat-label">Average${summary.unit ? ' (' + summary.unit + ')' : ''}</div>
                </div>
                <div class="drill-stat">
                    <div class="drill-stat-value">${summary.repsAtTarget}/${summary.totalReps}</div>
                    <div class="drill-stat-label">At Target</div>
                </div>
                <div class="drill-stat">
                    <div class="drill-stat-value">${summary.best < 10 ? summary.best.toFixed(1) : Math.round(summary.best)}</div>
                    <div class="drill-stat-label">Best</div>
                </div>
            `;

            // Bar chart
            const maxVal = Math.max(summary.target * 1.3, summary.best * 1.1);
            let chartHtml = '';
            summary.scores.forEach((score, i) => {
                const heightPct = Math.max(5, (score.value / maxVal) * 100);
                let barClass = 'miss';
                if (score.value >= summary.target) barClass = 'hit';
                else if (score.value >= summary.target * 0.8) barClass = 'close';

                chartHtml += `<div class="drill-chart-bar ${barClass}" style="height: ${heightPct}%"></div>`;
            });

            // Target line
            const targetPct = (summary.target / maxVal) * 100;
            chartHtml += `<div class="drill-chart-target-line" style="bottom: ${targetPct}%; position: absolute; left: 0; right: 0;"></div>`;

            document.getElementById('drillSummaryChart').innerHTML = chartHtml;
            document.getElementById('drillSummaryChart').style.position = 'relative';

            // Trend text
            const trendText = summary.trend === 'improving' ? 'Trending up across reps' :
                             summary.trend === 'declining' ? 'Consistency dropped toward the end' :
                             'Consistent performance throughout';
            const trendEl = document.querySelector('.drill-summary-trend');
            if (trendEl) {
                trendEl.textContent = trendText;
            } else {
                // Insert trend before actions
                const actions = document.querySelector('.drill-summary-actions');
                if (actions) {
                    const div = document.createElement('div');
                    div.className = 'drill-summary-trend';
                    div.textContent = trendText;
                    actions.parentNode.insertBefore(div, actions);
                }
            }

            document.getElementById('drillSummaryOverlay').style.display = 'flex';
        }

        function closeDrillSummary() {
            document.getElementById('drillSummaryOverlay').style.display = 'none';
        }

        function repeatDrill() {
            closeDrillSummary();
            if (lastDrillId) {
                startDrill(lastDrillId);
            }
        }

        function stopDrill() {
            if (typeof drillMode !== 'undefined' && drillMode.isActive) {
                showDrillSummary();
            }
        }

        // ========================================
        // Pro Comparison Functions
        // ========================================

        let selectedPro = null;

        function showProComparison() {
            document.getElementById('proComparisonModal').classList.add('visible');
            updateProComparisonDisplay();
        }

        function closeProComparison() {
            document.getElementById('proComparisonModal').classList.remove('visible');
        }

        function selectPro(proId) {
            selectedPro = proId;

            // Update UI selection
            document.querySelectorAll('.pro-card').forEach(card => card.classList.remove('selected'));
            document.getElementById(`pro-${proId}`).classList.add('selected');

            updateProComparisonDisplay();
        }

        function updateProComparisonDisplay() {
            const resultsDiv = document.getElementById('proComparisonResults');
            const emptyDiv = document.getElementById('proComparisonEmpty');
            const detailsDiv = document.getElementById('proComparisonDetails');
            const tipDiv = document.getElementById('proCoachingTip');

            // Check if we have stroke data
            if (!tennisAI || !tennisAI.enhancedAnalyzer || tennisAI.enhancedAnalyzer.sessionStats.totalStrokes === 0) {
                resultsDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                return;
            }

            if (!selectedPro) {
                resultsDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                emptyDiv.innerHTML = '<div style="font-size: 14px;">Select a pro above to compare your technique.</div>';
                return;
            }

            emptyDiv.style.display = 'none';
            resultsDiv.style.display = 'block';

            // Get pro profile and user's recent stroke data
            const proReferences = tennisAI.enhancedAnalyzer.proReferences;
            const proProfile = proReferences.getPlayerProfile(selectedPro);
            const lastStroke = tennisAI.enhancedAnalyzer.lastStrokeData;

            if (!lastStroke || !proProfile) {
                resultsDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                emptyDiv.innerHTML = '<div style="font-size: 14px;">Complete a stroke to see comparison.</div>';
                return;
            }

            // Get comparison data
            const comparison = lastStroke.proComparison;
            const similarity = comparison ? Math.round(comparison.overallSimilarity * 100) : 0;

            // Update similarity score
            document.getElementById('proSimilarityScore').textContent = `${similarity}%`;

            // Build comparison details
            let html = '<div class="comparison-metrics">';

            // Velocity comparison
            const velRatio = comparison?.velocityRatio || 0;
            html += buildComparisonMetric('Racquet Speed', velRatio, 'velocity');

            // Acceleration comparison
            const accRatio = comparison?.accelerationRatio || 0;
            html += buildComparisonMetric('Acceleration', accRatio, 'acceleration');

            // Rotation comparison
            const rotRatio = comparison?.rotationRatio || 0;
            html += buildComparisonMetric('Body Rotation', rotRatio, 'rotation');

            html += '</div>';

            // Strengths and improvements
            if (comparison) {
                if (comparison.strengths.length > 0) {
                    html += `<div style="margin-top: 16px;">
                        <div style="font-size: 11px; text-transform: uppercase; color: var(--accent-volt); margin-bottom: 8px;">Your Strengths</div>
                        <div style="font-size: 13px; color: white;">${comparison.strengths.join(' • ')}</div>
                    </div>`;
                }

                if (comparison.improvements.length > 0) {
                    html += `<div style="margin-top: 12px;">
                        <div style="font-size: 11px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 8px;">Focus Areas</div>
                        <div style="font-size: 13px; color: white;">${comparison.improvements.join(' • ')}</div>
                    </div>`;
                }
            }

            detailsDiv.innerHTML = html;

            // Coaching tip based on pro style
            const proTips = {
                federer: `To develop Federer-like technique, focus on fluid motion and early preparation. His forehand is built on timing and effortless power, not muscling the ball.`,
                djokovic: `Djokovic's game is built on flexibility and consistency. Work on staying low through contact and maximizing your court coverage.`,
                nadal: `To hit like Nadal, focus on extreme topspin and aggressive hip rotation. His lasso forehand comes from tremendous racquet head speed generated by the whole body.`,
                serena: `Serena's power comes from explosive leg drive and core rotation. Focus on loading your legs and driving up through the shot.`
            };

            tipDiv.innerHTML = `<div style="font-size: 13px; color: white;">${proTips[selectedPro] || 'Study the pro\'s technique and work on matching their form.'}</div>`;
        }

        function buildComparisonMetric(label, ratio, type) {
            const percent = Math.round(ratio * 100);
            const diff = percent - 100;
            const diffClass = diff >= 0 ? 'positive' : 'negative';
            const diffText = diff >= 0 ? `+${diff}%` : `${diff}%`;

            return `
                <div class="comparison-metric">
                    <div class="comparison-metric-label">${label}</div>
                    <div class="comparison-metric-values">
                        <span class="comparison-you">${percent}%</span>
                        <span class="comparison-vs">of pro</span>
                        <span class="comparison-diff ${diffClass}">${diffText}</span>
                    </div>
                </div>
            `;
        }

        // ========================================
        // Analysis Mode Functions
        // ========================================

        let appMode = 'browse'; // 'browse' | 'live'
        let currentTab = 'home';
        let analysisVideoElement = null;
        let selectedStroke = null;
        let _drillTabPopulated = false;
        let _challengeTabPopulated = false;
        let _profileTabPopulated = false;

        // Keep legacy alias so any stray reference doesn't crash
        let currentMode = 'practice';

        function switchTab(tabName) {
            currentTab = tabName;
            // Update tab bar active state
            document.querySelectorAll('#bottomTabBar .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });
            // Show/hide panels
            document.querySelectorAll('#tabContent .tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === 'tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1));
            });

            // Lazy-populate content
            if (tabName === 'upload' && !document.getElementById('uploadTabContent').hasChildNodes()) {
                // Move analysis mode container into upload tab
                const amc = document.getElementById('analysisModeContainer');
                if (amc) {
                    amc.classList.add('active');
                    document.getElementById('uploadTabContent').appendChild(amc);
                }
            }
            if (tabName === 'drills' && !_drillTabPopulated) {
                populateDrillTab();
            }
            if (tabName === 'challenges' && !_challengeTabPopulated) {
                populateChallengeTab();
            }
            if (tabName === 'profile' && !_profileTabPopulated) {
                populateProfileTab();
            }
            if (tabName === 'home') {
                populateHomeStats();
            }
        }

        function startLiveSession() {
            appMode = 'live';
            currentMode = 'practice';

            // Hide browse UI
            document.getElementById('bottomTabBar').style.display = 'none';
            document.getElementById('tabContent').classList.remove('active');

            // Show camera + live controls
            const cam = document.getElementById('cameraContainer');
            cam.style.display = 'block';
            cam.style.opacity = '1';
            document.getElementById('liveSessionControls').classList.add('active');

            // Show live-mode overlays
            document.querySelector('.status-bar').style.display = '';
            document.querySelector('.coaching-panel').style.display = '';

            // Auto-start analysis
            if (tennisAI && tennisAI.isReady && !tennisAI.isAnalyzing) {
                tennisAI.startAnalysis();
            }

            // Create session if needed
            if (typeof sessionStorage !== 'undefined' && sessionStorage.createSession) {
                const existingSession = sessionStorage.getCurrentSession();
                if (!existingSession) {
                    sessionStorage.createSession();
                }
            }
        }

        function endLiveSession() {
            appMode = 'browse';

            // Stop analysis
            if (tennisAI && tennisAI.isAnalyzing) {
                tennisAI.stopAnalysis();
            }

            // Stop active drill
            if (typeof drillMode !== 'undefined' && drillMode.isActive) {
                drillMode.stopDrill();
                document.getElementById('drillHUD').style.display = 'none';
            }

            // Hide live controls
            document.getElementById('liveSessionControls').classList.remove('active');

            // Trigger session reset (shows summary if strokes were hit)
            resetSession();

            // Return to browse mode
            document.getElementById('cameraContainer').style.display = 'none';
            document.getElementById('bottomTabBar').style.display = 'flex';
            document.getElementById('tabContent').classList.add('active');
            switchTab('home');
        }

        function startDrillFromTab(drillId) {
            startLiveSession();
            // Small delay to let camera show before starting drill
            setTimeout(() => {
                if (typeof drillMode !== 'undefined') {
                    const skillLevel = tennisAI?.playerProfile?.skillLevel || 'intermediate';
                    const drill = drillMode.startDrill(drillId, skillLevel);
                    if (drill) {
                        lastDrillId = drillId;
                        showDrillHUD(drill);
                    }
                }
            }, 300);
        }

        function startChallengeFromTab(challengeId) {
            if (typeof challengeMode === 'undefined') return;
            if (challengeMode.isCompleted(challengeId)) return;

            const challenge = challengeMode.startChallenge(challengeId);
            if (challenge) {
                startLiveSession();
                updateActiveChallengeBar();
            }
        }

        function populateDrillTab() {
            _drillTabPopulated = true;
            const container = document.getElementById('drillTabCards');
            if (typeof drillMode === 'undefined' || !drillMode.drills) {
                container.innerHTML = '<div style="color:var(--text-muted);text-align:center;padding:40px 0;">No drills available yet.</div>';
                return;
            }

            let html = '';
            const drills = drillMode.drills || drillMode.getDrills?.() || [];
            const drillList = Array.isArray(drills) ? drills : Object.values(drills);

            drillList.forEach(drill => {
                html += `
                    <div class="drill-card" onclick="startDrillFromTab('${drill.id}')">
                        <div class="drill-card-icon">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
                        </div>
                        <div class="drill-card-info">
                            <div class="drill-card-name">${drill.name}</div>
                            <div class="drill-card-desc">${drill.description || drill.metricLabel || ''}</div>
                        </div>
                        <div class="drill-card-chevron">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html || '<div style="color:var(--text-muted);text-align:center;padding:40px 0;">No drills available.</div>';
        }

        function populateChallengeTab() {
            _challengeTabPopulated = true;
            const container = document.getElementById('challengeTabCards');
            if (typeof challengeMode === 'undefined') {
                container.innerHTML = '<div style="color:var(--text-muted);text-align:center;padding:40px 0;">Challenges not available yet.</div>';
                return;
            }

            const challenges = challengeMode.getAvailableChallenges();
            const stats = challengeMode.getStats();

            let html = `
                <div style="text-align:center;margin-bottom:20px;">
                    <div style="font-size:28px;font-weight:800;color:var(--accent-volt);">${stats.completed}/${stats.total}</div>
                    <div style="font-size:12px;color:var(--text-muted);">Completed</div>
                </div>
            `;

            challenges.forEach(ch => {
                const completed = ch.isCompleted;
                html += `
                    <div class="challenge-card-tab ${completed ? 'completed' : ''}" onclick="startChallengeFromTab('${ch.id}')">
                        <div class="challenge-card-tab-icon">${ch.icon || ''}</div>
                        <div class="challenge-card-tab-info">
                            <div class="challenge-card-tab-name">${ch.name}</div>
                            <div class="challenge-card-tab-desc">${ch.description}</div>
                        </div>
                        ${completed ? '<span class="challenge-card-tab-badge">DONE</span>' : `
                        <div class="challenge-card-tab-chevron">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
                        </div>`}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function populateProfileTab() {
            _profileTabPopulated = true;
            const container = document.getElementById('profileTabContent');
            let html = '';

            // --- Data sources ---
            const profile = (typeof playerProfile !== 'undefined') ? playerProfile.profile : null;
            const localOb = (() => { try { return JSON.parse(localStorage.getItem('ace_onboarding') || '{}'); } catch(e) { return {}; } })();
            const displayName = profile?.displayName || (typeof onboardingState !== 'undefined' && onboardingState.displayName) || localOb.displayName || null;
            const coachKey = profile?.coachPreference || (typeof onboardingState !== 'undefined' && onboardingState.coachPreference) || localOb.coachPreference || 'alex';
            const ntrpLevel = profile?.ntrpLevel || (typeof onboardingState !== 'undefined' && onboardingState.ntrpLevel) || localOb.ntrpLevel || null;
            const tier = profile?.subscriptionTier || 'free';
            const goals = profile?.improvementGoals || (typeof onboardingState !== 'undefined' && onboardingState.goals) || localOb.goals || [];

            // Coach avatar SVG by key
            const coachAvatars = {
                alex: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
                jordan: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></svg>',
                sam: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>'
            };
            const avatarSvg = coachAvatars[coachKey] || coachAvatars.alex;

            // Tier badge
            const tierLabel = tier === 'pro' ? 'Pro' : tier === 'trial' ? 'Trial' : 'Free';
            const tierClass = tier === 'pro' ? 'pro' : tier === 'trial' ? 'trial' : 'free';

            // 1. HEADER
            html += `<div class="profile-header">
                <div class="profile-avatar">${avatarSvg}</div>
                <div class="profile-name">${displayName || 'Player'}</div>
                <div class="profile-meta">
                    ${ntrpLevel ? `<span>${ntrpLevel} NTRP</span>` : ''}
                    <span class="profile-tier-badge ${tierClass}">${tierLabel}</span>
                </div>
            </div>`;

            // 2. STATS ROW
            let stats = null;
            if (typeof sessionStorage !== 'undefined' && sessionStorage.getAggregatedStats) {
                stats = sessionStorage.getAggregatedStats();
            }
            const totalSessions = stats?.totalSessions || profile?.totalSessions || 0;
            const totalStrokes = stats?.totalStrokes || profile?.totalStrokes || 0;
            const totalTime = profile?.totalPracticeTime || (stats?.totalDuration) || 0;
            const timeHours = (totalTime / 3600000).toFixed(1);

            html += '<div class="profile-section">';
            html += `<div class="home-stats-row" style="margin-bottom:8px;">
                <div class="home-stat"><div class="home-stat-value">${totalSessions}</div><div class="home-stat-label">Sessions</div></div>
                <div class="home-stat"><div class="home-stat-value">${totalStrokes}</div><div class="home-stat-label">Strokes</div></div>
                <div class="home-stat"><div class="home-stat-value">${timeHours}h</div><div class="home-stat-label">Time</div></div>
            </div>`;
            html += '</div>';

            // 3. STROKE PROFICIENCY
            const strokeProf = profile?.strokeProficiency;
            if (strokeProf) {
                const activeTypes = Object.entries(strokeProf).filter(([_, p]) => p.attempts > 0);
                if (activeTypes.length > 0) {
                    html += '<div class="profile-section">';
                    html += '<div class="profile-section-title">Stroke Proficiency</div>';
                    activeTypes.forEach(([type, prof]) => {
                        const score = Math.round(prof.avgScore);
                        const pct = Math.min(100, score);
                        const barColor = score >= 75 ? '#4CAF50' : score >= 60 ? 'var(--accent-volt)' : '#F44336';
                        let detail = `${prof.attempts} strokes`;
                        if (prof.bestScore > 0) detail += ` &middot; Best ${Math.round(prof.bestScore)}`;
                        // Trend arrow from improvementTracker if available
                        if (typeof improvementTracker !== 'undefined') {
                            const progress = improvementTracker.getProgressForStroke?.(type);
                            if (progress && progress.trend === 'improving') detail += ' &middot; <span style="color:#4CAF50">↑</span>';
                            else if (progress && progress.trend === 'declining') detail += ' &middot; <span style="color:#F44336">↓</span>';
                        }
                        html += `<div class="profile-proficiency-row">
                            <div class="profile-proficiency-header">
                                <div class="profile-proficiency-type">${type}</div>
                                <div class="profile-proficiency-score" style="color:${barColor}">${score}</div>
                            </div>
                            <div class="profile-proficiency-bar"><div class="profile-proficiency-bar-fill" style="width:${pct}%;background:${barColor}"></div></div>
                            <div class="profile-proficiency-detail">${detail}</div>
                        </div>`;
                    });
                    html += '</div>';
                }
            }

            // 4. MILESTONES
            const milestones = profile?.milestones;
            if (milestones && milestones.length > 0) {
                html += '<div class="profile-section">';
                html += '<div class="profile-section-title">Milestones</div>';
                html += '<div class="profile-milestones">';
                milestones.forEach(m => {
                    html += `<span class="profile-milestone-pill">${m.label || m}</span>`;
                });
                html += '</div></div>';
            }

            // 5. GOALS
            if (goals && goals.length > 0) {
                html += '<div class="profile-section">';
                html += '<div class="profile-section-title">Goals</div>';
                html += '<div class="profile-goals">';
                goals.forEach(g => {
                    html += `<span class="profile-goal-chip">${g}</span>`;
                });
                html += '</div></div>';
            }

            // 6. SETTINGS
            html += '<div class="profile-section">';
            html += '<div class="profile-section-title">Settings</div>';

            // Ghost overlay
            html += `
                <div class="profile-row" onclick="toggleGhost()">
                    <div class="profile-row-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/><line x1="12" y1="2" x2="12" y2="4"/><line x1="12" y1="20" x2="12" y2="22"/><line x1="2" y1="12" x2="4" y2="12"/><line x1="20" y1="12" x2="22" y2="12"/></svg>
                    </div>
                    <div class="profile-row-text">Ghost Overlay</div>
                    <div class="profile-row-value" id="profileGhostStatus">${typeof ghostOverlay !== 'undefined' && ghostOverlay.enabled ? 'On' : 'Off'}</div>
                </div>
            `;

            // Calibration
            html += `
                <div class="profile-row" onclick="openCalibrationModal()">
                    <div class="profile-row-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                    </div>
                    <div class="profile-row-text">Calibration</div>
                    <div class="profile-row-chevron">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
                    </div>
                </div>
            `;

            // Sign out (if authenticated)
            if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                html += `
                    <div class="profile-row danger" onclick="handleSignOut()">
                        <div class="profile-row-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
                        </div>
                        <div class="profile-row-text">Sign Out</div>
                    </div>
                `;
            }
            html += '</div>';

            container.innerHTML = html;
        }

        function populateHomeStats() {
            try {
                // --- Personalized greeting ---
                const greetingEl = document.getElementById('homeGreetingText');
                const coachLineEl = document.getElementById('homeCoachLine');
                const progressEl = document.getElementById('homeProgressTidbit');

                // Get display name from playerProfile (returning user) or onboardingState (mid-onboarding)
                const displayName = (typeof playerProfile !== 'undefined' && playerProfile.profile?.displayName)
                    || (typeof onboardingState !== 'undefined' && onboardingState.displayName)
                    || null;

                // Get stats
                let stats = null;
                if (typeof sessionStorage !== 'undefined' && sessionStorage.getAggregatedStats) {
                    stats = sessionStorage.getAggregatedStats();
                }
                const hasSessions = stats && stats.totalSessions > 0;

                // Time-of-day greeting
                if (greetingEl) {
                    if (!hasSessions && !displayName) {
                        greetingEl.innerHTML = 'ACE<span class="accent">.</span>';
                    } else {
                        const hour = new Date().getHours();
                        let timeGreeting;
                        if (hour < 12) timeGreeting = 'Good morning';
                        else if (hour < 17) timeGreeting = 'Good afternoon';
                        else timeGreeting = 'Good evening';

                        if (hasSessions && displayName) {
                            greetingEl.textContent = `${timeGreeting}, ${displayName}.`;
                        } else if (displayName) {
                            greetingEl.textContent = `Welcome, ${displayName}.`;
                        } else {
                            greetingEl.textContent = `${timeGreeting}.`;
                        }
                    }
                }

                // Coach line
                if (coachLineEl) {
                    const coachKey = (typeof playerProfile !== 'undefined' && playerProfile.profile?.coachPreference)
                        || (typeof onboardingState !== 'undefined' && onboardingState.coachPreference)
                        || 'alex';
                    try {
                        const configs = GPTVoiceCoach.getCoachConfigs();
                        const coach = configs[coachKey] || configs.alex;
                        coachLineEl.textContent = coach.name;
                    } catch (e) {
                        coachLineEl.textContent = '';
                    }
                }

                // Progress tidbit
                if (progressEl) {
                    let tidbit = null;
                    if (typeof improvementTracker !== 'undefined' && hasSessions) {
                        tidbit = improvementTracker.getTopProgress?.();
                    }
                    if (tidbit) {
                        progressEl.textContent = tidbit;
                        progressEl.classList.remove('muted');
                    } else if (hasSessions && stats.trend && stats.trend !== 'stable') {
                        progressEl.textContent = stats.trend === 'improving' ? 'Your game is trending up' : 'Time to refocus — your scores dipped recently';
                        progressEl.classList.remove('muted');
                    } else if (!hasSessions) {
                        progressEl.textContent = 'Hit 5 strokes to unlock your first analysis.';
                        progressEl.classList.add('muted');
                    } else {
                        progressEl.textContent = '';
                    }
                }

                // --- Stats card ---
                if (hasSessions) {
                    document.getElementById('homeStatsCard').style.display = '';
                    const avgEl = document.getElementById('homeStatAvg');
                    const avgVal = Math.round(stats.overallAverage || 0);
                    let trendArrow = '';
                    if (stats.trend === 'improving') trendArrow = ' <span style="color:#4CAF50">↑</span>';
                    else if (stats.trend === 'declining') trendArrow = ' <span style="color:#F44336">↓</span>';
                    avgEl.innerHTML = avgVal + trendArrow;
                    document.getElementById('homeStatStrokes').textContent = stats.totalStrokes;
                    document.getElementById('homeStatSessions').textContent = stats.totalSessions;
                }

                // --- Plan card ---
                if (typeof improvementTracker !== 'undefined') {
                    const plan = improvementTracker.getCoachingPlan?.();
                    if (plan && plan.focusAreas && plan.focusAreas.length > 0) {
                        document.getElementById('homePlanCard').style.display = '';
                        const planContainer = document.getElementById('homePlanItems');
                        planContainer.innerHTML = plan.focusAreas.slice(0, 3).map(fa => `
                            <div class="home-plan-item">
                                <div class="home-plan-dot"></div>
                                <div>
                                    <div class="home-plan-text">${fa.area || fa.metric || fa.drill || ''}</div>
                                    ${fa.target ? `<div style="font-size:11px;color:var(--text-muted);margin-top:1px;">Target: ${fa.target}</div>` : ''}
                                </div>
                            </div>
                        `).join('');
                    }
                }
            } catch (e) {
                console.log('populateHomeStats:', e);
            }
        }

        function openSettings() {
            const sheet = document.getElementById('settingsSheet');
            sheet.classList.add('active');
            // Update ghost status
            const ghostStatus = typeof ghostOverlay !== 'undefined' && ghostOverlay.enabled ? 'On' : 'Off';
            const el = document.getElementById('settingsGhostStatus');
            if (el) el.textContent = ghostStatus;
            // Show sign out if authenticated
            if (typeof supabaseClient !== 'undefined' && supabaseClient.isAuthenticated()) {
                const so = document.getElementById('settingsSignOut');
                if (so) so.style.display = '';
            }
        }

        function closeSettings() {
            document.getElementById('settingsSheet').classList.remove('active');
        }

        // Legacy switchMode stub for any external references
        function switchMode(mode) {
            if (mode === 'analysis') {
                switchTab('upload');
            } else {
                switchTab('home');
            }
        }

        // Video Upload Handling
        function initVideoUpload() {
            const uploadZone = document.getElementById('videoUploadZone');
            const fileInput = document.getElementById('videoFileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    loadAnalysisVideo(file);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadAnalysisVideo(file);
                }
            });
        }

        async function loadAnalysisVideo(file) {
            const uploadZone = document.getElementById('videoUploadZone');
            const playerArea = document.getElementById('videoPlayerArea');
            const video = document.getElementById('analysisVideo');
            const progressOverlay = document.getElementById('analysisProgressOverlay');

            // Show player area
            uploadZone.classList.add('has-video');
            playerArea.classList.add('active');

            // Load video
            const url = URL.createObjectURL(file);
            video.src = url;
            analysisVideoElement = video;

            video.onloadedmetadata = async () => {
                // Set up canvas size
                const canvas = document.getElementById('analysisCanvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Update timeline
                updateTimelineDisplay();

                // Start analysis
                progressOverlay.classList.add('active');

                try {
                    await videoAnalyzer.initialize();
                    await videoAnalyzer.loadVideo(file);

                    const result = await videoAnalyzer.analyzeVideo((progress) => {
                        document.getElementById('analysisProgressFill').style.width = progress + '%';
                        document.getElementById('analysisProgressPercent').textContent = Math.round(progress) + '%';
                    });

                    // Add stroke markers to timeline
                    renderStrokeMarkers(result.strokes);

                    progressOverlay.classList.remove('active');
                } catch (error) {
                    console.error('Analysis failed:', error);
                    progressOverlay.classList.remove('active');
                    showToast('Failed to analyze video: ' + error.message);
                }
            };

            // Set up video time update
            video.ontimeupdate = updateTimelineDisplay;
        }

        function updateTimelineDisplay() {
            const video = document.getElementById('analysisVideo');
            if (!video || !video.duration) return;

            const current = video.currentTime;
            const duration = video.duration;
            const percent = (current / duration) * 100;

            document.getElementById('timelineProgress').style.width = percent + '%';
            document.getElementById('timelinePlayhead').style.left = percent + '%';
            document.getElementById('timelineTime').textContent =
                `${formatVideoTime(current)} / ${formatVideoTime(duration)}`;
        }

        function formatVideoTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function renderStrokeMarkers(strokes) {
            const track = document.getElementById('timelineTrack');
            const video = document.getElementById('analysisVideo');

            // Remove existing markers
            track.querySelectorAll('.stroke-marker').forEach(m => m.remove());

            strokes.forEach((stroke, index) => {
                const marker = document.createElement('div');
                marker.className = `stroke-marker ${stroke.type}`;
                marker.style.left = `calc(${(stroke.time / video.duration) * 100}% - 4px)`;
                marker.title = `${stroke.type} - ${stroke.quality}`;
                marker.dataset.strokeIndex = index;

                marker.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectStroke(stroke, index);
                });

                track.appendChild(marker);
            });
        }

        let comparisonStrokes = [];

        function selectStroke(stroke, index) {
            selectedStroke = stroke;
            selectedStroke._index = index;

            // Update marker selection
            document.querySelectorAll('.stroke-marker').forEach(m => m.classList.remove('selected'));
            document.querySelector(`.stroke-marker[data-stroke-index="${index}"]`)?.classList.add('selected');

            // Seek video to stroke time
            const video = document.getElementById('analysisVideo');
            video.currentTime = stroke.time;

            // Show stroke details
            const panel = document.getElementById('strokeDetailsPanel');
            document.getElementById('strokeDetailType').textContent = stroke.type;
            document.getElementById('strokeDetailScore').textContent = Math.round(stroke.quality);
            document.getElementById('strokeDetailScore').style.color =
                stroke.quality >= 80 ? 'var(--accent-volt, #CDFF00)' :
                stroke.quality >= 60 ? '#FF9800' : '#f44336';
            document.getElementById('strokeDetailTime').textContent = formatVideoTime(stroke.time);
            document.getElementById('strokeDetailVelocity').textContent =
                (stroke.velocity * 100).toFixed(1);

            // Update compare button state
            const isInComparison = comparisonStrokes.some(s => s._index === index);
            document.getElementById('compareBtn').textContent = isInComparison ? 'ADDED' : '+ Compare';

            panel.classList.add('visible');
        }

        function hideStrokeDetails() {
            document.getElementById('strokeDetailsPanel').classList.remove('visible');
        }

        function addToComparison() {
            if (!selectedStroke) return;

            // Check if already in comparison
            const existingIndex = comparisonStrokes.findIndex(s => s._index === selectedStroke._index);
            if (existingIndex >= 0) {
                // Remove from comparison
                comparisonStrokes.splice(existingIndex, 1);
                document.getElementById('compareBtn').textContent = '+ Compare';
            } else if (comparisonStrokes.length < 2) {
                // Add to comparison
                comparisonStrokes.push({ ...selectedStroke });
                document.getElementById('compareBtn').textContent = 'ADDED';
            }

            // Update comparison panel
            if (comparisonStrokes.length === 2) {
                showComparison();
            } else if (comparisonStrokes.length < 2) {
                document.getElementById('comparisonPanel').classList.remove('visible');
            }
        }

        function showComparison() {
            const s1 = comparisonStrokes[0];
            const s2 = comparisonStrokes[1];

            const scoreDiff = s2.quality - s1.quality;
            const velocityDiff = ((s2.velocity - s1.velocity) / s1.velocity * 100).toFixed(0);

            const html = `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                    <!-- Stroke 1 -->
                    <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px;">
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase;">Stroke 1</div>
                        <div style="font-size: 24px; font-weight: bold; color: var(--accent-volt);">${Math.round(s1.quality)}</div>
                        <div style="font-size: 11px; color: white; text-transform: capitalize;">${s1.type}</div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5);">${formatVideoTime(s1.time)}</div>
                    </div>

                    <!-- VS / Diff -->
                    <div style="text-align: center; padding: 8px;">
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5);">DIFF</div>
                        <div style="font-size: 16px; font-weight: bold; color: ${scoreDiff >= 0 ? 'var(--accent-volt)' : '#f44336'};">
                            ${scoreDiff >= 0 ? '+' : ''}${Math.round(scoreDiff)}
                        </div>
                    </div>

                    <!-- Stroke 2 -->
                    <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px;">
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase;">Stroke 2</div>
                        <div style="font-size: 24px; font-weight: bold; color: var(--accent-volt);">${Math.round(s2.quality)}</div>
                        <div style="font-size: 11px; color: white; text-transform: capitalize;">${s2.type}</div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5);">${formatVideoTime(s2.time)}</div>
                    </div>
                </div>

                <div style="margin-top: 12px; font-size: 11px; color: rgba(255,255,255,0.7);">
                    Velocity: ${velocityDiff >= 0 ? '+' : ''}${velocityDiff}%
                </div>
            `;

            document.getElementById('comparisonContent').innerHTML = html;
            document.getElementById('comparisonPanel').classList.add('visible');
        }

        function clearComparison() {
            comparisonStrokes = [];
            document.getElementById('comparisonPanel').classList.remove('visible');
            document.getElementById('compareBtn').textContent = '+ Compare';
        }

        function exportHighlightReel() {
            const strokes = videoAnalyzer.detectedStrokes;
            if (!strokes || strokes.length === 0) {
                showToast('No strokes detected to export');
                return;
            }

            // Get best 5 strokes
            const best5 = [...strokes]
                .sort((a, b) => b.quality - a.quality)
                .slice(0, 5);

            showExportModal('Best 5 Strokes', best5);
        }

        function exportBlooperReel() {
            const strokes = videoAnalyzer.detectedStrokes;
            if (!strokes || strokes.length === 0) {
                showToast('No strokes detected to export');
                return;
            }

            // Get worst 5 strokes (for learning)
            const worst5 = [...strokes]
                .sort((a, b) => a.quality - b.quality)
                .slice(0, 5);

            showExportModal('Strokes to Improve', worst5);
        }

        function showExportModal(title, strokes) {
            const html = `
                <div style="max-height: 60vh; overflow-y: auto;">
                    <div style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 16px;">
                        Click on any stroke to jump to that moment in the video.
                    </div>
                    ${strokes.map((stroke, i) => `
                        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                             onclick="jumpToStroke(${stroke.time})">
                            <div>
                                <div style="font-weight: bold; color: white;">#${i + 1} - ${stroke.type}</div>
                                <div style="font-size: 12px; color: rgba(255,255,255,0.6);">${formatVideoTime(stroke.time)}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 24px; font-weight: bold; color: ${stroke.quality >= 70 ? 'var(--accent-volt)' : stroke.quality >= 50 ? '#FF9800' : '#f44336'};">${Math.round(stroke.quality)}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <button class="btn" onclick="copyStrokeSummary(${JSON.stringify(strokes).replace(/"/g, '&quot;')})" style="width: 100%;">
                        Copy Summary to Clipboard
                    </button>
                </div>
            `;

            // Use export modal for this
            document.getElementById('exportModalContent').innerHTML = `
                <div style="text-align: center; margin-bottom: 16px;">
                    <div style="font-size: 18px; font-weight: bold; color: var(--accent-volt);">${title}</div>
                </div>
                ${html}
            `;
            document.getElementById('exportModal').classList.add('visible');
        }

        function jumpToStroke(time) {
            const video = document.getElementById('analysisVideo');
            video.currentTime = time;
            document.getElementById('exportModal').classList.remove('visible');
        }

        function copyStrokeSummary(strokes) {
            const summary = strokes.map((s, i) =>
                `${i + 1}. ${s.type} at ${formatVideoTime(s.time)} - Score: ${Math.round(s.quality)}`
            ).join('\n');

            navigator.clipboard.writeText(summary).then(() => {
                showToast('Summary copied to clipboard!');
            });
        }

        function toggleVideoPlayback() {
            const video = document.getElementById('analysisVideo');
            const btn = document.getElementById('timelinePlayBtn');

            if (video.paused) {
                video.play();
                btn.textContent = 'PAUSE';
            } else {
                video.pause();
                btn.textContent = 'PLAY';
            }
        }

        function clearAnalysisVideo() {
            const video = document.getElementById('analysisVideo');
            const uploadZone = document.getElementById('videoUploadZone');
            const playerArea = document.getElementById('videoPlayerArea');
            const strokePanel = document.getElementById('strokeDetailsPanel');

            // Reset video
            video.src = '';
            video.pause();

            // Hide player, show upload
            playerArea.classList.remove('active');
            uploadZone.classList.remove('has-video');
            strokePanel.classList.remove('visible');

            // Clear markers
            document.querySelectorAll('.stroke-marker').forEach(m => m.remove());

            // Clean up analyzer
            videoAnalyzer.destroy();

            selectedStroke = null;
        }

        // Timeline click to seek
        function initTimelineInteraction() {
            const track = document.getElementById('timelineTrack');

            track.addEventListener('click', (e) => {
                const video = document.getElementById('analysisVideo');
                if (!video || !video.duration) return;

                const rect = track.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                video.currentTime = percent * video.duration;
            });
        }

        // ========================================
        // Supabase Configuration
        // ========================================
        // IMPORTANT: Replace these with your actual Supabase project values
        const SUPABASE_URL = 'https://apacscxvplslepsdlcmd.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFwYWNzY3h2cGxzbGVwc2RsY21kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA3ODU0NzMsImV4cCI6MjA4NjM2MTQ3M30.T9gUpd1hMTx691xt3RUpvUuN0QWlq5eZu2Hns6T8CPI';

        // ========================================
        // Auth Functions
        // ========================================

        async function handleSignOut() {
            if (!confirm('Sign out? Your data is saved in the cloud.')) return;
            if (typeof supabaseClient !== 'undefined') {
                await supabaseClient.signOut();
            }
            window.location.reload();
        }

        /**
         * Load all user data from Supabase after sign-in.
         */
        async function loadUserData() {
            try {
                // Initialize all storage classes from Supabase
                if (typeof playerProfile !== 'undefined') await playerProfile.init();
                if (typeof improvementTracker !== 'undefined') await improvementTracker.init();
                if (typeof coachNotebook !== 'undefined') await coachNotebook.init();

                // CurriculumEngine needs separate init
                // (instantiated later in TennisAI, but we can pre-load)
            } catch (e) {
                console.error('loadUserData error:', e);
            }
        }

        /**
         * Show the welcome/permission screen with returning user context.
         */
        function showWelcomeScreen() {
            // Update welcome for returning users
            if (typeof playerProfile !== 'undefined' && playerProfile.isLoaded) {
                const profile = playerProfile.profile;
                if (profile && profile.totalSessions > 0) {
                    const subtitle = document.getElementById('heroSubtitle');
                    if (subtitle) subtitle.textContent = 'WELCOME BACK';

                    const sessionCount = document.getElementById('heroSessionCount');
                    if (sessionCount) {
                        sessionCount.textContent = `SESSION #${profile.totalSessions + 1}`;
                        sessionCount.style.display = 'block';
                    }

                    if (profile.totalSessions >= 3) {
                        const featureList = document.getElementById('featureList');
                        if (featureList) {
                            const progressCard = document.createElement('div');
                            progressCard.className = 'feature-card';
                            progressCard.innerHTML = `
                                <div class="feature-icon">
                                    <svg viewBox="0 0 24 24">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                </div>
                                <div class="feature-content">
                                    <div class="feature-title">${profile.totalSessions} Sessions Logged</div>
                                    <div class="feature-desc">Your progress is saved</div>
                                </div>
                            `;
                            featureList.appendChild(progressCard);
                        }
                    }
                }
            }

            transitionScreens('checkingAuthScreen', 'permissionScreen');
        }

        /**
         * Initialize auth flow on page load.
         */
        async function initializeAuth() {
            if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                console.log('Supabase not configured, using localStorage mode');
                // Check if onboarding was already completed locally
                const localOb = localStorage.getItem('ace_onboarding');
                document.getElementById('checkingAuthScreen').style.display = 'none';
                if (localOb) {
                    document.getElementById('permissionScreen').style.display = 'flex';
                    initOnboardingLegacy();
                } else {
                    document.getElementById('obSportScreen').style.display = 'flex';
                }
                return;
            }

            supabaseClient.initialize(SUPABASE_URL, SUPABASE_ANON_KEY);

            // Listen for auth state changes (handles magic link callback from onboarding screen 10)
            supabaseClient.onAuthChange(async (event, session, user) => {
                if (event === 'SIGNED_IN' && user) {
                    // Migrate old localStorage data if exists
                    if (supabaseClient.hasLocalStorageData()) {
                        showToast('Migrating your data...');
                        await supabaseClient.migrateFromLocalStorage();
                        showToast('Data migrated successfully!');
                    }

                    await loadUserData();

                    // Check if sign-in happened during onboarding flow (screen 10)
                    const signupScreen = document.getElementById('obSignupScreen');
                    if (signupScreen && signupScreen.style.display !== 'none') {
                        // Save onboarding data to newly created profile
                        await supabaseClient.updateProfile({
                            sport: onboardingState.sport,
                            ntrpLevel: onboardingState.ntrpLevel,
                            skillLevel: NTRP_TO_SKILL[onboardingState.ntrpLevel] || 'intermediate',
                            improvementGoals: onboardingState.goals,
                            customGoalText: onboardingState.customGoal || null,
                            coachPreference: onboardingState.coachPreference,
                            displayName: onboardingState.displayName,
                            age: onboardingState.age,
                            trialUsed: true,
                        });
                        transitionScreens('obSignupScreen', 'obPricingScreen');
                        return;
                    }

                    // Normal sign-in (not from onboarding)
                    const profile = await supabaseClient.loadProfile();
                    if (profile?.onboardingCompleted) {
                        showWelcomeScreen();
                    } else {
                        // Signed in but never completed onboarding
                        transitionScreens('checkingAuthScreen', 'obSportScreen');
                    }
                }
            });

            // Check for existing session
            const user = await supabaseClient.getExistingSession();
            if (user) {
                await loadUserData();
                const profile = await supabaseClient.loadProfile();

                if (profile?.onboardingCompleted) {
                    // Returning authenticated user — show welcome
                    showWelcomeScreen();
                } else {
                    // Authenticated but never finished onboarding
                    transitionScreens('checkingAuthScreen', 'obSportScreen');
                }
            } else {
                // Not signed in — start fresh onboarding (no auth needed for trial)
                transitionScreens('checkingAuthScreen', 'obSportScreen');
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            initVideoUpload();
            initTimelineInteraction();
            initCalibrationUpload();
            initializeAuth();

            // Free tier limit events
            window.addEventListener('ace:stroke-limit-reached', () => {
                showToast('Free tier: 10 strokes per session. Upgrade to Pro for unlimited!');
            });
            window.addEventListener('ace:session-limit-reached', () => {
                showToast('Free tier: 1 session per month. Upgrade to Pro for unlimited!');
            });
        });

        // Legacy onboarding for when Supabase is not configured
        function initOnboardingLegacy() {
            try {
                // Apply saved onboarding data
                const localOb = JSON.parse(localStorage.getItem('ace_onboarding') || '{}');
                if (localOb.coachPreference) {
                    onboardingState.coachPreference = localOb.coachPreference;
                }

                // Show returning user context on permission screen
                if (typeof playerProfile !== 'undefined' && playerProfile.isLoaded) {
                    const profile = playerProfile.profile;
                    if (profile && profile.totalSessions > 0) {
                        const subtitle = document.getElementById('heroSubtitle');
                        if (subtitle) subtitle.textContent = 'WELCOME BACK';

                        const sessionCount = document.getElementById('heroSessionCount');
                        if (sessionCount) {
                            sessionCount.textContent = `SESSION #${profile.totalSessions + 1}`;
                            sessionCount.style.display = 'block';
                        }
                    }
                }
            } catch (e) {
                console.log('Onboarding init:', e);
            }
        }

        // ========================================
        // Calibration Functions
        // ========================================

        function openCalibrationModal() {
            document.getElementById('calibrationModal').classList.add('visible');
        }

        function closeCalibrationModal() {
            document.getElementById('calibrationModal').classList.remove('visible');
            if (typeof calibrationTool !== 'undefined') {
                calibrationTool.cancel();
            }
        }

        function initCalibrationUpload() {
            const uploadZone = document.getElementById('calibrationUploadZone');
            const fileInput = document.getElementById('calibrationFileInput');

            if (!uploadZone || !fileInput) return;

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.style.borderColor = 'var(--accent-volt, #CDFF00)';
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.style.borderColor = 'rgba(255,255,255,0.3)';
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.style.borderColor = 'rgba(255,255,255,0.3)';
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    startCalibration(file);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    startCalibration(file);
                }
            });
        }

        async function startCalibration(file) {
            const label = document.getElementById('calibrationLabel').value;
            const player = document.getElementById('calibrationPlayer').value || 'unknown';

            // Show progress
            document.getElementById('calibrationUploadZone').style.display = 'none';
            document.getElementById('calibrationProgress').style.display = 'block';
            document.getElementById('calibrationResults').style.display = 'none';

            try {
                // Initialize calibration tool
                await calibrationTool.initialize();

                // Run calibration
                const results = await calibrationTool.calibrateFromVideo(file, {
                    label: label,
                    player: player,
                    onProgress: (progress) => {
                        document.getElementById('calibrationProgressBar').style.width = progress.progress + '%';
                        document.getElementById('calibrationStatus').textContent =
                            `Processing... ${progress.progress.toFixed(0)}%`;
                        document.getElementById('calibrationStrokeCount').textContent =
                            `${progress.strokesDetected} strokes detected`;
                    },
                    onStrokeDetected: (stroke, count) => {
                        console.log(`Calibration stroke #${count}: ${stroke.type}`);
                    }
                });

                // Show results
                displayCalibrationResults(results);

            } catch (error) {
                console.error('Calibration failed:', error);
                document.getElementById('calibrationStatus').textContent = 'Calibration failed: ' + error.message;
            }
        }

        function displayCalibrationResults(results) {
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrationResults').style.display = 'block';

            if (results.error) {
                document.getElementById('calibrationResults').innerHTML = `
                    <div style="color: #f44336; padding: 20px; text-align: center;">
                        ${results.error}
                    </div>
                `;
                return;
            }

            let html = `
                <div class="summary-stats" style="margin-bottom: 20px;">
                    <div class="summary-stat highlight">
                        <div class="summary-stat-value">${results.totalStrokes}</div>
                        <div class="summary-stat-label">Strokes Detected</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${results.label}</div>
                        <div class="summary-stat-label">Skill Level</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${results.player}</div>
                        <div class="summary-stat-label">Player</div>
                    </div>
                </div>
            `;

            // Key metrics
            if (results.metrics) {
                html += `<div class="summary-section"><div class="summary-section-title">Key Metrics</div>`;
                html += `<div style="font-size: 13px; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px;">`;

                const metricsToShow = ['velocity', 'acceleration', 'rotation', 'elbowAngle', 'hipShoulderSeparation'];
                for (const metric of metricsToShow) {
                    if (results.metrics[metric]) {
                        const m = results.metrics[metric];
                        html += `<div style="margin-bottom: 8px;">
                            <strong>${metric}:</strong>
                            avg=${m.avg.toFixed(4)}, range=[${m.min.toFixed(4)} - ${m.max.toFixed(4)}]
                        </div>`;
                    }
                }

                html += `</div></div>`;
            }

            // Recommended thresholds
            if (results.recommendedThresholds && Object.keys(results.recommendedThresholds).length > 0) {
                html += `<div class="summary-section"><div class="summary-section-title">Recommended Thresholds</div>`;
                html += `<div style="font-size: 12px; background: rgba(76,175,80,0.2); padding: 12px; border-radius: 8px; border: 1px solid rgba(76,175,80,0.3);">`;

                for (const [metric, data] of Object.entries(results.recommendedThresholds)) {
                    if (data.recommended) {
                        html += `<div style="margin-bottom: 8px;">
                            <strong>${metric}:</strong><br>
                            <span style="color: rgba(255,255,255,0.6);">Current:</span> ${JSON.stringify(data.current)}<br>
                            <span style="color: var(--accent-volt, #CDFF00);">Recommended:</span> ${JSON.stringify(data.recommended)}
                        </div>`;
                    }
                }

                html += `</div></div>`;
            }

            // Stroke type distribution
            if (results.distributions?.strokeTypes) {
                html += `<div class="summary-section"><div class="summary-section-title">Stroke Distribution</div>`;
                html += `<div style="display: flex; gap: 8px; flex-wrap: wrap;">`;
                for (const [type, count] of Object.entries(results.distributions.strokeTypes)) {
                    html += `<span style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                        ${type}: ${count}
                    </span>`;
                }
                html += `</div></div>`;
            }

            html += `
                <button class="btn" onclick="resetCalibrationUI()" style="width: 100%; margin-top: 16px;">
                    Calibrate Another Video
                </button>
            `;

            document.getElementById('calibrationResults').innerHTML = html;

            // Show threshold update section after successful calibration
            showThresholdUpdateSection();
        }

        function resetCalibrationUI() {
            document.getElementById('calibrationUploadZone').style.display = 'block';
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrationResults').style.display = 'none';
            document.getElementById('calibrationProgressBar').style.width = '0%';
            document.getElementById('calibrationFileInput').value = '';
            // Reset threshold update section
            document.getElementById('thresholdUpdateSection').style.display = 'none';
            document.getElementById('thresholdApplyStatus').textContent = '';
        }

        function showCalibrationStats() {
            if (typeof calibrationTool === 'undefined') return;

            const stats = calibrationTool.getAggregateStats();
            calibrationTool.printThresholdComparison();

            if (stats.error) {
                showToast(stats.error);
                return;
            }

            showToast(`Calibration: ${stats.totalRuns} runs, ${stats.totalStrokes} strokes. See console for details.`);
            console.log('Calibration Stats:', stats);
        }

        function exportCalibrationData() {
            if (typeof calibrationTool !== 'undefined') {
                calibrationTool.exportCalibrationData();
            }
        }

        function applyThresholdsToApp() {
            const statusEl = document.getElementById('thresholdApplyStatus');

            if (typeof thresholdUpdater === 'undefined') {
                statusEl.textContent = 'ERROR: ThresholdUpdater not loaded';
                statusEl.style.color = '#f44336';
                return;
            }

            const result = thresholdUpdater.applyToRunningApp();

            if (result.success) {
                statusEl.innerHTML = `Applied ${result.updatedModules.length} module updates!<br>` +
                    result.updatedModules.map(m => `• ${m}`).join('<br>');
                statusEl.style.color = 'var(--accent-volt, #CDFF00)';
            } else {
                statusEl.textContent = `FAILED: ${result.error}`;
                statusEl.style.color = '#f44336';
            }
        }

        function exportThresholdUpdates() {
            if (typeof thresholdUpdater === 'undefined') {
                showToast('ThresholdUpdater not loaded');
                return;
            }

            thresholdUpdater.exportUpdates();
        }

        function showThresholdUpdateSection() {
            const section = document.getElementById('thresholdUpdateSection');
            if (section && calibrationTool && calibrationTool.calibrationRuns.length > 0) {
                section.style.display = 'block';
            }
        }

        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            if (minutes === 0) return `${remainingSeconds}s`;
            return `${minutes}m ${remainingSeconds}s`;
        }

        // Stroke quality flash function
        function flashStrokeQuality(qualityScore) {
            const overlay = document.getElementById('strokeFlashOverlay');

            // Remove existing classes
            overlay.classList.remove('flash', 'great', 'good', 'needs-work');

            // Force reflow to restart animation
            void overlay.offsetWidth;

            // Add appropriate quality class
            if (qualityScore >= 80) {
                overlay.classList.add('great');
            } else if (qualityScore >= 60) {
                overlay.classList.add('good');
            } else {
                overlay.classList.add('needs-work');
            }

            // Trigger flash animation
            overlay.classList.add('flash');
        }

        // ============================================
        // REPLAY FUNCTIONS
        // ============================================
        let replayBtnTimeout = null;

        function showReplayButton(index) {
            const btn = document.getElementById('replayBtn');
            if (!btn) return;
            btn.dataset.index = index;
            btn.classList.add('visible');
            if (replayBtnTimeout) clearTimeout(replayBtnTimeout);
            replayBtnTimeout = setTimeout(() => {
                btn.classList.remove('visible');
            }, 5000);
        }

        function openReplay(index) {
            const overlay = document.getElementById('replayOverlay');
            const canvas = document.getElementById('replayCanvas');
            if (!overlay || !canvas || !window.tennisAI?.replayManager) return;

            const idx = parseInt(index, 10);
            const mgr = window.tennisAI.replayManager;
            if (idx < 0 || idx >= mgr.getReplayCount()) return;

            // Match canvas to main canvas dimensions
            const mainCanvas = document.getElementById('canvasElement');
            if (mainCanvas) {
                canvas.width = mainCanvas.width;
                canvas.height = mainCanvas.height;
            }

            overlay.classList.add('visible');
            const ctx = canvas.getContext('2d');

            const replay = mgr.getReplay(idx);
            mgr.startPlayback(idx, canvas, ctx, {
                speed: 0.5,
                loop: true,
                faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand,
                skillLevel: replay?.strokeData?.skillLevel || 'intermediate'
            });

            // Hide the replay button
            const btn = document.getElementById('replayBtn');
            if (btn) btn.classList.remove('visible');

            // Show/hide Coach's Eye button based on faults
            const hasFaults = replay?.strokeData?.biomechanicalFaults?.length > 0;
            const eyeBtn = document.getElementById('coachesEyeBtn');
            if (eyeBtn) {
                eyeBtn.style.display = hasFaults ? '' : 'none';
                eyeBtn.classList.remove('active');
                mgr.ghostEnabled = false;
            }

            // Update speed button states
            updateSpeedButtons(0.5);
            document.getElementById('replayPlayPauseBtn').textContent = 'PAUSE';
        }

        function closeReplay() {
            const overlay = document.getElementById('replayOverlay');
            if (overlay) overlay.classList.remove('visible');
            if (window.tennisAI?.replayManager) {
                window.tennisAI.replayManager.stopPlayback();
                window.tennisAI.replayManager.ghostEnabled = false;
            }
            const eyeBtn = document.getElementById('coachesEyeBtn');
            if (eyeBtn) eyeBtn.classList.remove('active');
        }

        function toggleCoachesEye() {
            const mgr = window.tennisAI?.replayManager;
            if (!mgr) return;
            mgr.ghostEnabled = !mgr.ghostEnabled;
            document.getElementById('coachesEyeBtn')?.classList.toggle('active', mgr.ghostEnabled);
            // Redraw current frame if paused
            if (mgr.isPaused && mgr.currentReplayIndex >= 0) {
                const canvas = document.getElementById('replayCanvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    const replay = mgr.getReplay(mgr.currentReplayIndex);
                    if (replay) {
                        mgr.drawReplayFrame(ctx, canvas, replay, mgr.currentFrameIndex, {
                            faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                            dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand,
                            skillLevel: replay.strokeData?.skillLevel || 'intermediate'
                        });
                    }
                }
            }
        }

        function toggleReplayPlayback() {
            if (!window.tennisAI?.replayManager) return;
            const mgr = window.tennisAI.replayManager;
            const paused = mgr.pausePlayback();
            document.getElementById('replayPlayPauseBtn').textContent = paused ? 'PLAY' : 'PAUSE';

            // If paused, redraw current frame
            if (paused) {
                const canvas = document.getElementById('replayCanvas');
                const ctx = canvas?.getContext('2d');
                const replay = mgr.getReplay(mgr.currentReplayIndex);
                if (replay && ctx) {
                    mgr.drawReplayFrame(ctx, canvas, replay, mgr.currentFrameIndex, {
                        faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                        dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand
                    });
                }
            }
        }

        function setReplaySpeed(speed) {
            if (!window.tennisAI?.replayManager) return;
            window.tennisAI.replayManager.setPlaybackSpeed(speed);
            updateSpeedButtons(speed);
        }

        function updateSpeedButtons(activeSpeed) {
            document.querySelectorAll('.replay-ctrl-btn[data-speed]').forEach(btn => {
                const s = parseFloat(btn.dataset.speed);
                btn.classList.toggle('active', s === activeSpeed);
            });
        }

        function replayStepFrame(delta) {
            if (!window.tennisAI?.replayManager) return;
            const mgr = window.tennisAI.replayManager;
            const replay = mgr.getReplay(mgr.currentReplayIndex);
            if (!replay) return;

            // Pause if playing
            if (!mgr.isPaused) {
                mgr.pausePlayback();
                document.getElementById('replayPlayPauseBtn').textContent = 'PLAY';
            }

            const newIdx = Math.max(0, Math.min(mgr.currentFrameIndex + delta, replay.frames.length - 1));
            mgr.currentFrameIndex = newIdx;

            const canvas = document.getElementById('replayCanvas');
            const ctx = canvas?.getContext('2d');
            if (ctx) {
                mgr.drawReplayFrame(ctx, canvas, replay, newIdx, {
                    faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                    dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand
                });
            }
        }

        // Build stroke review grid for session summary
        function buildStrokeReviewGrid(container) {
            if (!window.tennisAI?.replayManager) return;
            const mgr = window.tennisAI.replayManager;
            if (mgr.getReplayCount() === 0) return;

            const section = document.createElement('div');
            section.style.marginTop = '16px';

            const title = document.createElement('div');
            title.textContent = 'Review Strokes';
            title.style.cssText = 'font-size: 14px; font-weight: 700; color: #F5F5F5; margin-bottom: 8px;';
            section.appendChild(title);

            const grid = document.createElement('div');
            grid.className = 'replay-grid';

            const replays = mgr.getAllReplays();
            replays.forEach((replay, idx) => {
                const q = replay.strokeData.quality;
                const bg = q >= 80 ? 'rgba(50, 215, 75, 0.2)'
                    : q >= 60 ? 'rgba(205, 255, 0, 0.2)'
                    : 'rgba(255, 59, 48, 0.2)';
                const color = q >= 80 ? '#32D74B' : q >= 60 ? '#CDFF00' : '#FF3B30';

                const item = document.createElement('div');
                item.className = 'replay-grid-item';
                item.style.background = bg;
                item.style.color = color;
                item.style.border = `1px solid ${color}33`;
                item.textContent = q;
                item.title = `${replay.strokeData.type} - ${q}/100`;
                item.onclick = () => openReplay(idx);
                grid.appendChild(item);
            });

            section.appendChild(grid);
            container.appendChild(section);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                // Close replay if open, otherwise toggle analysis
                const overlay = document.getElementById('replayOverlay');
                if (overlay?.classList.contains('visible')) {
                    toggleReplayPlayback();
                } else {
                    toggleAnalysis();
                }
            } else if (event.code === 'KeyR' && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                resetSession();
            } else if (event.code === 'Escape') {
                closeReplay();
            }
        });
    </script>
</body>
</html>