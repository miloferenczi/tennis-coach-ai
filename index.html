<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACE - AI Coach</title>
    <meta name="description" content="AI-powered athletic coaching with real-time pose analysis">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#0A0A0A">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ACE">

    <!-- Premium Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Link to manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
        
        <!-- Signal processing filters (must load before physics/analysis) -->
    <script src="js/signal-filters.js"></script>
    <script src="js/kalman-velocity-estimator.js"></script>

        <!-- Add these new scripts in order -->
    <script src="js/physics-analyzer.js"></script>
    <script src="js/stroke-classifier.js"></script>
    <script src="js/professional-references.js"></script>
    <script src="js/coaching-orchestrator.js"></script>
    <script src="js/phase-detector.js"></script>
    <script src="js/kinetic-chain-analyzer.js"></script>
    <script src="js/motion-sequence-analyzer.js"></script>
    <script src="js/biomechanical-checkpoints.js"></script>
    <script src="js/diagnostic-logger.js"></script>
    <script src="js/calibration-tool.js"></script>
    <script src="js/threshold-updater.js"></script>

    <!-- Sport Configuration -->
    <script src="js/sport-loader.js"></script>

    <!-- Ball/Court Tracking -->
    <script src="js/ball-tracking-client.js"></script>

    <!-- Application Scripts -->
    <script src="js/session-storage.js"></script>
    <script src="js/improvement-tracker.js"></script>
    <script src="js/player-profile.js"></script>
    <script src="js/ghost-overlay.js"></script>
    <script src="js/stroke-replay.js"></script>
    <script src="js/challenge-mode.js"></script>
    <script src="js/drill-mode.js"></script>
    <script src="js/coach-notebook.js"></script>
    <script src="js/footwork-analyzer.js"></script>
    <script src="js/serve-analyzer.js"></script>
    <script src="js/enhanced-tennis-analyzer.js"></script>
    <script src="js/gpt-voice-coach.js"></script>
    <script src="js/video-analyzer.js"></script>

    <style>
        /* ============================================
           PREMIUM DESIGN SYSTEM - Nike/Athletic Aesthetic
           ============================================ */

        :root {
            /* Color System */
            --bg-primary: #0A0A0A;
            --bg-secondary: #141414;
            --bg-surface: rgba(255, 255, 255, 0.06);
            --accent-volt: #CDFF00;
            --text-primary: #F5F5F5;
            --text-muted: #8A8A8A;
            --text-subtle: #666666;
            --danger: #FF3B30;
            --success: #32D74B;
            --warning: #FF9500;
            --border-subtle: rgba(255, 255, 255, 0.08);

            /* Glass Effect */
            --glass-bg: rgba(10, 10, 10, 0.75);
            --glass-blur: blur(20px);

            /* Typography */
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;

            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --radius-full: 9999px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            -webkit-font-smoothing: antialiased;
        }

        /* Noise/Grain Texture Overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 10000;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .camera-container {
            position: relative;
            flex: 1;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
        }

        #canvasElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* ============================================
           ONBOARDING SCREENS - Nike/W+K Premium
           ============================================ */

        /* System font stack - SF Pro Display */
        .onboarding-font {
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0A0A0A;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 24px;
            z-index: 1001;
            opacity: 1;
            transform: translateY(0);
            transition: opacity 400ms ease-out, transform 400ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
        }

        .screen.exiting {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        .screen.entering {
            opacity: 0;
            transform: translateY(20px);
        }

        .screen.entering.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Onboarding content container */
        .onboarding-content {
            width: 100%;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            justify-content: center;
        }

        /* Step Indicator - Fixed at bottom */
        .step-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        .step-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 300ms ease-out;
        }

        .step-dot.active {
            background: #CDFF00;
            border-color: #CDFF00;
        }

        /* Step 1: Welcome Screen */
        .hero-title {
            font-size: 72px;
            font-weight: 900;
            color: #F5F5F5;
            letter-spacing: -0.03em;
            line-height: 1;
            margin-bottom: 12px;
        }

        .hero-title .accent {
            color: #CDFF00;
        }

        .hero-subtitle {
            font-size: 12px;
            font-weight: 500;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 48px;
        }

        .hero-session-count {
            font-size: 11px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-top: 4px;
        }

        /* Feature Cards */
        .feature-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            margin-bottom: 32px;
        }

        .feature-card {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 18px 20px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 16px;
            opacity: 0;
            transform: translateY(12px);
            animation: featureCardIn 400ms ease-out forwards;
        }

        .feature-card:nth-child(1) { animation-delay: 0ms; }
        .feature-card:nth-child(2) { animation-delay: 80ms; }
        .feature-card:nth-child(3) { animation-delay: 160ms; }
        .feature-card:nth-child(4) { animation-delay: 240ms; }

        @keyframes featureCardIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .feature-icon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .feature-icon svg {
            width: 24px;
            height: 24px;
            stroke: #CDFF00;
            fill: none;
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .feature-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .feature-title {
            font-size: 15px;
            font-weight: 600;
            color: #F5F5F5;
        }

        .feature-desc {
            font-size: 12px;
            font-weight: 400;
            color: #444;
        }

        /* Primary CTA Button */
        .btn-primary {
            width: 100%;
            height: 56px;
            background: #CDFF00;
            color: #0A0A0A;
            border: none;
            border-radius: 28px;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            cursor: pointer;
            transition: transform 150ms ease-out, background 150ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            /* Haptic trigger point */
        }

        .btn-primary:active {
            transform: scale(0.97);
            background: #B8E600;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Step 2: Voice Coach Screen */
        .voice-header {
            width: 100%;
            text-align: left;
            margin-bottom: 32px;
        }

        .voice-title {
            font-size: 56px;
            font-weight: 900;
            color: #F5F5F5;
            letter-spacing: -0.02em;
            line-height: 0.95;
        }

        .voice-label {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            color: #0A0A0A;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            background: rgba(255, 255, 255, 0.12);
            padding: 6px 10px;
            border-radius: 4px;
            margin-top: 16px;
        }

        .voice-tagline {
            font-size: 14px;
            font-weight: 400;
            color: #555;
            margin-top: 12px;
            text-align: left;
        }

        /* API Input */
        .api-input-group {
            width: 100%;
            margin-bottom: 24px;
        }

        .api-label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            margin-bottom: 8px;
            text-align: left;
        }

        .api-input-wrapper {
            position: relative;
            width: 100%;
        }

        .api-input {
            width: 100%;
            height: 52px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 0 16px;
            font-size: 14px;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            color: #F5F5F5;
            transition: border-color 200ms ease-out, background 200ms ease-out;
        }

        .api-input:focus {
            outline: none;
            border-color: rgba(205, 255, 0, 0.4);
            background: rgba(255, 255, 255, 0.08);
        }

        .api-input::placeholder {
            color: #333;
        }

        .api-input.validated {
            padding-right: 44px;
        }

        .api-input.flash {
            animation: inputFlash 200ms ease-out;
        }

        @keyframes inputFlash {
            0%, 100% { border-color: rgba(205, 255, 0, 0.4); }
            50% { border-color: #CDFF00; }
        }

        .api-checkmark {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            display: none;
        }

        .api-checkmark.visible {
            display: block;
        }

        .api-checkmark svg {
            width: 16px;
            height: 16px;
            stroke: #CDFF00;
            fill: none;
            stroke-width: 2;
        }

        .api-link {
            display: inline-block;
            font-size: 12px;
            font-weight: 500;
            color: #555;
            text-decoration: none;
            margin-top: 12px;
            transition: color 200ms ease-out;
        }

        .api-link:hover {
            color: #CDFF00;
        }

        /* Skip Button */
        .btn-skip {
            background: transparent;
            border: none;
            font-size: 13px;
            font-weight: 500;
            color: #444;
            cursor: pointer;
            padding: 16px 24px;
            margin-top: 24px;
            transition: color 200ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
            min-height: 44px;
            /* Intentionally de-emphasized */
        }

        .btn-skip:hover {
            color: #666;
        }

        /* Step 3: Loading Screen */
        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }

        .loading-logo {
            width: 64px;
            height: 64px;
            margin-bottom: 20px;
            animation: logoScale 2s ease-in-out infinite;
        }

        .loading-logo svg {
            width: 100%;
            height: 100%;
        }

        @keyframes logoScale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.04); }
        }

        .loading-phase {
            font-size: 14px;
            font-weight: 700;
            color: #F5F5F5;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 8px;
            min-height: 20px;
            transition: opacity 200ms ease-out;
        }

        .loading-phase.crossfade {
            opacity: 0;
        }

        .loading-detail {
            font-size: 12px;
            font-weight: 400;
            color: #444;
            margin-bottom: 24px;
            min-height: 16px;
            transition: opacity 200ms ease-out;
        }

        .loading-detail.crossfade {
            opacity: 0;
        }

        .loading-track {
            width: 100%;
            max-width: 360px;
            height: 3px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-fill {
            height: 100%;
            background: #CDFF00;
            width: 0%;
            transition: width 400ms ease-out;
            border-radius: 2px;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            background: rgba(255, 59, 48, 0.15);
            color: #FF3B30;
            font-size: 13px;
            font-weight: 500;
            padding: 12px 20px;
            border-radius: 12px;
            z-index: 9999;
            opacity: 0;
            transition: transform 300ms ease-out, opacity 300ms ease-out;
            font-family: -apple-system, 'SF Pro Display', BlinkMacSystemFont, system-ui, sans-serif;
        }

        .toast.visible {
            transform: translateX(-50%) translateY(20px);
            opacity: 1;
        }

        .toast.hiding {
            transform: translateX(-50%) translateY(-20px);
            opacity: 0;
        }

        /* ============================================
           BUTTONS
           ============================================ */
        .btn {
            background: var(--accent-volt);
            color: var(--bg-primary);
            border: none;
            padding: 16px 40px;
            border-radius: var(--radius-full);
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: transform 0.15s ease, opacity 0.15s ease;
            font-family: var(--font-family);
        }

        .btn:hover {
            opacity: 0.9;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn-secondary {
            background: var(--bg-surface);
            color: var(--text-primary);
            border: 1px solid var(--border-subtle);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-muted);
            padding: 12px 24px;
        }

        .btn-ghost:hover {
            color: var(--text-primary);
        }

        /* ============================================
           INPUTS
           ============================================ */
        input[type="password"],
        input[type="text"] {
            width: 100%;
            max-width: 360px;
            padding: 16px 20px;
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            background: var(--bg-surface);
            color: var(--text-primary);
            font-size: 15px;
            font-family: var(--font-family);
            margin: 20px 0;
            backdrop-filter: var(--glass-blur);
            transition: border-color 0.2s ease;
        }

        input[type="password"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-volt);
        }

        input[type="password"]::placeholder,
        input[type="text"]::placeholder {
            color: var(--text-subtle);
        }

        /* ============================================
           LOADING SCREEN
           ============================================ */
        .loading-screen {
            z-index: 1000;
        }

        .loading-text {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        .loading-progress {
            width: 200px;
            height: 2px;
            background: var(--bg-surface);
            border-radius: var(--radius-full);
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: var(--accent-volt);
            border-radius: var(--radius-full);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* ============================================
           STATUS BAR (Top HUD)
           ============================================ */
        .status-bar {
            position: absolute;
            top: var(--space-md);
            left: var(--space-md);
            right: var(--space-md);
            display: flex;
            justify-content: space-between;
            z-index: 100;
            background: var(--glass-bg);
            padding: 16px 20px;
            border-radius: var(--radius-lg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
        }

        .status-item {
            text-align: center;
            flex: 1;
        }

        .status-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-subtle);
            margin-bottom: 6px;
        }

        .status-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
        }

        .status-value.muted {
            color: var(--text-subtle);
        }

        .ai-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-subtle);
        }

        .status-dot.ready {
            background: var(--warning);
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: var(--accent-volt);
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 12px rgba(205, 255, 0, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* ============================================
           ANALYSIS CARD
           ============================================ */
        .analysis-card {
            position: absolute;
            top: 100px;
            right: var(--space-md);
            background: var(--glass-bg);
            border-radius: var(--radius-lg);
            padding: 20px;
            min-width: 180px;
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            transform: scale(0) translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            max-height: 320px;
            overflow-y: auto;
            z-index: 100;
        }

        .analysis-card.visible {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .stroke-type {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-volt);
            margin-bottom: 8px;
            text-align: center;
        }

        .technique-score {
            font-size: 48px;
            font-weight: 800;
            text-align: center;
            margin-bottom: 4px;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .score-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-subtle);
            text-align: center;
            margin-bottom: 16px;
        }

        .advanced-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            padding-top: 16px;
            border-top: 1px solid var(--border-subtle);
        }

        .metric-item {
            text-align: center;
        }

        .metric-label {
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-subtle);
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* ============================================
           COACHING PANEL
           ============================================ */
        .coaching-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--glass-bg);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border-top: 1px solid var(--border-subtle);
            max-height: 30vh;
            overflow-y: auto;
            z-index: 100;
        }

        .coaching-drag-handle {
            width: 36px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-full);
            margin: 0 auto 16px;
        }

        .coaching-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .coaching-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-volt);
        }

        .coaching-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-volt);
            animation: pulse 1.5s infinite;
        }

        .coaching-text {
            font-size: 15px;
            line-height: 1.5;
            color: var(--text-primary);
            font-weight: 400;
        }

        .phase-indicator {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
        }

        .phase-step {
            flex: 1;
            text-align: center;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 0.05em;
            padding: 4px 2px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.06);
            color: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .phase-step.active {
            background: rgba(205, 255, 0, 0.2);
            color: var(--accent-volt);
            box-shadow: 0 0 8px rgba(205, 255, 0, 0.15);
        }

        .phase-step.completed {
            background: rgba(205, 255, 0, 0.08);
            color: rgba(205, 255, 0, 0.5);
        }

        .fault-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .fault-chip {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(255, 59, 48, 0.15);
            color: #FF3B30;
            border: 1px solid rgba(255, 59, 48, 0.3);
        }

        .fault-chip.low-priority {
            background: rgba(255, 159, 10, 0.15);
            color: #FF9F0A;
            border-color: rgba(255, 159, 10, 0.3);
        }

        .strength-chip {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(48, 209, 88, 0.15);
            color: #30D158;
            border: 1px solid rgba(48, 209, 88, 0.3);
        }

        /* ============================================
           CONTROLS
           ============================================ */
        .controls {
            position: absolute;
            bottom: calc(160px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 24px;
            z-index: 100;
        }

        .control-btn {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            box-shadow: 0 0 0 2px var(--accent-volt);
        }

        .control-btn-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-top: 8px;
            position: absolute;
            bottom: -24px;
            white-space: nowrap;
        }

        .play-btn.recording {
            box-shadow: 0 0 0 2px var(--accent-volt), 0 0 20px rgba(205, 255, 0, 0.3);
        }

        /* Icon styling */
        .control-icon {
            font-size: 22px;
            line-height: 1;
        }

        /* ============================================
           MODE SWITCHER (Tab Bar)
           ============================================ */
        .mode-switcher {
            position: absolute;
            top: calc(90px + var(--space-md));
            left: var(--space-md);
            display: flex;
            background: var(--glass-bg);
            border-radius: var(--radius-full);
            padding: 4px;
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            z-index: 100;
        }

        .mode-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            padding: 8px 16px;
            border-radius: var(--radius-full);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-family);
        }

        .mode-btn.active {
            background: var(--accent-volt);
            color: var(--bg-primary);
        }

        .mode-btn:not(.active):hover {
            color: var(--text-primary);
        }

        /* ============================================
           ERROR MESSAGE
           ============================================ */
        .error-message {
            background: var(--danger);
            color: white;
            padding: 16px 20px;
            border-radius: var(--radius-md);
            margin: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
        }

        /* ============================================
           STROKE FLASH OVERLAY
           ============================================ */
        .stroke-flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0;
        }

        .stroke-flash-overlay.flash {
            animation: borderFlash 0.5s ease-out forwards;
        }

        .stroke-flash-overlay.great {
            box-shadow: inset 0 0 120px 40px rgba(205, 255, 0, 0.6);
        }

        .stroke-flash-overlay.good {
            box-shadow: inset 0 0 120px 40px rgba(255, 149, 0, 0.5);
        }

        .stroke-flash-overlay.needs-work {
            box-shadow: inset 0 0 120px 40px rgba(255, 59, 48, 0.5);
        }

        @keyframes borderFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* ============================================
           GHOST OVERLAY STYLES
           ============================================ */
        .ghost-similarity {
            position: fixed;
            top: 140px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-lg);
            padding: 12px 16px;
            text-align: center;
            z-index: 100;
        }

        .ghost-similarity-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .ghost-similarity-value {
            font-size: 28px;
            font-weight: 800;
            color: var(--accent-volt);
        }

        .ghost-similarity-value.low {
            color: #f44336;
        }

        .ghost-similarity-value.medium {
            color: #FF9800;
        }

        .ghost-similarity-value.high {
            color: var(--accent-volt);
        }

        #ghostBtn.active {
            background: var(--accent-volt);
            color: #0A0A0A;
        }

        #ghostBtn.active .control-icon {
            filter: none;
        }

        /* ============================================
           PRO COMPARISON STYLES
           ============================================ */
        .pro-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pro-card:hover {
            background: rgba(205, 255, 0, 0.1);
            border-color: var(--accent-volt);
        }

        .pro-card.selected {
            background: rgba(205, 255, 0, 0.15);
            border-color: var(--accent-volt);
        }

        .pro-name {
            font-weight: 700;
            color: white;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .pro-style {
            font-size: 11px;
            color: var(--text-muted);
        }

        .comparison-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .comparison-metric:last-child {
            border-bottom: none;
        }

        .comparison-metric-label {
            color: var(--text-muted);
            font-size: 13px;
        }

        .comparison-metric-values {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .comparison-you {
            color: white;
            font-weight: 600;
        }

        .comparison-vs {
            color: var(--text-muted);
            font-size: 11px;
        }

        .comparison-pro {
            color: var(--accent-volt);
            font-weight: 600;
        }

        .comparison-diff {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .comparison-diff.positive {
            background: rgba(205, 255, 0, 0.2);
            color: var(--accent-volt);
        }

        .comparison-diff.negative {
            background: rgba(255, 59, 48, 0.2);
            color: #f44336;
        }

        /* ============================================
           CHALLENGE MODE STYLES
           ============================================ */
        .active-challenge-bar {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-full);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 100;
        }

        .challenge-info {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .challenge-icon {
            font-size: 16px;
        }

        .challenge-name {
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .challenge-progress-bar {
            width: 80px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .challenge-progress-fill {
            height: 100%;
            background: var(--accent-volt);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .challenge-progress-text {
            font-size: 11px;
            color: var(--text-muted);
            min-width: 30px;
        }

        .challenge-complete-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000;
            animation: fadeIn 0.3s ease;
        }

        .challenge-complete-content {
            text-align: center;
            padding: 40px;
        }

        .challenge-complete-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounceIn 0.5s ease;
        }

        .challenge-complete-title {
            font-size: 28px;
            font-weight: 800;
            color: var(--accent-volt);
            margin-bottom: 12px;
        }

        .challenge-complete-name {
            font-size: 18px;
            color: white;
            margin-bottom: 8px;
        }

        .challenge-complete-reward {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* ============================================
           DRILL MODE STYLES
           ============================================ */
        .drill-hud {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 90;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 320px;
        }

        .drill-hud-header {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-full);
            padding: 6px 16px;
            pointer-events: auto;
        }

        .drill-hud-name {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .drill-hud-stop {
            font-size: 10px;
            font-weight: 700;
            color: var(--danger);
            background: rgba(255, 59, 48, 0.15);
            border: 1px solid rgba(255, 59, 48, 0.3);
            border-radius: 4px;
            padding: 3px 8px;
            cursor: pointer;
            letter-spacing: 0.5px;
        }

        .drill-hud-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .drill-hud-progress-bar {
            flex: 1;
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .drill-hud-progress-fill {
            height: 100%;
            background: var(--accent-volt);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .drill-hud-progress-text {
            font-size: 11px;
            color: var(--text-muted);
            min-width: 30px;
            text-align: right;
        }

        .drill-hud-metric {
            text-align: center;
            animation: drillMetricPop 0.3s ease;
        }

        .drill-hud-metric-value {
            font-size: 56px;
            font-weight: 900;
            line-height: 1;
            color: var(--text-primary);
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            transition: color 0.2s ease;
        }

        .drill-hud-metric-value.at-target {
            color: var(--success);
            text-shadow: 0 0 20px rgba(50, 215, 75, 0.4);
        }

        .drill-hud-metric-value.close {
            color: var(--warning);
            text-shadow: 0 0 20px rgba(255, 149, 0, 0.4);
        }

        .drill-hud-metric-value.far {
            color: var(--danger);
            text-shadow: 0 0 20px rgba(255, 59, 48, 0.4);
        }

        .drill-hud-metric-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .drill-hud-metric-target {
            font-size: 10px;
            color: var(--text-subtle);
        }

        @keyframes drillMetricPop {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .drill-hud-reps {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .drill-rep-dot {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: 700;
            color: transparent;
            transition: all 0.3s ease;
        }

        .drill-rep-dot.hit {
            background: rgba(50, 215, 75, 0.25);
            border-color: var(--success);
            color: var(--success);
        }

        .drill-rep-dot.close {
            background: rgba(255, 149, 0, 0.2);
            border-color: var(--warning);
            color: var(--warning);
        }

        .drill-rep-dot.miss {
            background: rgba(255, 59, 48, 0.2);
            border-color: var(--danger);
            color: var(--danger);
        }

        .drill-hud-wrong-type {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 59, 48, 0.9);
            color: white;
            font-size: 16px;
            font-weight: 700;
            padding: 12px 24px;
            border-radius: var(--radius-md);
            z-index: 95;
            animation: drillWrongTypeFade 1.5s ease forwards;
            pointer-events: none;
        }

        @keyframes drillWrongTypeFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(0.9); }
        }

        .drill-summary-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20000;
            animation: fadeIn 0.3s ease;
        }

        .drill-summary-content {
            text-align: center;
            padding: 32px;
            max-width: 400px;
            width: 100%;
        }

        .drill-summary-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .drill-summary-name {
            font-size: 24px;
            font-weight: 800;
            color: var(--accent-volt);
            margin-bottom: 24px;
        }

        .drill-summary-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 24px;
        }

        .drill-stat {
            text-align: center;
        }

        .drill-stat-value {
            font-size: 28px;
            font-weight: 800;
            color: var(--text-primary);
        }

        .drill-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .drill-summary-chart {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 4px;
            height: 100px;
            margin-bottom: 24px;
            padding: 0 8px;
        }

        .drill-chart-bar {
            flex: 1;
            max-width: 28px;
            border-radius: 3px 3px 0 0;
            position: relative;
            transition: height 0.3s ease;
        }

        .drill-chart-bar.hit {
            background: var(--success);
        }

        .drill-chart-bar.close {
            background: var(--warning);
        }

        .drill-chart-bar.miss {
            background: var(--danger);
        }

        .drill-chart-target-line {
            position: absolute;
            left: -8px;
            right: -8px;
            height: 2px;
            background: var(--accent-volt);
            opacity: 0.5;
        }

        .drill-summary-trend {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 20px;
        }

        .drill-summary-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .drill-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .drill-card:hover {
            border-color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.05);
        }

        .drill-card.recommended {
            border-color: rgba(205, 255, 0, 0.3);
            background: rgba(205, 255, 0, 0.05);
        }

        .drill-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .drill-card-name {
            font-weight: 700;
            color: white;
            font-size: 15px;
        }

        .drill-card-reps {
            font-size: 11px;
            color: var(--text-muted);
        }

        .drill-card-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .drill-card-meta {
            display: flex;
            gap: 12px;
            font-size: 11px;
        }

        .drill-card-stroke {
            color: var(--accent-volt);
            font-weight: 600;
        }

        .drill-card-target {
            color: var(--text-subtle);
        }

        .drill-card-badge {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: inline-block;
        }

        .challenge-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .challenge-card:hover {
            border-color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.05);
        }

        .challenge-card.completed {
            opacity: 0.6;
            border-color: var(--accent-volt);
        }

        .challenge-card.active {
            border-color: var(--accent-volt);
            background: rgba(205, 255, 0, 0.1);
        }

        .challenge-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .challenge-card-icon {
            font-size: 24px;
        }

        .challenge-card-title {
            font-weight: 700;
            color: white;
            font-size: 15px;
        }

        .challenge-card-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .challenge-card-difficulty {
            font-size: 10px;
            text-transform: uppercase;
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .challenge-card-difficulty.easy {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .challenge-card-difficulty.medium {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }

        .challenge-card-difficulty.hard {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .challenge-card-badge {
            font-size: 11px;
            color: var(--accent-volt);
            margin-left: auto;
        }

        /* ============================================
           MODAL STYLES
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius-xl);
            padding: 28px;
            max-width: 480px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            transform: scale(0.95) translateY(20px);
            transition: transform 0.3s ease;
            border: 1px solid var(--border-subtle);
        }

        .modal-overlay.visible .modal {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            color: var(--text-primary);
        }

        .modal-close {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            color: var(--text-muted);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .summary-stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .summary-stat.highlight {
            grid-column: span 2;
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .summary-stat-value {
            font-size: 28px;
            font-weight: bold;
            color: white;
            margin-bottom: 4px;
        }

        .summary-stat-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
        }

        .summary-section {
            margin-bottom: 20px;
        }

        .summary-section-title {
            font-size: 14px;
            font-weight: bold;
            color: var(--accent-volt, #CDFF00);
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .weakness-tag {
            display: inline-block;
            background: rgba(255, 152, 0, 0.3);
            color: #FFC107;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            margin: 4px 4px 4px 0;
        }

        .drill-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 12px;
            border-left: 4px solid var(--accent-volt, #CDFF00);
        }

        .drill-name {
            font-size: 16px;
            font-weight: bold;
            color: white;
            margin-bottom: 8px;
        }

        .drill-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .drill-duration {
            font-size: 12px;
            color: var(--accent-volt, #CDFF00);
        }

        .improvement-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: bold;
        }

        .improvement-badge.positive {
            background: rgba(76, 175, 80, 0.3);
            color: var(--accent-volt, #CDFF00);
        }

        .improvement-badge.negative {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        .improvement-badge.neutral {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        /* Mode Switcher */
        .mode-switcher {
            position: absolute;
            top: 80px;
            left: 20px;
            display: flex;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 25px;
            padding: 4px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            font-weight: 500;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: var(--accent-volt, #CDFF00);
            color: #0A0A0A;
        }

        .mode-btn:hover:not(.active) {
            color: var(--text-primary, #F5F5F5);
        }

        /* Analysis Mode Container */
        .analysis-mode-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            background: var(--bg-primary, #0A0A0A);
        }

        .analysis-mode-container.active {
            display: flex;
        }

        .video-upload-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--bg-secondary, #141414);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px dashed var(--border-subtle, rgba(255,255,255,0.1));
            margin: 16px;
            border-radius: var(--radius-lg, 16px);
        }

        .video-upload-zone.dragover {
            border-color: var(--accent-volt, #CDFF00);
            background: rgba(205, 255, 0, 0.05);
        }

        .video-upload-zone.has-video {
            display: none;
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }

        .upload-subtext {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
        }

        /* Video Player Area */
        .video-player-area {
            flex: 1;
            position: relative;
            display: none;
            background: #000;
        }

        .video-player-area.active {
            display: flex;
            flex-direction: column;
        }

        .video-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #analysisVideo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        #analysisCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Timeline */
        .timeline-container {
            background: rgba(0, 0, 0, 0.9);
            padding: 16px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 12px;
        }

        .timeline-time {
            font-size: 14px;
            color: white;
            font-family: monospace;
            min-width: 100px;
        }

        .timeline-playback-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: var(--accent-volt, #CDFF00);
            color: white;
            font-size: 16px;
            cursor: pointer;
        }

        .timeline-track {
            position: relative;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(76, 175, 80, 0.3);
            border-radius: 4px;
            pointer-events: none;
        }

        .timeline-playhead {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-volt, #CDFF00);
            border-radius: 2px;
            pointer-events: none;
        }

        .stroke-marker {
            position: absolute;
            top: 4px;
            bottom: 4px;
            width: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .stroke-marker:hover {
            transform: scaleY(1.2);
        }

        .stroke-marker.forehand {
            background: var(--accent-volt, #CDFF00);
        }

        .stroke-marker.backhand {
            background: var(--accent-volt, #CDFF00);
        }

        .stroke-marker.serve {
            background: #FF9800;
        }

        .stroke-marker.volley {
            background: #9C27B0;
        }

        .stroke-marker.selected {
            box-shadow: 0 0 0 2px white;
        }

        /* Stroke Details Panel */
        .stroke-details-panel {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 16px;
            padding: 16px;
            min-width: 200px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            transform: translateX(320px);
            transition: transform 0.3s ease;
            z-index: 100;
        }

        .stroke-details-panel.visible {
            transform: translateX(0);
        }

        #comparisonPanel {
            left: 20px;
            right: auto;
            transform: translateX(-320px);
        }

        #comparisonPanel.visible {
            transform: translateX(0);
        }

        .stroke-details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .stroke-details-type {
            font-size: 16px;
            font-weight: bold;
            text-transform: capitalize;
        }

        .stroke-details-score {
            font-size: 24px;
            font-weight: bold;
        }

        .stroke-details-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stroke-metric {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
        }

        .stroke-metric-value {
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .stroke-metric-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Analysis Progress */
        .analysis-progress-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .analysis-progress-overlay.active {
            display: flex;
        }

        .analysis-progress-text {
            font-size: 18px;
            color: white;
            margin-bottom: 20px;
        }

        .analysis-progress-bar {
            width: 80%;
            max-width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .analysis-progress-fill {
            height: 100%;
            background: var(--accent-volt, #CDFF00);
            width: 0%;
            transition: width 0.2s;
        }

        @media (max-width: 480px) {
            .status-bar {
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 10px 12px;
            }

            .analysis-card {
                top: 120px;
                right: 10px;
                padding: 12px;
                min-width: 140px;
            }

            .coaching-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                padding: 12px;
                max-height: 160px;
            }

            .phase-step {
                font-size: 8px;
                padding: 3px 1px;
            }

            .fault-chip, .strength-chip {
                font-size: 9px;
                padding: 2px 6px;
            }

            .controls {
                bottom: 140px;
                gap: 15px;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* ============================================
           REPLAY OVERLAY
           ============================================ */
        .replay-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .replay-overlay.visible {
            display: flex;
        }

        .replay-canvas-wrap {
            position: relative;
            width: 100%;
            max-width: 640px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #replayCanvas {
            width: 100%;
            max-height: 80vh;
            border-radius: 8px;
        }

        .replay-controls {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .replay-ctrl-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #F5F5F5;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 600;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .replay-ctrl-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .replay-ctrl-btn.active {
            background: var(--accent-volt);
            color: #0A0A0A;
            border-color: var(--accent-volt);
        }

        .replay-ctrl-btn.close-btn {
            background: rgba(255, 59, 48, 0.2);
            border-color: rgba(255, 59, 48, 0.4);
            color: #FF3B30;
        }

        .replay-btn {
            position: fixed;
            bottom: calc(220px + env(safe-area-inset-bottom));
            right: 16px;
            z-index: 200;
            background: var(--accent-volt);
            color: #0A0A0A;
            border: none;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 700;
            padding: 10px 16px;
            border-radius: 24px;
            cursor: pointer;
            display: none;
            box-shadow: 0 4px 12px rgba(205, 255, 0, 0.3);
            animation: replayPulse 1.5s ease-in-out infinite;
        }

        @keyframes replayPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .replay-btn.visible {
            display: block;
        }

        /* Session review stroke grid */
        .replay-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 6px;
            margin-top: 8px;
        }

        .replay-grid-item {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .replay-grid-item:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Onboarding Step 1: Welcome -->
        <div id="permissionScreen" class="screen">
            <div class="onboarding-content">
                <div class="hero-title">ACE<span class="accent">.</span></div>
                <div class="hero-subtitle" id="heroSubtitle">AI TENNIS COACH</div>
                <div class="hero-session-count" id="heroSessionCount" style="display: none;"></div>

                <div class="feature-list" id="featureList">
                    <div class="feature-card">
                        <div class="feature-icon">
                            <!-- Waveform/pulse icon -->
                            <svg viewBox="0 0 24 24">
                                <polyline points="2 12 5 12 7 8 10 16 13 10 16 14 19 12 22 12"/>
                            </svg>
                        </div>
                        <div class="feature-content">
                            <div class="feature-title">Real-Time Analysis</div>
                            <div class="feature-desc">30fps pose detection</div>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <!-- Sound wave icon (3 bars) -->
                            <svg viewBox="0 0 24 24">
                                <line x1="8" y1="8" x2="8" y2="16"/>
                                <line x1="12" y1="5" x2="12" y2="19"/>
                                <line x1="16" y1="8" x2="16" y2="16"/>
                            </svg>
                        </div>
                        <div class="feature-content">
                            <div class="feature-title">Voice Coaching</div>
                            <div class="feature-desc">Real-time spoken feedback</div>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <!-- Bar chart icon -->
                            <svg viewBox="0 0 24 24">
                                <line x1="6" y1="20" x2="6" y2="14"/>
                                <line x1="12" y1="20" x2="12" y2="8"/>
                                <line x1="18" y1="20" x2="18" y2="11"/>
                            </svg>
                        </div>
                        <div class="feature-content">
                            <div class="feature-title">Pro Comparison</div>
                            <div class="feature-desc">Match elite benchmarks</div>
                        </div>
                    </div>
                </div>

                <button class="btn-primary" onclick="requestCameraPermission()">
                    GET STARTED <span style="margin-left: 4px;"></span>
                </button>
            </div>

            <div class="step-indicator">
                <div class="step-dot active"></div>
                <div class="step-dot"></div>
                <div class="step-dot"></div>
            </div>
        </div>

        <!-- Onboarding Step 2: Voice Coach Setup -->
        <div id="apiKeyScreen" class="screen" style="display: none;">
            <div class="onboarding-content">
                <div class="voice-header">
                    <div class="voice-title">VOICE<br>COACH</div>
                    <div class="voice-label">OPTIONAL</div>
                    <div class="voice-tagline">Real-time voice feedback on your form.</div>
                </div>

                <div class="api-input-group">
                    <label class="api-label">OPENAI API KEY</label>
                    <div class="api-input-wrapper">
                        <input
                            type="password"
                            id="apiKeyInput"
                            class="api-input"
                            placeholder="sk-..."
                            autocomplete="off"
                        />
                        <div class="api-checkmark" id="apiCheckmark">
                            <svg viewBox="0 0 24 24">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                        </div>
                    </div>
                    <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener" class="api-link">
                        Get an API key 
                    </a>
                </div>

                <button class="btn-primary" id="connectBtn" onclick="connectGPTCoach()">
                    CONNECT <span style="margin-left: 4px;"></span>
                </button>
                <button class="btn-skip" onclick="skipGPTCoach()">
                    Continue without voice
                </button>
            </div>

            <div class="step-indicator">
                <div class="step-dot active"></div>
                <div class="step-dot active"></div>
                <div class="step-dot"></div>
            </div>
        </div>

        <!-- Onboarding Step 3: Loading -->
        <div id="loadingScreen" class="screen" style="display: none;">
            <div class="onboarding-content">
                <div class="loading-content">
                    <div class="loading-logo">
                        <!-- ACE Logo Mark: Ball + Chevron -->
                        <svg viewBox="0 0 64 64" fill="none">
                            <circle cx="20" cy="32" r="10" fill="#CDFF00"/>
                            <path d="M38 16L54 32L38 48L42 48L58 32L42 16Z" fill="#CDFF00"/>
                        </svg>
                    </div>
                    <div class="loading-phase" id="loadingPhase">LOADING</div>
                    <div class="loading-detail" id="loadingDetail">Initializing pose detection model</div>
                    <div class="loading-track">
                        <div class="loading-fill" id="loadingFill"></div>
                    </div>
                </div>
            </div>

            <div class="step-indicator">
                <div class="step-dot active"></div>
                <div class="step-dot active"></div>
                <div class="step-dot active"></div>
            </div>
        </div>

        <!-- Toast Notification Container -->
        <div class="toast" id="toast"></div>

        <!-- Main Camera Interface -->
        <div class="camera-container" style="display: none;" id="cameraContainer">
            <video id="videoElement" playsinline autoplay muted></video>
            <canvas id="canvasElement"></canvas>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-label">STROKES</div>
                    <div class="status-value" id="strokeCount">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">AVG SCORE</div>
                    <div class="status-value muted" id="avgScore">--</div>
                </div>
                <div class="status-item">
                    <div class="status-label">CONSISTENCY</div>
                    <div class="status-value muted" id="consistencyScore">--</div>
                </div>
                <div class="status-item">
                    <div class="status-label">AI COACH</div>
                    <div class="ai-status">
                        <div id="aiStatusDot" class="status-dot"></div>
                    </div>
                </div>
            </div>

            <!-- Analysis Card -->
            <div id="analysisCard" class="analysis-card">
                <div id="strokeType" class="stroke-type">FOREHAND</div>
                <div id="techniqueScore" class="technique-score">85</div>
                <div class="score-label">SCORE</div>

                <div class="advanced-metrics">
                    <div class="metric-item">
                        <div class="metric-label">ELBOW</div>
                        <div class="metric-value" id="elbowAngleMetric">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">ROTATION</div>
                        <div class="metric-value" id="hipSepMetric">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">STANCE</div>
                        <div class="metric-value" id="stanceMetric">--</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">WEIGHT</div>
                        <div class="metric-value" id="weightMetric">--</div>
                    </div>

                    <div class="metric-item" style="grid-column: span 2;">
                        <div class="metric-label">LEVEL</div>
                        <div class="metric-value" id="skillLevelMetric" style="color: var(--accent-volt);">--</div>
                    </div>
                </div>
            </div>

            <!-- Ghost Similarity Display -->
            <div id="ghostSimilarityDisplay" class="ghost-similarity" style="display: none;">
                <div class="ghost-similarity-label">GHOST MATCH</div>
                <div class="ghost-similarity-value" id="ghostSimilarityValue">--</div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <button class="control-btn text-btn" onclick="showAnalytics()" title="View History">
                    STATS
                </button>
                <button id="ghostBtn" class="control-btn text-btn" onclick="toggleGhost()" title="Ghost Overlay">
                    <span id="ghostBtnLabel">GHOST</span>
                </button>
                <button id="playBtn" class="control-btn play-btn" onclick="toggleAnalysis()">
                    REC
                </button>
                <button class="control-btn text-btn" onclick="flipCamera()" title="Flip Camera">
                    FLIP
                </button>
                <button class="control-btn text-btn" onclick="resetSession()">
                    RESET
                </button>
            </div>

            <!-- Coaching Panel -->
            <div class="coaching-panel">
                <div class="coaching-drag-handle"></div>
                <div class="coaching-header">
                    <span class="coaching-label">AI COACH</span>
                    <span class="coaching-dot"></span>
                </div>
                <div id="phaseIndicator" class="phase-indicator" style="display: none;">
                    <div class="phase-step" data-phase="preparation">PREP</div>
                    <div class="phase-step" data-phase="loading">LOAD</div>
                    <div class="phase-step" data-phase="acceleration">ACCEL</div>
                    <div class="phase-step" data-phase="contact">HIT</div>
                    <div class="phase-step" data-phase="followThrough">FINISH</div>
                </div>
                <div id="faultChips" class="fault-chips"></div>
                <div id="coachingText" class="coaching-text">
                    Ready. Stand in frame and swing to begin analysis.
                </div>
            </div>

            <!-- Mode Switcher -->
            <div class="mode-switcher">
                <button class="mode-btn active" id="practiceModeBtn" onclick="switchMode('practice')">Practice</button>
                <button class="mode-btn" id="analysisModeBtn" onclick="switchMode('analysis')">Analysis</button>
                <button class="mode-btn" onclick="showChallenges()" title="Challenges">CHAL</button>
                <button class="mode-btn" id="drillModeBtn" onclick="showDrillSelection()" title="Drill Mode">DRILL</button>
                <button class="mode-btn" onclick="showProComparison()" title="Compare to pro players">Pro</button>
                <button class="mode-btn" id="calibrateModeBtn" onclick="openCalibrationModal()" title="Calibrate with pro videos">Cal</button>
            </div>

            <!-- Analysis Mode Container -->
            <div class="analysis-mode-container" id="analysisModeContainer">
                <!-- Video Upload Zone -->
                <div class="video-upload-zone" id="videoUploadZone">
                    <div class="upload-icon" style="font-size: 24px; font-weight: bold; letter-spacing: 2px;">VIDEO</div>
                    <div class="upload-text">Drop a video here or click to upload</div>
                    <div class="upload-subtext">Supports MP4, MOV, WebM</div>
                    <input type="file" id="videoFileInput" accept="video/*" style="display: none;">
                </div>

                <!-- Video Player Area -->
                <div class="video-player-area" id="videoPlayerArea">
                    <div class="video-container">
                        <video id="analysisVideo" playsinline></video>
                        <canvas id="analysisCanvas"></canvas>
                    </div>

                    <!-- Timeline -->
                    <div class="timeline-container">
                        <div class="timeline-controls">
                            <button class="timeline-playback-btn" id="timelinePlayBtn" onclick="toggleVideoPlayback()">PLAY</button>
                            <span class="timeline-time" id="timelineTime">0:00 / 0:00</span>
                            <div style="margin-left: auto; display: flex; gap: 8px;">
                                <button class="btn btn-secondary" onclick="exportHighlightReel()" style="padding: 8px 12px; font-size: 11px;" title="Export best 5 strokes">
                                    Best 5
                                </button>
                                <button class="btn btn-secondary" onclick="exportBlooperReel()" style="padding: 8px 12px; font-size: 11px;" title="Export worst 5 for learning">
                                    Learn 5
                                </button>
                                <button class="btn btn-secondary" onclick="clearAnalysisVideo()" style="padding: 8px 12px; font-size: 11px;">
                                    New
                                </button>
                            </div>
                        </div>
                        <div class="timeline-track" id="timelineTrack">
                            <div class="timeline-progress" id="timelineProgress"></div>
                            <div class="timeline-playhead" id="timelinePlayhead"></div>
                            <!-- Stroke markers will be inserted here -->
                        </div>
                    </div>

                    <!-- Stroke Details Panel -->
                    <div class="stroke-details-panel" id="strokeDetailsPanel">
                        <div class="stroke-details-header">
                            <span class="stroke-details-type" id="strokeDetailType">Forehand</span>
                            <span class="stroke-details-score" id="strokeDetailScore" style="color: var(--accent-volt, #CDFF00);">85</span>
                        </div>
                        <div class="stroke-details-metrics">
                            <div class="stroke-metric">
                                <div class="stroke-metric-value" id="strokeDetailTime">0:00</div>
                                <div class="stroke-metric-label">Time</div>
                            </div>
                            <div class="stroke-metric">
                                <div class="stroke-metric-value" id="strokeDetailVelocity">--</div>
                                <div class="stroke-metric-label">Velocity</div>
                            </div>
                        </div>
                        <div style="margin-top: 12px; display: flex; gap: 8px;">
                            <button class="btn btn-secondary" onclick="addToComparison()" style="flex: 1; padding: 8px; font-size: 11px;" id="compareBtn">
                                + Compare
                            </button>
                            <button class="btn btn-secondary" onclick="hideStrokeDetails()" style="padding: 8px 12px; font-size: 11px;">
                                
                            </button>
                        </div>
                    </div>

                    <!-- Comparison Panel -->
                    <div class="stroke-details-panel" id="comparisonPanel" style="left: 20px; right: auto; transform: translateX(-320px);">
                        <div style="font-size: 12px; font-weight: bold; text-transform: uppercase; margin-bottom: 12px; color: var(--accent-volt);">
                            Comparing 2 Strokes
                        </div>
                        <div id="comparisonContent">
                            <!-- Dynamic comparison content -->
                        </div>
                        <button class="btn btn-secondary" onclick="clearComparison()" style="width: 100%; margin-top: 12px; padding: 8px; font-size: 11px;">
                            Clear Comparison
                        </button>
                    </div>

                    <!-- Analysis Progress Overlay -->
                    <div class="analysis-progress-overlay" id="analysisProgressOverlay">
                        <div class="analysis-progress-text">Analyzing video...</div>
                        <div class="analysis-progress-bar">
                            <div class="analysis-progress-fill" id="analysisProgressFill"></div>
                        </div>
                        <div style="margin-top: 12px; font-size: 14px; color: rgba(255,255,255,0.6);" id="analysisProgressPercent">0%</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Error Container -->
        <div id="errorContainer"></div>

        <!-- Stroke Quality Flash Overlay -->
        <div id="strokeFlashOverlay" class="stroke-flash-overlay"></div>

        <!-- Session Summary Modal -->
        <div id="sessionSummaryModal" class="modal-overlay">
            <div class="modal">
                <div class="modal-header">
                    <div class="modal-title">Session Complete</div>
                    <button class="modal-close" onclick="closeSessionSummary()">&times;</button>
                </div>
                <div id="sessionSummaryContent">
                    <!-- Dynamic content inserted here -->
                </div>
                <button class="btn" onclick="closeSessionSummary()" style="width: 100%; margin-top: 16px;">
                    Start New Session
                </button>
            </div>
        </div>

        <!-- Drill Selection Modal -->
        <div id="drillModal" class="modal-overlay">
            <div class="modal" style="max-width: 500px;">
                <div class="modal-header">
                    <div class="modal-title">Select Drill</div>
                    <button class="modal-close" onclick="closeDrillModal()">&times;</button>
                </div>
                <div id="drillListContent"></div>
            </div>
        </div>

        <!-- Drill Mode HUD -->
        <div id="drillHUD" class="drill-hud" style="display: none;">
            <div class="drill-hud-header">
                <div class="drill-hud-name" id="drillHudName"></div>
                <button class="drill-hud-stop" onclick="stopDrill()">STOP</button>
            </div>
            <div class="drill-hud-progress">
                <div class="drill-hud-progress-bar">
                    <div class="drill-hud-progress-fill" id="drillProgressFill" style="width: 0%"></div>
                </div>
                <div class="drill-hud-progress-text" id="drillProgressText">0/10</div>
            </div>
            <div class="drill-hud-metric" id="drillMetricDisplay" style="display: none;">
                <div class="drill-hud-metric-value" id="drillMetricValue">--</div>
                <div class="drill-hud-metric-label" id="drillMetricLabel"></div>
                <div class="drill-hud-metric-target" id="drillMetricTarget"></div>
            </div>
            <div class="drill-hud-reps" id="drillRepDots"></div>
        </div>

        <!-- Drill Summary Overlay -->
        <div id="drillSummaryOverlay" class="drill-summary-overlay" style="display: none;">
            <div class="drill-summary-content">
                <div class="drill-summary-title">Drill Complete</div>
                <div class="drill-summary-name" id="drillSummaryName"></div>
                <div class="drill-summary-stats" id="drillSummaryStats"></div>
                <div class="drill-summary-chart" id="drillSummaryChart"></div>
                <div class="drill-summary-actions">
                    <button class="btn" onclick="closeDrillSummary()">Done</button>
                    <button class="btn" onclick="repeatDrill()" style="background: transparent; border: 1px solid var(--text-muted); color: var(--text-primary);">Repeat</button>
                </div>
            </div>
        </div>

        <!-- Analytics Modal -->
        <div id="analyticsModal" class="modal-overlay">
            <div class="modal" style="max-width: 560px;">
                <div class="modal-header">
                    <div class="modal-title">Session History</div>
                    <button class="modal-close" onclick="closeAnalytics()">&times;</button>
                </div>
                <div id="analyticsContent">
                    <!-- Dynamic content inserted here -->
                </div>
            </div>
        </div>

        <!-- Active Challenge Display -->
        <div id="activeChallengeBar" class="active-challenge-bar" style="display: none;">
            <div class="challenge-info">
                <span class="challenge-icon" id="activeChallengeIcon" style="font-weight: bold; font-size: 14px;"></span>
                <span class="challenge-name" id="activeChallengeName">Challenge</span>
            </div>
            <div class="challenge-progress-bar">
                <div class="challenge-progress-fill" id="activeChallengeProgress"></div>
            </div>
            <div class="challenge-progress-text" id="activeChallengeText">0/10</div>
        </div>

        <!-- Challenge Completion Celebration -->
        <div id="challengeCompleteOverlay" class="challenge-complete-overlay" style="display: none;">
            <div class="challenge-complete-content">
                <div class="challenge-complete-icon" style="font-size: 32px; font-weight: bold; letter-spacing: 3px;">DONE</div>
                <div class="challenge-complete-title">Challenge Complete!</div>
                <div class="challenge-complete-name" id="completedChallengeName">Consistency King</div>
                <div class="challenge-complete-reward" id="completedChallengeReward">Unlocked: Advanced Analytics</div>
                <button class="btn" onclick="closeChallengeComplete()">Continue</button>
            </div>
        </div>

        <!-- Challenges Modal -->
        <div id="challengesModal" class="modal-overlay">
            <div class="modal" style="max-width: 500px;">
                <div class="modal-header">
                    <div class="modal-title">Challenges</div>
                    <button class="modal-close" onclick="closeChallenges()">&times;</button>
                </div>
                <div id="challengesContent">
                    <!-- Dynamic challenge list -->
                </div>
            </div>
        </div>

        <!-- Pro Comparison Modal -->
        <div id="proComparisonModal" class="modal-overlay">
            <div class="modal" style="max-width: 500px;">
                <div class="modal-header">
                    <div class="modal-title">Compare to Pro</div>
                    <button class="modal-close" onclick="closeProComparison()">&times;</button>
                </div>
                <div id="proComparisonContent">
                    <!-- Pro selector -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 12px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 8px;">Select a Pro</div>
                        <div class="pro-selector" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                            <button class="pro-card" onclick="selectPro('federer')" id="pro-federer">
                                <div class="pro-name">Roger Federer</div>
                                <div class="pro-style">Forehand, Serve, Volley</div>
                            </button>
                            <button class="pro-card" onclick="selectPro('djokovic')" id="pro-djokovic">
                                <div class="pro-name">Novak Djokovic</div>
                                <div class="pro-style">Backhand, Return, Defense</div>
                            </button>
                            <button class="pro-card" onclick="selectPro('nadal')" id="pro-nadal">
                                <div class="pro-name">Rafael Nadal</div>
                                <div class="pro-style">Forehand, Topspin, Defense</div>
                            </button>
                            <button class="pro-card" onclick="selectPro('serena')" id="pro-serena">
                                <div class="pro-name">Serena Williams</div>
                                <div class="pro-style">Serve, Power, Forehand</div>
                            </button>
                        </div>
                    </div>

                    <!-- Comparison results -->
                    <div id="proComparisonResults" style="display: none;">
                        <div class="summary-stats" style="margin-bottom: 16px;">
                            <div class="summary-stat highlight">
                                <div class="summary-stat-value" id="proSimilarityScore">--</div>
                                <div class="summary-stat-label">Similarity</div>
                            </div>
                        </div>

                        <div id="proComparisonDetails">
                            <!-- Dynamic comparison details -->
                        </div>

                        <div id="proCoachingTip" style="margin-top: 16px; padding: 12px; background: rgba(205, 255, 0, 0.1); border-radius: 8px; border-left: 3px solid var(--accent-volt);">
                            <!-- GPT coaching insight -->
                        </div>
                    </div>

                    <div id="proComparisonEmpty" style="text-align: center; padding: 30px; color: var(--text-muted);">
                        <div style="font-size: 14px;">Complete some strokes first to compare your technique with a pro.</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calibration Modal -->
        <div id="calibrationModal" class="modal-overlay">
            <div class="modal" style="max-width: 600px;">
                <div class="modal-header">
                    <div class="modal-title">Calibration Tool</div>
                    <button class="modal-close" onclick="closeCalibrationModal()">&times;</button>
                </div>
                <div id="calibrationContent">
                    <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">
                        Upload professional tennis videos to calibrate the analysis thresholds.
                        Use slow-motion court-level footage for best results.
                    </p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                        <div>
                            <label style="font-size: 12px; color: rgba(255,255,255,0.6);">Skill Level</label>
                            <select id="calibrationLabel" style="width: 100%; padding: 8px; border-radius: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white;">
                                <option value="professional">Professional</option>
                                <option value="advanced">Advanced</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="beginner">Beginner</option>
                            </select>
                        </div>
                        <div>
                            <label style="font-size: 12px; color: rgba(255,255,255,0.6);">Player Name</label>
                            <input type="text" id="calibrationPlayer" placeholder="e.g., Djokovic" style="width: 100%; padding: 8px; border-radius: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white;">
                        </div>
                    </div>

                    <div id="calibrationUploadZone" style="border: 2px dashed rgba(255,255,255,0.3); border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; margin-bottom: 20px;">
                        <div style="font-size: 18px; font-weight: bold; letter-spacing: 2px; margin-bottom: 12px;">UPLOAD</div>
                        <div>Drop video here or click to upload</div>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.5); margin-top: 8px;">MP4, MOV, WebM supported</div>
                        <input type="file" id="calibrationFileInput" accept="video/*" style="display: none;">
                    </div>

                    <div id="calibrationProgress" style="display: none; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span id="calibrationStatus">Processing...</span>
                            <span id="calibrationStrokeCount">0 strokes</span>
                        </div>
                        <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                            <div id="calibrationProgressBar" style="height: 100%; background: var(--accent-volt, #CDFF00); width: 0%; transition: width 0.3s;"></div>
                        </div>
                    </div>

                    <div id="calibrationResults" style="display: none;">
                        <!-- Results will be inserted here -->
                    </div>

                    <div style="display: flex; gap: 12px; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="showCalibrationStats()" style="flex: 1;">
                            View All Stats
                        </button>
                        <button class="btn btn-secondary" onclick="exportCalibrationData()" style="flex: 1;">
                            Export Data
                        </button>
                    </div>

                    <!-- Threshold Update Actions -->
                    <div id="thresholdUpdateSection" style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 14px; font-weight: bold; margin-bottom: 12px;">Apply Calibration</div>
                        <p style="font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 16px;">
                            Apply calibrated thresholds to improve stroke detection accuracy.
                        </p>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn" onclick="applyThresholdsToApp()" style="flex: 1; background: var(--accent-volt, #CDFF00);">
                                Apply Now
                            </button>
                            <button class="btn btn-secondary" onclick="exportThresholdUpdates()" style="flex: 1;">
                                Export Code
                            </button>
                        </div>
                        <div id="thresholdApplyStatus" style="margin-top: 12px; font-size: 12px; color: rgba(255,255,255,0.6);"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Replay Button (fixed, bottom-right) -->
    <button id="replayBtn" class="replay-btn" onclick="openReplay(this.dataset.index)">REPLAY</button>

    <!-- Replay Overlay -->
    <div id="replayOverlay" class="replay-overlay">
        <div class="replay-canvas-wrap">
            <canvas id="replayCanvas" width="640" height="480"></canvas>
        </div>
        <div class="replay-controls">
            <button class="replay-ctrl-btn" onclick="toggleReplayPlayback()" id="replayPlayPauseBtn">PAUSE</button>
            <button class="replay-ctrl-btn" onclick="setReplaySpeed(0.25)" data-speed="0.25">0.25x</button>
            <button class="replay-ctrl-btn active" onclick="setReplaySpeed(0.5)" data-speed="0.5">0.5x</button>
            <button class="replay-ctrl-btn" onclick="setReplaySpeed(1)" data-speed="1">1x</button>
            <button class="replay-ctrl-btn" onclick="replayStepFrame(-1)">&lt;</button>
            <button class="replay-ctrl-btn" onclick="replayStepFrame(1)">&gt;</button>
            <button class="replay-ctrl-btn close-btn" onclick="closeReplay()">CLOSE</button>
        </div>
    </div>

    <script>
        // Tennis AI Application
        class TennisAI {
            constructor() {
                this.pose = null;
                this.camera = null;
                this.isReady = false;
                this.isAnalyzing = false;
                this.currentFacingMode = 'user';

                // Signal processing: adaptive low-pass filter + bone constraints
                this.landmarkFilter = new LandmarkFilter({
                    frequency: 30,
                    minCutoff: 1.0,
                    beta: 80.0,
                    dCutoff: 1.0,
                    enableBoneConstraints: true,
                    boneDeviationThreshold: 0.15,
                    calibrationFrames: 30
                });

                // Enhanced Analysis Engine
                this.enhancedAnalyzer = new EnhancedTennisAnalyzer();
                this.enhancedAnalyzer.setLandmarkFilter(this.landmarkFilter);
                this.enhancedAnalyzer.onStrokeCallback = (strokeData, historySnapshot) => {
                    this.freezeTrail(historySnapshot, strokeData);
                    // Show replay button after each stroke
                    if (this.replayManager && this.replayManager.getReplayCount() > 0) {
                        showReplayButton(this.replayManager.getReplayCount() - 1);
                    }
                };

                // Stroke Replay Manager
                this.replayManager = new StrokeReplayManager();
                window.strokeReplayManager = this.replayManager;

                // Ball Tracking (in-browser color detection, no server needed)
                this.ballTracker = new BallTrackingClient({
                    onShotAnalyzed: this.onShotAnalyzed.bind(this)
                });

                // Fault-to-landmark mapping for visual highlighting
                this.faultLandmarkMap = {
                    latePreparation: [11, 12],
                    armOnlySwing: [11, 12, 23, 24],
                    collapsingElbow: [13, 14],
                    hittingOffBackFoot: [27, 28],
                    abbreviatedFollowThrough: [15, 16],
                    inconsistentContactPoint: [15, 16],
                    noKneeBend: [25, 26],
                    rushingTheSwing: [11, 12, 23, 24],
                    narrowBase: [27, 28],
                    noStepIn: [27, 28],
                    poorRecovery: [23, 24, 27, 28],
                    wrongStanceForStroke: [23, 24, 27, 28],
                    // Serve faults
                    noLegDrive: [25, 26, 27, 28],
                    noTrophyPosition: [11, 12, 15, 16],
                    lowServeContactPoint: [15, 16],
                    flatServeNoTilt: [11, 12]
                };
                this.faultHighlightDuration = 3000;

                // Enhanced swing trail state
                this.frozenTrail = null;
                this.frozenTrailTimestamp = 0;
                this.frozenTrailFadeMs = 1500;
                this.contactPointMarker = null;
                this.phaseColors = {
                    preparation:   { r: 60,  g: 130, b: 246 },
                    loading:       { r: 250, g: 204, b: 21  },
                    acceleration:  { r: 249, g: 115, b: 22  },
                    contact:       { r: 255, g: 59,  b: 48  },
                    followThrough: { r: 50,  g: 215, b: 75  },
                    unknown:       { r: 0,   g: 255, b: 255 }
                };

                // DOM elements
                this.video = document.getElementById('videoElement');
                this.canvas = document.getElementById('canvasElement');
                this.ctx = this.canvas.getContext('2d');

                this.initializeLoadingSequence();
            }

            async initializeLoadingSequence() {
                try {
                    this.updateLoadingProgress(10, 'Loading MediaPipe libraries...');
                    await this.sleep(500);
                    
                    this.updateLoadingProgress(30, 'Initializing pose detection...');
                    await this.initializeMediaPipe();
                    
                    this.updateLoadingProgress(60, 'Setting up tennis analysis...');
                    await this.sleep(500);
                    
                    this.updateLoadingProgress(80, 'Configuring camera...');
                    await this.setupCamera();
                    
                    this.updateLoadingProgress(90, 'Connecting ball tracking...');
                    this.ballTracker.startCapture(this.video);
                    await this.sleep(300);

                    this.updateLoadingProgress(100, 'Ready to coach!');
                    await this.sleep(500);

                    this.completeInitialization();
                    
                } catch (error) {
                    this.showError('Failed to initialize: ' + error.message);
                }
            }

            async initializeMediaPipe() {
                this.pose = new Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });

                this.pose.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.pose.onResults(this.onResults.bind(this));
                this.isReady = true;
            }
            async setupCamera() {
                // Stop existing tracks before switching
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: this.currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                this.video.srcObject = stream;

                return new Promise((resolve) => {
                    this.video.onloadedmetadata = () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;

                       this.camera = new Camera(this.video, {
                        onFrame: async () => {
                            if (this.pose) {
                                await this.pose.send({ image: this.video });
                            }
                        },
                        width: 1280,
                        height: 720
                    });

                        this.camera.start();
                        resolve();
                    };
                });
            }
            onResults(results) {
                // Clear and draw camera feed
                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(results.image, 0, 0, this.canvas.width, this.canvas.height);

                if (results.poseLandmarks) {

                // Draw pose overlay
                // Volt accent skeleton with glow effect
                this.ctx.shadowColor = 'rgba(205, 255, 0, 0.4)';
                this.ctx.shadowBlur = 8;
                drawConnectors(this.ctx, results.poseLandmarks, POSE_CONNECTIONS, {
                    color: 'rgba(205, 255, 0, 0.7)',
                    lineWidth: 2
                });
                this.ctx.shadowBlur = 0;
                drawLandmarks(this.ctx, results.poseLandmarks, {
                    color: '#FFFFFF',
                    fillColor: 'rgba(205, 255, 0, 0.9)',
                    lineWidth: 1,
                    radius: 3
                });

                // Draw fault highlights on affected joints
                if (this.isAnalyzing) {
                    this.drawFaultHighlights(results.poseLandmarks);
                }

                // Only analyze pose when user has pressed play
                if (this.isAnalyzing) {
                    // Filter landmarks for analysis (raw landmarks still used above for skeleton drawing)
                    const timestamp = Date.now();
                    const filteredLandmarks = this.landmarkFilter.filterLandmarks(results.poseLandmarks, timestamp);
                    const poseData = this.enhancedAnalyzer.analyzePose(filteredLandmarks, timestamp);

                    // Capture frame for ball tracking (runs in background)
                    this.ballTracker.onFrame();

                    // Draw swing trail
                    if (this.enhancedAnalyzer.poseHistory.length > 2) {
                        this.drawSwingTrail();
                    }

                    // Continuously record frames for ghost (we'll extract stroke when detected)
                    if (typeof ghostOverlay !== 'undefined') {
                        ghostOverlay.recordFrame(results.poseLandmarks, Date.now());
                    }
                }

                // Draw ghost overlay (behind current pose for visibility)
                if (typeof ghostOverlay !== 'undefined' && ghostOverlay.isEnabled()) {
                    ghostOverlay.draw(this.ctx, results.poseLandmarks);

                    // Update similarity display
                    const similarity = ghostOverlay.getSimilarityScore();
                    if (similarity !== null) {
                        this.updateGhostSimilarity(similarity);
                    }
                }
            }

                this.ctx.restore();
            }

            drawSwingTrail() {
                const now = Date.now();

                // Draw frozen trail (post-stroke, phase-colored) if available
                if (this.frozenTrail) {
                    const age = now - this.frozenTrailTimestamp;
                    if (age > this.frozenTrailFadeMs) {
                        this.frozenTrail = null;
                        this.contactPointMarker = null;
                    } else {
                        const fadeAlpha = age < 1000 ? 1.0 : 1.0 - ((age - 1000) / 500);
                        this.drawPhaseColoredTrail(this.frozenTrail, fadeAlpha);
                        this.drawContactPointMarker(fadeAlpha);
                        return;
                    }
                }

                // Draw live real-time trail
                this.drawLiveTrail();
            }

            drawLiveTrail() {
                const history = this.enhancedAnalyzer.poseHistory;
                if (history.length < 3) return;

                this.ctx.save();

                const points = history.map(p => {
                    const wrist = p.joints.dominantWrist || p.joints.rightWrist;
                    return {
                        x: wrist.x * this.canvas.width,
                        y: wrist.y * this.canvas.height,
                        velocity: p.velocity?.magnitude || 0
                    };
                });

                const velocities = points.map(p => p.velocity);
                const maxVel = Math.max(...velocities);
                const minVel = Math.min(...velocities);
                const velRange = maxVel - minVel || 1;
                const peakIdx = velocities.indexOf(maxVel);

                for (let i = 1; i < points.length; i++) {
                    const t = i / points.length;
                    const velNorm = (points[i].velocity - minVel) / velRange;
                    const isPastPeak = i > peakIdx && peakIdx > points.length * 0.3;
                    const color = this.velocityToColor(velNorm, isPastPeak);
                    const lineWidth = 2 + velNorm * 6;

                    this.ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${t * 0.5})`;
                    this.ctx.shadowBlur = 6 + velNorm * 8;
                    this.ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${t * 0.8})`;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.lineCap = 'round';

                    this.ctx.beginPath();
                    this.ctx.moveTo(points[i - 1].x, points[i - 1].y);
                    this.ctx.lineTo(points[i].x, points[i].y);
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            velocityToColor(velNorm, isPastPeak) {
                if (isPastPeak) return this.phaseColors.followThrough;
                if (velNorm < 0.2) return this.phaseColors.preparation;
                if (velNorm < 0.45) return this.phaseColors.loading;
                if (velNorm < 0.7) return this.phaseColors.acceleration;
                return this.phaseColors.contact;
            }

            freezeTrail(poseHistory, strokeData) {
                const phases = this.enhancedAnalyzer.lastDetectedPhase;
                const phaseDetector = this.enhancedAnalyzer.phaseDetector;

                const velocities = poseHistory.map(p => p.velocity?.magnitude || 0);
                const maxVel = Math.max(...velocities);
                const minVel = Math.min(...velocities);
                const velRange = maxVel - minVel || 1;

                this.frozenTrail = poseHistory.map((p, i) => {
                    const wrist = p.joints.dominantWrist || p.joints.rightWrist;
                    const velNorm = (velocities[i] - minVel) / velRange;

                    let phase = 'unknown';
                    if (phases && phaseDetector) {
                        phase = phaseDetector.getPhaseAtFrame(phases, i);
                    }

                    return {
                        x: wrist.x * this.canvas.width,
                        y: wrist.y * this.canvas.height,
                        velNorm,
                        phase
                    };
                });

                this.frozenTrailTimestamp = Date.now();

                // Set contact point marker
                if (phases && phases.contactFrame != null && poseHistory[phases.contactFrame]) {
                    const contactPose = poseHistory[phases.contactFrame];
                    const wrist = contactPose.joints.dominantWrist || contactPose.joints.rightWrist;
                    this.contactPointMarker = {
                        x: wrist.x * this.canvas.width,
                        y: wrist.y * this.canvas.height,
                        timestamp: Date.now()
                    };
                }
            }

            drawPhaseColoredTrail(trailData, globalAlpha) {
                if (trailData.length < 2) return;
                this.ctx.save();

                for (let i = 1; i < trailData.length; i++) {
                    const seg = trailData[i];
                    const color = this.phaseColors[seg.phase] || this.phaseColors.unknown;
                    const t = i / trailData.length;

                    this.ctx.shadowColor = `rgba(${color.r}, ${color.g}, ${color.b}, ${globalAlpha * 0.5})`;
                    this.ctx.shadowBlur = 8 + seg.velNorm * 10;
                    this.ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${globalAlpha * t})`;
                    this.ctx.lineWidth = 2 + seg.velNorm * 6;
                    this.ctx.lineCap = 'round';

                    this.ctx.beginPath();
                    this.ctx.moveTo(trailData[i - 1].x, trailData[i - 1].y);
                    this.ctx.lineTo(seg.x, seg.y);
                    this.ctx.stroke();
                }

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            drawContactPointMarker(alpha) {
                if (!this.contactPointMarker) return;
                const { x, y, timestamp } = this.contactPointMarker;
                const age = Date.now() - timestamp;
                const pulse = 1.0 + 0.3 * Math.sin(age / 100);
                const radius = 10 * pulse;

                this.ctx.save();
                this.ctx.shadowColor = `rgba(255, 59, 48, ${alpha * 0.8})`;
                this.ctx.shadowBlur = 20;

                // Outer ring
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.stroke();

                // Inner dot
                this.ctx.fillStyle = `rgba(255, 59, 48, ${alpha * 0.9})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.shadowBlur = 0;
                this.ctx.restore();
            }

            drawFaultHighlights(landmarks) {
                const now = Date.now();
                const faults = this.enhancedAnalyzer.activeFaults;
                if (!faults || faults.length === 0) return;

                const highlighted = new Set();

                this.ctx.save();
                for (const fault of faults) {
                    const age = now - fault.timestamp;
                    if (age > this.faultHighlightDuration) continue;

                    const indices = this.faultLandmarkMap[fault.id];
                    if (!indices) continue;

                    const alpha = 1 - (age / this.faultHighlightDuration);
                    const pulse = 0.5 + 0.5 * Math.sin(now / 150);

                    for (const idx of indices) {
                        if (highlighted.has(idx)) continue;
                        highlighted.add(idx);

                        const lm = landmarks[idx];
                        if (!lm) continue;

                        const x = lm.x * this.canvas.width;
                        const y = lm.y * this.canvas.height;
                        const radius = 8 + pulse * 4;

                        // Outer glow
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 59, 48, ${alpha * pulse * 0.3})`;
                        this.ctx.fill();

                        // Inner circle
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(255, 59, 48, ${alpha * 0.8})`;
                        this.ctx.fill();
                        this.ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }
                this.ctx.restore();
            }

            updateGhostSimilarity(similarity) {
                const display = document.getElementById('ghostSimilarityDisplay');
                const valueEl = document.getElementById('ghostSimilarityValue');

                if (!display || !valueEl) return;

                valueEl.textContent = `${similarity}%`;

                // Color code based on similarity
                valueEl.classList.remove('low', 'medium', 'high');
                if (similarity >= 80) {
                    valueEl.classList.add('high');
                } else if (similarity >= 50) {
                    valueEl.classList.add('medium');
                } else {
                    valueEl.classList.add('low');
                }
            }

            updateUI(context) {
                // Update status bar
                document.getElementById('strokeCount').textContent = context.session.strokeCount;
                document.getElementById('avgScore').textContent = context.quality.overall.toFixed(0);
                document.getElementById('consistencyScore').textContent = context.session.consistency;
                
                // Update analysis card
                document.getElementById('strokeType').textContent = 
                    context.strokeType.charAt(0).toUpperCase() + context.strokeType.slice(1);
                document.getElementById('techniqueScore').textContent = 
                    `${context.quality.overall.toFixed(0)}/100`;
                
                // Update metrics
                document.getElementById('elbowAngleMetric').textContent = 
                    `${context.technique.elbowAngleAtContact.toFixed(0)}`;
                document.getElementById('hipSepMetric').textContent = 
                    `${context.technique.hipShoulderSeparation.toFixed(0)}`;
                document.getElementById('stanceMetric').textContent = context.technique.stance;
                document.getElementById('weightMetric').textContent = context.technique.weightTransfer;
                
                if (context.comparison && context.comparison.skillLevel) {
        const skillLevel = context.comparison.skillLevel;
        const skillDisplay = skillLevel.charAt(0).toUpperCase() + skillLevel.slice(1);
        document.getElementById('skillLevelMetric').textContent = 
            `${skillDisplay} (${context.comparison.percentile}%)`;
    }
    
                // Show card
                const card = document.getElementById('analysisCard');
                card.classList.add('visible');
                setTimeout(() => card.classList.remove('visible'), 4000);
        }   
            

            startAnalysis() {
                if (!this.isReady) return;
                
                this.isAnalyzing = true;
                
                document.getElementById('aiStatusDot').className = 'status-dot active';
                document.getElementById('playBtn').textContent = 'STOP';
                document.getElementById('coachingText').textContent = 
                    'AI analyzing your strokes. Make tennis swings to get feedback!';
            }

            stopAnalysis() {
                this.isAnalyzing = false;
                
                document.getElementById('aiStatusDot').className = 'status-dot ready';
                document.getElementById('playBtn').textContent = 'REC';
                document.getElementById('coachingText').textContent = 
                    'Analysis paused. Tap play to resume.';
            }

            async resetSession() {
                // End current session and show summary if strokes were recorded
                if (typeof sessionStorage !== 'undefined' && sessionStorage.endSession) {
                    const endedSession = sessionStorage.endSession();
                    if (endedSession && endedSession.summary && endedSession.summary.totalStrokes > 0) {
                        // Record session in player profile for cross-session tracking
                        if (typeof playerProfile !== 'undefined') {
                            const milestones = playerProfile.recordSession(endedSession.summary);
                            // Show milestones if any achieved
                            if (milestones && milestones.length > 0) {
                                endedSession.summary.milestones = milestones;
                            }
                        }

                        // Record metrics in improvement tracker
                        if (typeof improvementTracker !== 'undefined') {
                            improvementTracker.recordSession(endedSession.strokes, endedSession.summary);
                        }

                        // Synthesize notebook entry (while GPT connection still alive)
                        if (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.synthesizeNotebookEntry) {
                            try {
                                const coachNotes = await gptVoiceCoach.synthesizeNotebookEntry(endedSession.summary);
                                if (typeof coachNotebook !== 'undefined' && coachNotes) {
                                    coachNotebook.saveEntry({
                                        date: Date.now(),
                                        sessionNumber: playerProfile?.profile?.totalSessions || 0,
                                        summary: {
                                            totalStrokes: endedSession.summary.totalStrokes,
                                            avgScore: endedSession.summary.averageScore,
                                            weaknesses: endedSession.summary.weaknesses,
                                            improvement: endedSession.summary.improvement,
                                            skillLevel: endedSession.summary.skillLevel,
                                            strokeTypeBreakdowns: endedSession.summary.strokeTypeBreakdowns
                                        },
                                        coachNotes: coachNotes,
                                        transcriptSnippets: gptVoiceCoach.sessionTranscript?.length || 0
                                    });
                                }
                                endedSession.summary.coachNotes = coachNotes;
                            } catch (e) {
                                console.error('Notebook synthesis failed:', e);
                            }
                        }

                        // Synthesize coaching plan update
                        if (typeof improvementTracker !== 'undefined' && typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.synthesizeCoachingPlan) {
                            try {
                                const plan = await gptVoiceCoach.synthesizeCoachingPlan(
                                    endedSession.summary,
                                    improvementTracker
                                );
                                if (plan) {
                                    improvementTracker.updateCoachingPlan(plan);
                                    endedSession.summary.coachingPlan = plan;
                                }
                            } catch (e) {
                                console.error('Plan synthesis failed:', e);
                            }
                        }

                        showSessionSummary(endedSession.summary);
                    }
                    // Create new session
                    sessionStorage.createSession();
                }

                // Reset GPT coach session state
                if (typeof gptVoiceCoach !== 'undefined' && gptVoiceCoach.resetSession) {
                    gptVoiceCoach.resetSession();
                }

                this.enhancedAnalyzer.resetSession();
                this.landmarkFilter.reset();

                document.getElementById('strokeCount').textContent = '0';
                document.getElementById('avgScore').textContent = '--';
                document.getElementById('consistencyScore').textContent = '--';
                document.getElementById('elbowAngleMetric').textContent = '--';
                document.getElementById('hipSepMetric').textContent = '--';
                document.getElementById('stanceMetric').textContent = '--';
                document.getElementById('weightMetric').textContent = '--';
                document.getElementById('coachingText').textContent =
                    'Session reset! Ready to analyze your technique.';
                document.getElementById('analysisCard').classList.remove('visible');
            }

            /**
             * Called asynchronously when ball tracking backend returns shot outcome
             */
            onShotAnalyzed(shotOutcome, originalStroke) {
                const outcome = shotOutcome.outcome;
                if (!outcome || outcome.confidence < 0.2) return;

                // Build follow-up coaching based on shot outcome
                const outcomeContext = {
                    type: 'shot_outcome',
                    in_court: outcome.in_court,
                    ball_direction: outcome.ball_direction,
                    net_clearance: outcome.net_clearance,
                    landed_position: outcome.landed_position,
                    confidence: outcome.confidence,
                    strokeType: shotOutcome.strokeType,
                    ballDetectionRate: shotOutcome.ballDetectionRate
                };

                // Send outcome to GPT coach as follow-up context
                if (typeof gptVoiceCoach !== 'undefined' && outcome.confidence >= 0.4) {
                    const followUp = this.buildOutcomeCoachingMessage(outcomeContext, originalStroke);
                    if (followUp) {
                        gptVoiceCoach.analyzeStroke({
                            type: 'shot_outcome_followup',
                            ...followUp
                        });
                    }
                }

                // Update coaching panel with outcome
                const panel = document.getElementById('coachingText');
                if (panel && outcome?.in_court !== null && outcome?.in_court !== undefined) {
                    const tag = outcome.in_court ? 'IN' : 'OUT';
                    const current = panel.textContent;
                    panel.textContent = `[${tag}] ${current}`;
                }
            }

            /**
             * Build coaching follow-up message based on shot outcome
             */
            buildOutcomeCoachingMessage(outcomeContext, stroke) {
                // Only follow up if there's something notable to say
                const quality = stroke.quality?.overall || 0;

                // Good form but ball went out = important coaching moment
                if (quality >= 70 && outcomeContext.in_court === false) {
                    return {
                        strokeType: outcomeContext.strokeType,
                        message: 'Good technique but the ball went out. Consider reducing swing speed slightly or adjusting contact angle.',
                        quality: { overall: quality },
                        shotOutcome: outcomeContext
                    };
                }

                // Bad form but ball went in = acknowledge but keep coaching form
                if (quality < 50 && outcomeContext.in_court === true) {
                    return {
                        strokeType: outcomeContext.strokeType,
                        message: 'The ball landed in, but the technique needs work for consistency. Keep focusing on form.',
                        quality: { overall: quality },
                        shotOutcome: outcomeContext
                    };
                }

                // Great form + ball in = positive reinforcement
                if (quality >= 80 && outcomeContext.in_court === true) {
                    return {
                        strokeType: outcomeContext.strokeType,
                        message: 'Great shot! Technique and placement both excellent.',
                        quality: { overall: quality },
                        shotOutcome: outcomeContext
                    };
                }

                return null; // Don't follow up for unremarkable outcomes
            }

            completeInitialization() {
                const loadingScreen = document.getElementById('loadingScreen');
                const cameraContainer = document.getElementById('cameraContainer');

                // Cinematic exit: Hold at READY for 1s, then exit
                // Haptic trigger point: navigator.vibrate && navigator.vibrate(10);

                setTimeout(() => {
                    // Exit: fade out + move up (more dramatic -30px)
                    loadingScreen.style.transition = 'opacity 300ms ease-out, transform 300ms ease-out';
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.transform = 'translateY(-30px)';

                    // Prepare camera view underneath
                    cameraContainer.style.display = 'block';
                    cameraContainer.style.opacity = '0';

                    setTimeout(() => {
                        loadingScreen.style.display = 'none';

                        // Fade in camera view
                        cameraContainer.style.transition = 'opacity 400ms ease-out';
                        cameraContainer.offsetHeight; // Trigger reflow
                        cameraContainer.style.opacity = '1';

                        document.getElementById('aiStatusDot').className = 'status-dot ready';

                        // Create or restore session
                        if (typeof sessionStorage !== 'undefined' && sessionStorage.createSession) {
                            const existingSession = sessionStorage.getCurrentSession();
                            if (!existingSession) {
                                sessionStorage.createSession();
                            }
                        }

                        // Welcome coaching message
                        document.getElementById('coachingText').textContent =
                            'Ready to analyze. Tap REC to start.';
                    }, 300);
                }, 1000); // Hold at READY for 1 second
            }

            // Premium loading phase management
            updateLoadingProgress(percent, status) {
                const phaseEl = document.getElementById('loadingPhase');
                const detailEl = document.getElementById('loadingDetail');
                const fillEl = document.getElementById('loadingFill');

                // Phase mapping with spec-compliant details
                const phases = {
                    'Loading MediaPipe libraries...': { phase: 'LOADING', detail: 'Initializing pose detection model', progress: 10 },
                    'Initializing pose detection...': { phase: 'DETECTING', detail: 'Configuring MediaPipe Holistic', progress: 30 },
                    'Setting up tennis analysis...': { phase: 'ANALYZING', detail: 'Loading stroke analysis engine', progress: 60 },
                    'Configuring camera...': { phase: 'CAMERA', detail: 'Requesting camera access', progress: 80 },
                    'Connecting ball tracking...': { phase: 'TRACKING', detail: 'Connecting to ball detection server', progress: 90 },
                    'Ready to coach!': { phase: 'READY', detail: "Let's go.", progress: 100 }
                };

                const mapped = phases[status] || { phase: 'LOADING', detail: status, progress: percent };

                // Crossfade phase text
                if (phaseEl && phaseEl.textContent !== mapped.phase) {
                    phaseEl.classList.add('crossfade');
                    detailEl.classList.add('crossfade');

                    setTimeout(() => {
                        phaseEl.textContent = mapped.phase;
                        detailEl.textContent = mapped.detail;
                        phaseEl.classList.remove('crossfade');
                        detailEl.classList.remove('crossfade');
                    }, 200);
                }

                // Smooth progress bar - never jumps, always eases
                if (fillEl) {
                    fillEl.style.width = mapped.progress + '%';
                }
            }

            showError(message) {
                showToast(message);
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Global application state
        let tennisAI = null;
        window.tennisAI = null; // Exposed for cross-module access (ball tracking)

        // ============================================
        // PREMIUM SCREEN TRANSITIONS
        // Vertical motion only, 400ms ease-out
        // ============================================

        function transitionScreens(fromId, toId, callback) {
            const fromScreen = document.getElementById(fromId);
            const toScreen = document.getElementById(toId);

            // Exit animation: fade out + move up
            fromScreen.classList.add('exiting');

            setTimeout(() => {
                fromScreen.style.display = 'none';
                fromScreen.classList.remove('exiting');

                // Enter animation: start below, fade in while moving up
                toScreen.style.display = 'flex';
                toScreen.classList.add('entering');

                // Trigger reflow
                toScreen.offsetHeight;

                // Activate enter animation
                toScreen.classList.add('active');

                setTimeout(() => {
                    toScreen.classList.remove('entering', 'active');
                    if (callback) callback();
                }, 400);
            }, 400);
        }

        // ============================================
        // ONBOARDING FLOW
        // ============================================

        async function requestCameraPermission() {
            // Haptic trigger point: navigator.vibrate && navigator.vibrate(10);
            transitionScreens('permissionScreen', 'apiKeyScreen');
        }

        async function connectGPTCoach() {
            const input = document.getElementById('apiKeyInput');
            const apiKey = input.value;
            const connectBtn = document.getElementById('connectBtn');

            if (!apiKey || !apiKey.startsWith('sk-')) {
                showToast('Please enter a valid OpenAI API key');
                input.focus();
                return;
            }

            // Save API key for future sessions
            try {
                localStorage.setItem('ace_openai_key', apiKey);
            } catch (e) {}

            // Micro-interaction: flash input border
            input.classList.add('flash');

            // Show checkmark
            document.getElementById('apiCheckmark').classList.add('visible');

            // Change button text to CONNECTED
            const originalHTML = connectBtn.innerHTML;
            connectBtn.innerHTML = 'CONNECTED <span style="margin-left: 4px;"></span>';
            connectBtn.disabled = true;

            // Haptic trigger point: navigator.vibrate && navigator.vibrate([10, 50, 10]);

            // Wait for micro-interaction to complete
            await new Promise(r => setTimeout(r, 800));

            // Transition to loading
            transitionScreens('apiKeyScreen', 'loadingScreen', async () => {
                // Initialize GPT coach
                await gptVoiceCoach.initialize(apiKey);

                // Start tennis AI initialization
                tennisAI = new TennisAI();
                window.tennisAI = tennisAI;
            });
        }

        function skipGPTCoach() {
            transitionScreens('apiKeyScreen', 'loadingScreen', () => {
                // Use fallback coaching
                gptVoiceCoach.fallbackToSpeechSynthesis();

                // Start tennis AI initialization
                tennisAI = new TennisAI();
                window.tennisAI = tennisAI;
            });
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // Slides down from top, auto-dismiss
        // ============================================

        function showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;

            // Clear any existing state
            toast.classList.remove('visible', 'hiding');
            toast.textContent = message;

            // Show toast
            requestAnimationFrame(() => {
                toast.classList.add('visible');
            });

            // Auto-dismiss after 3s
            setTimeout(() => {
                toast.classList.add('hiding');
                toast.classList.remove('visible');
            }, 3000);
        }

        function toggleAnalysis() {
            if (!tennisAI || !tennisAI.isReady) return;
            
            if (tennisAI.isAnalyzing) {
                tennisAI.stopAnalysis();
            } else {
                tennisAI.startAnalysis();
            }
        }

        function resetSession() {
            if (tennisAI) {
                tennisAI.resetSession();
            }
            // Reset ghost session tracking
            if (typeof ghostOverlay !== 'undefined') {
                ghostOverlay.resetSession();
            }
            // Clear replay recordings
            if (tennisAI?.replayManager) {
                tennisAI.replayManager.clearReplays();
            }
        }

        async function flipCamera() {
            if (!tennisAI) return;
            const wasAnalyzing = tennisAI.isAnalyzing;
            if (wasAnalyzing) tennisAI.stopAnalysis();

            // Stop MediaPipe camera loop
            if (tennisAI.camera) {
                tennisAI.camera.stop();
            }

            tennisAI.currentFacingMode = tennisAI.currentFacingMode === 'user' ? 'environment' : 'user';
            await tennisAI.setupCamera();

            if (wasAnalyzing) tennisAI.startAnalysis();
        }

        // Ghost Overlay Toggle
        function toggleGhost() {
            if (typeof ghostOverlay === 'undefined') return;

            const enabled = ghostOverlay.toggle();
            const btn = document.getElementById('ghostBtn');
            const label = document.getElementById('ghostBtnLabel');
            const display = document.getElementById('ghostSimilarityDisplay');

            if (enabled) {
                // Check if we have a ghost to show
                if (!ghostOverlay.ghostStroke) {
                    // Try to use best stroke from this session
                    if (!ghostOverlay.useBestStroke()) {
                        // No ghost available
                        alert('No ghost available yet. Complete some strokes first, and your best one will become the ghost.');
                        ghostOverlay.toggle(); // Turn back off
                        return;
                    }
                }

                btn.classList.add('active');
                label.textContent = 'GHOST ON';
                display.style.display = 'block';
                ghostOverlay.play();

                // Show ghost info
                const info = ghostOverlay.getGhostInfo();
                if (info) {
                    console.log(`Ghost active: ${info.name} (${info.frameCount} frames)`);
                }
            } else {
                btn.classList.remove('active');
                label.textContent = 'GHOST';
                display.style.display = 'none';
                ghostOverlay.pause();
            }
        }

        // Lock current best stroke as ghost reference
        function lockCurrentGhost() {
            if (typeof ghostOverlay === 'undefined' || !ghostOverlay.bestStrokeThisSession) {
                alert('No stroke to lock. Complete some strokes first.');
                return;
            }

            const stroke = ghostOverlay.lockStroke(ghostOverlay.bestStrokeThisSession);
            alert(`Locked "${stroke.name}" as a saved ghost reference!`);
        }

        // Session Summary Modal
        function showSessionSummary(summary) {
            if (!summary) return;

            const duration = formatDuration(summary.duration);
            const improvementClass = summary.improvement > 0 ? 'positive' :
                                     summary.improvement < 0 ? 'negative' : 'neutral';
            const improvementText = summary.improvement > 0 ? `+${summary.improvement}` :
                                    summary.improvement < 0 ? `${summary.improvement}` : '0';

            let html = `
                <div class="summary-stats">
                    <div class="summary-stat highlight">
                        <div class="summary-stat-value">${summary.averageScore}</div>
                        <div class="summary-stat-label">Average Score</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${summary.totalStrokes}</div>
                        <div class="summary-stat-label">Total Strokes</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${duration}</div>
                        <div class="summary-stat-label">Duration</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${summary.bestScore}</div>
                        <div class="summary-stat-label">Best Stroke</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${summary.consistency}</div>
                        <div class="summary-stat-label">Consistency</div>
                    </div>
                </div>

                <div class="summary-section">
                    <div class="summary-section-title">Session Trend</div>
                    <span class="improvement-badge ${improvementClass}">
                        ${summary.improvement > 0 ? '' : summary.improvement < 0 ? '' : ''}
                        ${improvementText} points from start to finish
                    </span>
                </div>
            `;

            if (summary.weaknesses && summary.weaknesses.length > 0) {
                html += `
                    <div class="summary-section">
                        <div class="summary-section-title">Areas to Improve</div>
                        ${summary.weaknesses.map(w => `<span class="weakness-tag">${w}</span>`).join('')}
                    </div>
                `;
            }

            if (summary.drillRecommendation) {
                html += `
                    <div class="summary-section">
                        <div class="summary-section-title">Recommended Drill</div>
                        <div class="drill-card">
                            <div class="drill-name">${summary.drillRecommendation.name}</div>
                            <div class="drill-description">${summary.drillRecommendation.description}</div>
                            <div class="drill-duration">${summary.drillRecommendation.duration}</div>
                        </div>
                    </div>
                `;
            }

            // Show coach's notebook notes
            if (summary.coachNotes) {
                html += `
                    <div class="summary-section">
                        <div class="summary-section-title">Coach's Notes</div>
                        <div style="font-style: italic; color: rgba(255,255,255,0.8); font-size: 14px;
                                    line-height: 1.6; padding: 12px 16px; background: rgba(255,255,255,0.05);
                                    border-radius: 8px; border-left: 3px solid var(--accent-volt);">
                            "${summary.coachNotes}"
                        </div>
                    </div>
                `;
            }

            // Show coaching plan / next session goal
            const plan = summary.coachingPlan || (typeof improvementTracker !== 'undefined' ? improvementTracker.getCoachingPlan() : null);
            if (plan?.focusAreas?.length > 0) {
                html += `
                    <div class="summary-section">
                        <div class="summary-section-title">Improvement Plan</div>
                        ${plan.focusAreas.map(f => `
                            <div style="padding: 10px 14px; margin-bottom: 8px; background: rgba(255,255,255,0.05);
                                        border-radius: 8px; border-left: 3px solid #4FC3F7;">
                                <div style="font-weight: 600; color: #4FC3F7; font-size: 14px; margin-bottom: 4px;">${f.area}</div>
                                <div style="color: rgba(255,255,255,0.7); font-size: 13px; line-height: 1.4;">
                                    ${f.why || ''}${f.drill ? ` Drill: ${f.drill}` : ''}
                                </div>
                            </div>
                        `).join('')}
                        ${plan.sessionGoal ? `
                            <div style="margin-top: 10px; padding: 10px 14px; background: rgba(200,230,255,0.08);
                                        border-radius: 8px; font-size: 14px; color: rgba(255,255,255,0.9);">
                                Next session goal: ${plan.sessionGoal}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Show milestones if any achieved
            if (summary.milestones && summary.milestones.length > 0) {
                html += `
                    <div class="summary-section">
                        <div class="summary-section-title">Milestones Achieved!</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                            ${summary.milestones.map(m => `
                                <span style="background: linear-gradient(135deg, var(--accent-volt), #a0cc00); color: #0A0A0A; padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 13px;">
                                    ${m.label}
                                </span>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            document.getElementById('sessionSummaryContent').innerHTML = html;

            // Add stroke review grid if replays are available
            const summaryContent = document.getElementById('sessionSummaryContent');
            if (typeof buildStrokeReviewGrid === 'function') {
                buildStrokeReviewGrid(summaryContent);
            }

            document.getElementById('sessionSummaryModal').classList.add('visible');
        }

        function closeSessionSummary() {
            document.getElementById('sessionSummaryModal').classList.remove('visible');
        }

        // Analytics Modal
        function showAnalytics() {
            if (typeof sessionStorage === 'undefined' || !sessionStorage.getAggregatedStats) {
                alert('Session history not available');
                return;
            }

            const stats = sessionStorage.getAggregatedStats();
            const history = sessionStorage.getSessionHistory();

            // Get player profile stats
            let profileStats = null;
            if (typeof playerProfile !== 'undefined') {
                profileStats = playerProfile.getPlayerStats();
            }

            let html = '';

            if (!stats || stats.totalSessions === 0) {
                html = `
                    <div style="text-align: center; padding: 40px 20px; color: rgba(255,255,255,0.7);">
                        <div style="font-size: 24px; font-weight: bold; margin-bottom: 16px; letter-spacing: 2px;">STATS</div>
                        <div style="font-size: 16px;">No session history yet</div>
                        <div style="font-size: 14px; margin-top: 8px;">Complete a practice session to see your stats</div>
                    </div>
                `;
            } else {
                const trendIcon = stats.trend === 'improving' ? '' :
                                  stats.trend === 'declining' ? '' : '';
                const trendClass = stats.trend === 'improving' ? 'positive' :
                                   stats.trend === 'declining' ? 'negative' : 'neutral';

                html = `
                    <div class="summary-stats">
                        <div class="summary-stat highlight">
                            <div class="summary-stat-value">${stats.overallAverage}</div>
                            <div class="summary-stat-label">Avg Score (All Time)</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${stats.totalSessions}</div>
                            <div class="summary-stat-label">Sessions</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">${stats.totalStrokes}</div>
                            <div class="summary-stat-label">Total Strokes</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value" style="text-transform: capitalize;">${stats.mostPracticed}</div>
                            <div class="summary-stat-label">Most Practiced</div>
                        </div>
                        <div class="summary-stat">
                            <div class="summary-stat-value">
                                <span class="improvement-badge ${trendClass}">${trendIcon} ${stats.trend}</span>
                            </div>
                            <div class="summary-stat-label">Trend</div>
                        </div>
                    </div>
                `;

                if (stats.bestSession) {
                    const bestDate = new Date(stats.bestSession.date).toLocaleDateString();
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Personal Best</div>
                            <div class="drill-card">
                                <div class="drill-name">${stats.bestSession.score} Average Score</div>
                                <div class="drill-description">Achieved on ${bestDate}</div>
                            </div>
                        </div>
                    `;
                }

                // Player Profile: Milestones
                if (profileStats && profileStats.milestones && profileStats.milestones.length > 0) {
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Milestones</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                ${profileStats.milestones.slice(0, 6).map(m => `
                                    <span style="background: rgba(205, 255, 0, 0.2); color: var(--accent-volt); padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: 600;">
                                        ${m.label}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // Player Profile: Areas to Improve
                if (profileStats && profileStats.weaknesses && profileStats.weaknesses.length > 0) {
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Focus Areas</div>
                            ${profileStats.weaknesses.slice(0, 3).map(w => `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-bottom: 6px;">
                                    <span style="color: white;">${w.name}</span>
                                    <span style="font-size: 12px; color: ${w.improving ? 'var(--accent-volt)' : 'rgba(255,255,255,0.5)'};">
                                        ${w.improving ? ' Improving' : `${w.count} sessions`}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // Player Profile: Stroke Proficiency
                if (profileStats && profileStats.strokeProficiency) {
                    const strokes = Object.entries(profileStats.strokeProficiency)
                        .filter(([_, data]) => data.attempts > 0)
                        .sort((a, b) => b[1].avgScore - a[1].avgScore);

                    if (strokes.length > 0) {
                        html += `
                            <div class="summary-section">
                                <div class="summary-section-title">Stroke Proficiency</div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    ${strokes.map(([type, data]) => `
                                        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; text-align: center;">
                                            <div style="font-size: 20px; font-weight: bold; color: var(--accent-volt);">${Math.round(data.avgScore)}</div>
                                            <div style="font-size: 12px; color: white;">${type}</div>
                                            <div style="font-size: 10px; color: rgba(255,255,255,0.5);">${data.attempts} strokes</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                }

                // Recent Sessions
                if (history.length > 0) {
                    html += `
                        <div class="summary-section">
                            <div class="summary-section-title">Recent Sessions</div>
                            <div style="max-height: 200px; overflow-y: auto;">
                    `;

                    history.slice(0, 10).forEach(session => {
                        const date = new Date(session.date).toLocaleDateString();
                        const time = new Date(session.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        const s = session.summary;

                        if (s) {
                            html += `
                                <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <div style="font-weight: bold; color: white;">${date} ${time}</div>
                                            <div style="font-size: 12px; color: rgba(255,255,255,0.6);">
                                                ${s.totalStrokes} strokes  ${formatDuration(s.duration)}
                                            </div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 24px; font-weight: bold; color: var(--accent-volt, #CDFF00);">${s.averageScore}</div>
                                            <div style="font-size: 10px; color: rgba(255,255,255,0.6);">${s.consistency}</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    });

                    html += `</div></div>`;
                }
            }

            document.getElementById('analyticsContent').innerHTML = html;
            document.getElementById('analyticsModal').classList.add('visible');
        }

        function closeAnalytics() {
            document.getElementById('analyticsModal').classList.remove('visible');
        }

        // ========================================
        // Challenge Mode Functions
        // ========================================

        function showChallenges() {
            renderChallengesList();
            document.getElementById('challengesModal').classList.add('visible');
        }

        function closeChallenges() {
            document.getElementById('challengesModal').classList.remove('visible');
        }

        function renderChallengesList() {
            if (typeof challengeMode === 'undefined') return;

            const challenges = challengeMode.getAvailableChallenges();
            const stats = challengeMode.getStats();

            let html = `
                <div style="margin-bottom: 16px; text-align: center;">
                    <div style="font-size: 24px; font-weight: 800; color: var(--accent-volt);">${stats.completed}/${stats.total}</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Challenges Completed</div>
                </div>
            `;

            challenges.forEach(challenge => {
                const statusClass = challenge.isCompleted ? 'completed' : (challenge.isActive ? 'active' : '');
                const badge = challenge.isCompleted ? 'DONE' : (challenge.isActive ? 'Active' : '');

                html += `
                    <div class="challenge-card ${statusClass}" onclick="startChallenge('${challenge.id}')">
                        <div class="challenge-card-header">
                            <span class="challenge-card-icon">${challenge.icon}</span>
                            <span class="challenge-card-title">${challenge.name}</span>
                            ${badge ? `<span class="challenge-card-badge">${badge}</span>` : ''}
                        </div>
                        <div class="challenge-card-desc">${challenge.description}</div>
                        <span class="challenge-card-difficulty ${challenge.difficulty}">${challenge.difficulty}</span>
                    </div>
                `;
            });

            document.getElementById('challengesContent').innerHTML = html;
        }

        function startChallenge(challengeId) {
            if (typeof challengeMode === 'undefined') return;

            // Don't start if already completed
            if (challengeMode.isCompleted(challengeId)) {
                return;
            }

            const challenge = challengeMode.startChallenge(challengeId);
            if (challenge) {
                closeChallenges();
                updateActiveChallengeBar();
            }
        }

        function updateActiveChallengeBar() {
            if (typeof challengeMode === 'undefined') return;

            const challengeBar = document.getElementById('activeChallengeBar');
            const info = challengeMode.getActiveChallengeInfo();

            if (!info) {
                challengeBar.style.display = 'none';
                return;
            }

            challengeBar.style.display = 'flex';
            document.getElementById('activeChallengeIcon').textContent = info.icon;
            document.getElementById('activeChallengeName').textContent = info.name;
            document.getElementById('activeChallengeText').textContent = `${info.progress}/${info.target}`;

            const progressPercent = (info.progress / info.target) * 100;
            document.getElementById('activeChallengeProgress').style.width = `${progressPercent}%`;
        }

        function recordChallengeStroke(strokeData) {
            if (typeof challengeMode === 'undefined' || !challengeMode.activeChallenge) return;

            const result = challengeMode.recordStroke(strokeData);

            if (result) {
                updateActiveChallengeBar();

                if (result.complete) {
                    showChallengeComplete(result.challenge);
                }
            }
        }

        function showChallengeComplete(challenge) {
            document.getElementById('completedChallengeName').textContent = challenge.name;
            document.getElementById('completedChallengeReward').textContent = `Reward: ${challenge.reward}`;
            document.getElementById('challengeCompleteOverlay').style.display = 'flex';

            // Hide challenge bar
            document.getElementById('activeChallengeBar').style.display = 'none';
        }

        function closeChallengeComplete() {
            document.getElementById('challengeCompleteOverlay').style.display = 'none';
        }

        // ========================================
        // Drill Mode Functions
        // ========================================

        let lastDrillId = null;

        function showDrillSelection() {
            renderDrillList();
            document.getElementById('drillModal').classList.add('visible');
        }

        function closeDrillModal() {
            document.getElementById('drillModal').classList.remove('visible');
        }

        function renderDrillList() {
            if (typeof drillMode === 'undefined') return;

            const skillLevel = tennisAI?.playerProfile?.skillLevel || 'intermediate';
            let html = '';

            // Auto drill from improvement plan
            const autoDrill = drillMode.buildAutoDrill(skillLevel);
            if (autoDrill) {
                html += `
                    <div class="drill-card-badge">Recommended from your plan</div>
                    <div class="drill-card recommended" onclick="startDrill('auto')">
                        <div class="drill-card-header">
                            <span class="drill-card-name">${autoDrill.name}</span>
                            <span class="drill-card-reps">${autoDrill.totalReps} reps</span>
                        </div>
                        <div class="drill-card-desc">${autoDrill.description}</div>
                        <div class="drill-card-meta">
                            ${autoDrill.strokeType ? `<span class="drill-card-stroke">${autoDrill.strokeType}</span>` : '<span class="drill-card-stroke">Any stroke</span>'}
                            <span class="drill-card-target">Target: ${autoDrill.target}${autoDrill.unit ? ' ' + autoDrill.unit : ''}</span>
                        </div>
                    </div>
                `;
            }

            // Predefined drills
            Object.values(drillMode.drills).forEach(drill => {
                const target = drill.targets?.[skillLevel] || drill.targets?.intermediate;
                const strokeLabel = drill.strokeType || (drill.acceptedTypes ? drill.acceptedTypes.join('/') : 'Any');
                html += `
                    <div class="drill-card" onclick="startDrill('${drill.id}')">
                        <div class="drill-card-header">
                            <span class="drill-card-name">${drill.name}</span>
                            <span class="drill-card-reps">${drill.totalReps} reps</span>
                        </div>
                        <div class="drill-card-desc">${drill.description}</div>
                        <div class="drill-card-meta">
                            <span class="drill-card-stroke">${strokeLabel}</span>
                            <span class="drill-card-target">Target: ${target}${drill.unit ? ' ' + drill.unit : ''}</span>
                        </div>
                    </div>
                `;
            });

            document.getElementById('drillListContent').innerHTML = html;
        }

        function startDrill(drillId) {
            if (typeof drillMode === 'undefined') return;

            const skillLevel = tennisAI?.playerProfile?.skillLevel || 'intermediate';
            const drill = drillMode.startDrill(drillId, skillLevel);
            if (!drill) return;

            lastDrillId = drillId;
            closeDrillModal();

            // Ensure practice mode
            if (currentMode !== 'practice') {
                switchMode('practice');
            }

            // Auto-start analysis if not running
            if (tennisAI && !tennisAI.isAnalyzing) {
                tennisAI.startAnalysis();
            }

            showDrillHUD(drill);
        }

        function showDrillHUD(drill) {
            const hud = document.getElementById('drillHUD');
            document.getElementById('drillHudName').textContent = drill.name;
            document.getElementById('drillProgressText').textContent = `0/${drill.totalReps}`;
            document.getElementById('drillProgressFill').style.width = '0%';
            document.getElementById('drillMetricDisplay').style.display = 'none';
            document.getElementById('drillMetricLabel').textContent = drill.metricLabel;
            document.getElementById('drillMetricTarget').textContent = `Target: ${drill.target}${drill.unit ? ' ' + drill.unit : ''}`;
            renderRepDots(drill);
            hud.style.display = 'flex';

            // Hide challenge bar if active
            document.getElementById('activeChallengeBar').style.display = 'none';
        }

        function renderRepDots(drill) {
            let html = '';
            for (let i = 0; i < drill.totalReps; i++) {
                html += `<div class="drill-rep-dot" id="drillDot${i}"></div>`;
            }
            document.getElementById('drillRepDots').innerHTML = html;
        }

        function recordDrillStroke(strokeData) {
            if (typeof drillMode === 'undefined' || !drillMode.isActive) return;

            const result = drillMode.recordStroke(strokeData);
            if (!result) return;

            if (result.wrongType) {
                showDrillWrongType(result.expectedType);
                return;
            }

            if (result.error) return;

            updateDrillHUD(result);

            if (result.isComplete) {
                setTimeout(() => showDrillSummary(), 800);
            }
        }

        function updateDrillHUD(result) {
            // Update progress
            const pct = (result.rep / result.totalReps) * 100;
            document.getElementById('drillProgressFill').style.width = `${pct}%`;
            document.getElementById('drillProgressText').textContent = `${result.rep}/${result.totalReps}`;

            // Show big metric value with pop animation
            const metricDisplay = document.getElementById('drillMetricDisplay');
            const metricValue = document.getElementById('drillMetricValue');
            const valueStr = result.metricValue < 10 ? result.metricValue.toFixed(1) : Math.round(result.metricValue);

            metricDisplay.style.display = 'block';
            metricValue.textContent = valueStr;

            // Color based on distance from target
            metricValue.classList.remove('at-target', 'close', 'far');
            if (result.hitTarget) {
                metricValue.classList.add('at-target');
            } else if (result.metricValue >= result.target * 0.8) {
                metricValue.classList.add('close');
            } else {
                metricValue.classList.add('far');
            }

            // Re-trigger pop animation
            metricDisplay.style.animation = 'none';
            metricDisplay.offsetHeight; // force reflow
            metricDisplay.style.animation = 'drillMetricPop 0.3s ease';

            // Update rep dot
            const dotIdx = result.rep - 1;
            const dot = document.getElementById(`drillDot${dotIdx}`);
            if (dot) {
                const dotValue = result.metricValue < 10 ? result.metricValue.toFixed(0) : Math.round(result.metricValue);
                dot.textContent = dotValue;
                if (result.hitTarget) {
                    dot.classList.add('hit');
                } else if (result.metricValue >= result.target * 0.8) {
                    dot.classList.add('close');
                } else {
                    dot.classList.add('miss');
                }
            }

            // Auto-hide metric after 3s
            clearTimeout(window._drillMetricTimeout);
            window._drillMetricTimeout = setTimeout(() => {
                metricDisplay.style.display = 'none';
            }, 3000);
        }

        function showDrillWrongType(expectedType) {
            // Remove any existing wrong-type indicator
            const existing = document.querySelector('.drill-hud-wrong-type');
            if (existing) existing.remove();

            const indicator = document.createElement('div');
            indicator.className = 'drill-hud-wrong-type';
            indicator.textContent = `Need: ${expectedType}`;
            document.body.appendChild(indicator);

            setTimeout(() => indicator.remove(), 1500);
        }

        function showDrillSummary() {
            const summary = drillMode.stopDrill();
            if (!summary) return;

            document.getElementById('drillHUD').style.display = 'none';

            // Populate summary
            document.getElementById('drillSummaryName').textContent = summary.drillName;

            // Stats row
            const hitPct = summary.totalReps > 0 ? Math.round((summary.repsAtTarget / summary.totalReps) * 100) : 0;
            document.getElementById('drillSummaryStats').innerHTML = `
                <div class="drill-stat">
                    <div class="drill-stat-value">${summary.average < 10 ? summary.average.toFixed(1) : Math.round(summary.average)}</div>
                    <div class="drill-stat-label">Average${summary.unit ? ' (' + summary.unit + ')' : ''}</div>
                </div>
                <div class="drill-stat">
                    <div class="drill-stat-value">${summary.repsAtTarget}/${summary.totalReps}</div>
                    <div class="drill-stat-label">At Target</div>
                </div>
                <div class="drill-stat">
                    <div class="drill-stat-value">${summary.best < 10 ? summary.best.toFixed(1) : Math.round(summary.best)}</div>
                    <div class="drill-stat-label">Best</div>
                </div>
            `;

            // Bar chart
            const maxVal = Math.max(summary.target * 1.3, summary.best * 1.1);
            let chartHtml = '';
            summary.scores.forEach((score, i) => {
                const heightPct = Math.max(5, (score.value / maxVal) * 100);
                let barClass = 'miss';
                if (score.value >= summary.target) barClass = 'hit';
                else if (score.value >= summary.target * 0.8) barClass = 'close';

                chartHtml += `<div class="drill-chart-bar ${barClass}" style="height: ${heightPct}%"></div>`;
            });

            // Target line
            const targetPct = (summary.target / maxVal) * 100;
            chartHtml += `<div class="drill-chart-target-line" style="bottom: ${targetPct}%; position: absolute; left: 0; right: 0;"></div>`;

            document.getElementById('drillSummaryChart').innerHTML = chartHtml;
            document.getElementById('drillSummaryChart').style.position = 'relative';

            // Trend text
            const trendText = summary.trend === 'improving' ? 'Trending up across reps' :
                             summary.trend === 'declining' ? 'Consistency dropped toward the end' :
                             'Consistent performance throughout';
            const trendEl = document.querySelector('.drill-summary-trend');
            if (trendEl) {
                trendEl.textContent = trendText;
            } else {
                // Insert trend before actions
                const actions = document.querySelector('.drill-summary-actions');
                if (actions) {
                    const div = document.createElement('div');
                    div.className = 'drill-summary-trend';
                    div.textContent = trendText;
                    actions.parentNode.insertBefore(div, actions);
                }
            }

            document.getElementById('drillSummaryOverlay').style.display = 'flex';
        }

        function closeDrillSummary() {
            document.getElementById('drillSummaryOverlay').style.display = 'none';
        }

        function repeatDrill() {
            closeDrillSummary();
            if (lastDrillId) {
                startDrill(lastDrillId);
            }
        }

        function stopDrill() {
            if (typeof drillMode !== 'undefined' && drillMode.isActive) {
                showDrillSummary();
            }
        }

        // ========================================
        // Pro Comparison Functions
        // ========================================

        let selectedPro = null;

        function showProComparison() {
            document.getElementById('proComparisonModal').classList.add('visible');
            updateProComparisonDisplay();
        }

        function closeProComparison() {
            document.getElementById('proComparisonModal').classList.remove('visible');
        }

        function selectPro(proId) {
            selectedPro = proId;

            // Update UI selection
            document.querySelectorAll('.pro-card').forEach(card => card.classList.remove('selected'));
            document.getElementById(`pro-${proId}`).classList.add('selected');

            updateProComparisonDisplay();
        }

        function updateProComparisonDisplay() {
            const resultsDiv = document.getElementById('proComparisonResults');
            const emptyDiv = document.getElementById('proComparisonEmpty');
            const detailsDiv = document.getElementById('proComparisonDetails');
            const tipDiv = document.getElementById('proCoachingTip');

            // Check if we have stroke data
            if (!tennisAI || !tennisAI.enhancedAnalyzer || tennisAI.enhancedAnalyzer.sessionStats.totalStrokes === 0) {
                resultsDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                return;
            }

            if (!selectedPro) {
                resultsDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                emptyDiv.innerHTML = '<div style="font-size: 14px;">Select a pro above to compare your technique.</div>';
                return;
            }

            emptyDiv.style.display = 'none';
            resultsDiv.style.display = 'block';

            // Get pro profile and user's recent stroke data
            const proReferences = tennisAI.enhancedAnalyzer.proReferences;
            const proProfile = proReferences.getPlayerProfile(selectedPro);
            const lastStroke = tennisAI.enhancedAnalyzer.lastStrokeData;

            if (!lastStroke || !proProfile) {
                resultsDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                emptyDiv.innerHTML = '<div style="font-size: 14px;">Complete a stroke to see comparison.</div>';
                return;
            }

            // Get comparison data
            const comparison = lastStroke.proComparison;
            const similarity = comparison ? Math.round(comparison.overallSimilarity * 100) : 0;

            // Update similarity score
            document.getElementById('proSimilarityScore').textContent = `${similarity}%`;

            // Build comparison details
            let html = '<div class="comparison-metrics">';

            // Velocity comparison
            const velRatio = comparison?.velocityRatio || 0;
            html += buildComparisonMetric('Racquet Speed', velRatio, 'velocity');

            // Acceleration comparison
            const accRatio = comparison?.accelerationRatio || 0;
            html += buildComparisonMetric('Acceleration', accRatio, 'acceleration');

            // Rotation comparison
            const rotRatio = comparison?.rotationRatio || 0;
            html += buildComparisonMetric('Body Rotation', rotRatio, 'rotation');

            html += '</div>';

            // Strengths and improvements
            if (comparison) {
                if (comparison.strengths.length > 0) {
                    html += `<div style="margin-top: 16px;">
                        <div style="font-size: 11px; text-transform: uppercase; color: var(--accent-volt); margin-bottom: 8px;">Your Strengths</div>
                        <div style="font-size: 13px; color: white;">${comparison.strengths.join('  ')}</div>
                    </div>`;
                }

                if (comparison.improvements.length > 0) {
                    html += `<div style="margin-top: 12px;">
                        <div style="font-size: 11px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 8px;">Focus Areas</div>
                        <div style="font-size: 13px; color: white;">${comparison.improvements.join('  ')}</div>
                    </div>`;
                }
            }

            detailsDiv.innerHTML = html;

            // Coaching tip based on pro style
            const proTips = {
                federer: `To develop Federer-like technique, focus on fluid motion and early preparation. His forehand is built on timing and effortless power, not muscling the ball.`,
                djokovic: `Djokovic's game is built on flexibility and consistency. Work on staying low through contact and maximizing your court coverage.`,
                nadal: `To hit like Nadal, focus on extreme topspin and aggressive hip rotation. His lasso forehand comes from tremendous racquet head speed generated by the whole body.`,
                serena: `Serena's power comes from explosive leg drive and core rotation. Focus on loading your legs and driving up through the shot.`
            };

            tipDiv.innerHTML = `<div style="font-size: 13px; color: white;">${proTips[selectedPro] || 'Study the pro\'s technique and work on matching their form.'}</div>`;
        }

        function buildComparisonMetric(label, ratio, type) {
            const percent = Math.round(ratio * 100);
            const diff = percent - 100;
            const diffClass = diff >= 0 ? 'positive' : 'negative';
            const diffText = diff >= 0 ? `+${diff}%` : `${diff}%`;

            return `
                <div class="comparison-metric">
                    <div class="comparison-metric-label">${label}</div>
                    <div class="comparison-metric-values">
                        <span class="comparison-you">${percent}%</span>
                        <span class="comparison-vs">of pro</span>
                        <span class="comparison-diff ${diffClass}">${diffText}</span>
                    </div>
                </div>
            `;
        }

        // ========================================
        // Analysis Mode Functions
        // ========================================

        let currentMode = 'practice';
        let analysisVideoElement = null;
        let selectedStroke = null;

        function switchMode(mode) {
            currentMode = mode;

            // Update button states
            document.getElementById('practiceModeBtn').classList.toggle('active', mode === 'practice');
            document.getElementById('analysisModeBtn').classList.toggle('active', mode === 'analysis');

            // Toggle containers
            const practiceElements = ['videoElement', 'canvasElement'];
            const analysisContainer = document.getElementById('analysisModeContainer');

            if (mode === 'practice') {
                analysisContainer.classList.remove('active');
                document.getElementById('videoElement').style.display = 'block';
                document.getElementById('canvasElement').style.display = 'block';
                document.querySelector('.coaching-panel').style.display = 'block';
                document.querySelector('.controls').style.display = 'flex';
            } else {
                analysisContainer.classList.add('active');
                document.getElementById('videoElement').style.display = 'none';
                document.getElementById('canvasElement').style.display = 'none';
                document.querySelector('.coaching-panel').style.display = 'none';
                document.querySelector('.controls').style.display = 'none';

                // Stop practice mode analysis if running
                if (tennisAI && tennisAI.isAnalyzing) {
                    tennisAI.stopAnalysis();
                }

                // Stop active drill when leaving practice mode
                if (typeof drillMode !== 'undefined' && drillMode.isActive) {
                    drillMode.stopDrill();
                    document.getElementById('drillHUD').style.display = 'none';
                }
            }
        }

        // Video Upload Handling
        function initVideoUpload() {
            const uploadZone = document.getElementById('videoUploadZone');
            const fileInput = document.getElementById('videoFileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    loadAnalysisVideo(file);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadAnalysisVideo(file);
                }
            });
        }

        async function loadAnalysisVideo(file) {
            const uploadZone = document.getElementById('videoUploadZone');
            const playerArea = document.getElementById('videoPlayerArea');
            const video = document.getElementById('analysisVideo');
            const progressOverlay = document.getElementById('analysisProgressOverlay');

            // Show player area
            uploadZone.classList.add('has-video');
            playerArea.classList.add('active');

            // Load video
            const url = URL.createObjectURL(file);
            video.src = url;
            analysisVideoElement = video;

            video.onloadedmetadata = async () => {
                // Set up canvas size
                const canvas = document.getElementById('analysisCanvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Update timeline
                updateTimelineDisplay();

                // Start analysis
                progressOverlay.classList.add('active');

                try {
                    await videoAnalyzer.initialize();
                    await videoAnalyzer.loadVideo(file);

                    const result = await videoAnalyzer.analyzeVideo((progress) => {
                        document.getElementById('analysisProgressFill').style.width = progress + '%';
                        document.getElementById('analysisProgressPercent').textContent = Math.round(progress) + '%';
                    });

                    // Add stroke markers to timeline
                    renderStrokeMarkers(result.strokes);

                    progressOverlay.classList.remove('active');
                } catch (error) {
                    console.error('Analysis failed:', error);
                    progressOverlay.classList.remove('active');
                    alert('Failed to analyze video: ' + error.message);
                }
            };

            // Set up video time update
            video.ontimeupdate = updateTimelineDisplay;
        }

        function updateTimelineDisplay() {
            const video = document.getElementById('analysisVideo');
            if (!video || !video.duration) return;

            const current = video.currentTime;
            const duration = video.duration;
            const percent = (current / duration) * 100;

            document.getElementById('timelineProgress').style.width = percent + '%';
            document.getElementById('timelinePlayhead').style.left = percent + '%';
            document.getElementById('timelineTime').textContent =
                `${formatVideoTime(current)} / ${formatVideoTime(duration)}`;
        }

        function formatVideoTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function renderStrokeMarkers(strokes) {
            const track = document.getElementById('timelineTrack');
            const video = document.getElementById('analysisVideo');

            // Remove existing markers
            track.querySelectorAll('.stroke-marker').forEach(m => m.remove());

            strokes.forEach((stroke, index) => {
                const marker = document.createElement('div');
                marker.className = `stroke-marker ${stroke.type}`;
                marker.style.left = `calc(${(stroke.time / video.duration) * 100}% - 4px)`;
                marker.title = `${stroke.type} - ${stroke.quality}`;
                marker.dataset.strokeIndex = index;

                marker.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectStroke(stroke, index);
                });

                track.appendChild(marker);
            });
        }

        let comparisonStrokes = [];

        function selectStroke(stroke, index) {
            selectedStroke = stroke;
            selectedStroke._index = index;

            // Update marker selection
            document.querySelectorAll('.stroke-marker').forEach(m => m.classList.remove('selected'));
            document.querySelector(`.stroke-marker[data-stroke-index="${index}"]`)?.classList.add('selected');

            // Seek video to stroke time
            const video = document.getElementById('analysisVideo');
            video.currentTime = stroke.time;

            // Show stroke details
            const panel = document.getElementById('strokeDetailsPanel');
            document.getElementById('strokeDetailType').textContent = stroke.type;
            document.getElementById('strokeDetailScore').textContent = Math.round(stroke.quality);
            document.getElementById('strokeDetailScore').style.color =
                stroke.quality >= 80 ? 'var(--accent-volt, #CDFF00)' :
                stroke.quality >= 60 ? '#FF9800' : '#f44336';
            document.getElementById('strokeDetailTime').textContent = formatVideoTime(stroke.time);
            document.getElementById('strokeDetailVelocity').textContent =
                (stroke.velocity * 100).toFixed(1);

            // Update compare button state
            const isInComparison = comparisonStrokes.some(s => s._index === index);
            document.getElementById('compareBtn').textContent = isInComparison ? 'ADDED' : '+ Compare';

            panel.classList.add('visible');
        }

        function hideStrokeDetails() {
            document.getElementById('strokeDetailsPanel').classList.remove('visible');
        }

        function addToComparison() {
            if (!selectedStroke) return;

            // Check if already in comparison
            const existingIndex = comparisonStrokes.findIndex(s => s._index === selectedStroke._index);
            if (existingIndex >= 0) {
                // Remove from comparison
                comparisonStrokes.splice(existingIndex, 1);
                document.getElementById('compareBtn').textContent = '+ Compare';
            } else if (comparisonStrokes.length < 2) {
                // Add to comparison
                comparisonStrokes.push({ ...selectedStroke });
                document.getElementById('compareBtn').textContent = 'ADDED';
            }

            // Update comparison panel
            if (comparisonStrokes.length === 2) {
                showComparison();
            } else if (comparisonStrokes.length < 2) {
                document.getElementById('comparisonPanel').classList.remove('visible');
            }
        }

        function showComparison() {
            const s1 = comparisonStrokes[0];
            const s2 = comparisonStrokes[1];

            const scoreDiff = s2.quality - s1.quality;
            const velocityDiff = ((s2.velocity - s1.velocity) / s1.velocity * 100).toFixed(0);

            const html = `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                    <!-- Stroke 1 -->
                    <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px;">
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase;">Stroke 1</div>
                        <div style="font-size: 24px; font-weight: bold; color: var(--accent-volt);">${Math.round(s1.quality)}</div>
                        <div style="font-size: 11px; color: white; text-transform: capitalize;">${s1.type}</div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5);">${formatVideoTime(s1.time)}</div>
                    </div>

                    <!-- VS / Diff -->
                    <div style="text-align: center; padding: 8px;">
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5);">DIFF</div>
                        <div style="font-size: 16px; font-weight: bold; color: ${scoreDiff >= 0 ? 'var(--accent-volt)' : '#f44336'};">
                            ${scoreDiff >= 0 ? '+' : ''}${Math.round(scoreDiff)}
                        </div>
                    </div>

                    <!-- Stroke 2 -->
                    <div style="text-align: center; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px;">
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase;">Stroke 2</div>
                        <div style="font-size: 24px; font-weight: bold; color: var(--accent-volt);">${Math.round(s2.quality)}</div>
                        <div style="font-size: 11px; color: white; text-transform: capitalize;">${s2.type}</div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.5);">${formatVideoTime(s2.time)}</div>
                    </div>
                </div>

                <div style="margin-top: 12px; font-size: 11px; color: rgba(255,255,255,0.7);">
                    Velocity: ${velocityDiff >= 0 ? '+' : ''}${velocityDiff}%
                </div>
            `;

            document.getElementById('comparisonContent').innerHTML = html;
            document.getElementById('comparisonPanel').classList.add('visible');
        }

        function clearComparison() {
            comparisonStrokes = [];
            document.getElementById('comparisonPanel').classList.remove('visible');
            document.getElementById('compareBtn').textContent = '+ Compare';
        }

        function exportHighlightReel() {
            const strokes = videoAnalyzer.detectedStrokes;
            if (!strokes || strokes.length === 0) {
                alert('No strokes detected to export');
                return;
            }

            // Get best 5 strokes
            const best5 = [...strokes]
                .sort((a, b) => b.quality - a.quality)
                .slice(0, 5);

            showExportModal('Best 5 Strokes', best5);
        }

        function exportBlooperReel() {
            const strokes = videoAnalyzer.detectedStrokes;
            if (!strokes || strokes.length === 0) {
                alert('No strokes detected to export');
                return;
            }

            // Get worst 5 strokes (for learning)
            const worst5 = [...strokes]
                .sort((a, b) => a.quality - b.quality)
                .slice(0, 5);

            showExportModal('Strokes to Improve', worst5);
        }

        function showExportModal(title, strokes) {
            const html = `
                <div style="max-height: 60vh; overflow-y: auto;">
                    <div style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 16px;">
                        Click on any stroke to jump to that moment in the video.
                    </div>
                    ${strokes.map((stroke, i) => `
                        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;"
                             onclick="jumpToStroke(${stroke.time})">
                            <div>
                                <div style="font-weight: bold; color: white;">#${i + 1} - ${stroke.type}</div>
                                <div style="font-size: 12px; color: rgba(255,255,255,0.6);">${formatVideoTime(stroke.time)}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 24px; font-weight: bold; color: ${stroke.quality >= 70 ? 'var(--accent-volt)' : stroke.quality >= 50 ? '#FF9800' : '#f44336'};">${Math.round(stroke.quality)}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <button class="btn" onclick="copyStrokeSummary(${JSON.stringify(strokes).replace(/"/g, '&quot;')})" style="width: 100%;">
                        Copy Summary to Clipboard
                    </button>
                </div>
            `;

            // Use session summary modal for this
            document.getElementById('sessionSummaryContent').innerHTML = `
                <div style="text-align: center; margin-bottom: 16px;">
                    <div style="font-size: 18px; font-weight: bold; color: var(--accent-volt);">${title}</div>
                </div>
                ${html}
            `;
            document.querySelector('#sessionSummaryModal .modal-title').textContent = 'Export';
            document.querySelector('#sessionSummaryModal .btn').style.display = 'none';
            document.getElementById('sessionSummaryModal').classList.add('visible');
        }

        function jumpToStroke(time) {
            const video = document.getElementById('analysisVideo');
            video.currentTime = time;
            closeSessionSummary();
        }

        function copyStrokeSummary(strokes) {
            const summary = strokes.map((s, i) =>
                `${i + 1}. ${s.type} at ${formatVideoTime(s.time)} - Score: ${Math.round(s.quality)}`
            ).join('\n');

            navigator.clipboard.writeText(summary).then(() => {
                alert('Summary copied to clipboard!');
            });
        }

        function toggleVideoPlayback() {
            const video = document.getElementById('analysisVideo');
            const btn = document.getElementById('timelinePlayBtn');

            if (video.paused) {
                video.play();
                btn.textContent = 'PAUSE';
            } else {
                video.pause();
                btn.textContent = 'PLAY';
            }
        }

        function clearAnalysisVideo() {
            const video = document.getElementById('analysisVideo');
            const uploadZone = document.getElementById('videoUploadZone');
            const playerArea = document.getElementById('videoPlayerArea');
            const strokePanel = document.getElementById('strokeDetailsPanel');

            // Reset video
            video.src = '';
            video.pause();

            // Hide player, show upload
            playerArea.classList.remove('active');
            uploadZone.classList.remove('has-video');
            strokePanel.classList.remove('visible');

            // Clear markers
            document.querySelectorAll('.stroke-marker').forEach(m => m.remove());

            // Clean up analyzer
            videoAnalyzer.destroy();

            selectedStroke = null;
        }

        // Timeline click to seek
        function initTimelineInteraction() {
            const track = document.getElementById('timelineTrack');

            track.addEventListener('click', (e) => {
                const video = document.getElementById('analysisVideo');
                if (!video || !video.duration) return;

                const rect = track.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                video.currentTime = percent * video.duration;
            });
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            initVideoUpload();
            initTimelineInteraction();
            initCalibrationUpload();
            initOnboarding();
        });

        // Initialize onboarding - detect returning users
        function initOnboarding() {
            try {
                // Check for saved API key
                const savedKey = localStorage.getItem('ace_openai_key');
                if (savedKey && savedKey.startsWith('sk-')) {
                    const input = document.getElementById('apiKeyInput');
                    if (input) {
                        // Mask all but last 4 characters
                        const masked = '' + savedKey.slice(-4);
                        input.value = savedKey;
                        input.classList.add('validated');

                        // Show checkmark
                        document.getElementById('apiCheckmark').classList.add('visible');
                    }
                }

                // Check if returning user with player profile
                if (typeof playerProfile !== 'undefined') {
                    const profile = playerProfile.profile;
                    if (profile && profile.sessionsPlayed > 0) {
                        // Update hero subtitle for returning user
                        const subtitle = document.getElementById('heroSubtitle');
                        if (subtitle) {
                            subtitle.textContent = 'WELCOME BACK';
                        }

                        // Show session count
                        const sessionCount = document.getElementById('heroSessionCount');
                        if (sessionCount) {
                            sessionCount.textContent = `SESSION #${profile.sessionsPlayed + 1}`;
                            sessionCount.style.display = 'block';
                        }

                        // Add progress card for users with 3+ sessions
                        if (profile.sessionsPlayed >= 3) {
                            const featureList = document.getElementById('featureList');
                            if (featureList) {
                                const progressCard = document.createElement('div');
                                progressCard.className = 'feature-card';
                                progressCard.innerHTML = `
                                    <div class="feature-icon">
                                        <svg viewBox="0 0 24 24">
                                            <polyline points="20 6 9 17 4 12"/>
                                        </svg>
                                    </div>
                                    <div class="feature-content">
                                        <div class="feature-title">${profile.sessionsPlayed} Sessions Logged</div>
                                        <div class="feature-desc">Your progress is saved</div>
                                    </div>
                                `;
                                featureList.appendChild(progressCard);
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('Onboarding init:', e);
            }
        }

        // ========================================
        // Calibration Functions
        // ========================================

        function openCalibrationModal() {
            document.getElementById('calibrationModal').classList.add('visible');
        }

        function closeCalibrationModal() {
            document.getElementById('calibrationModal').classList.remove('visible');
            if (typeof calibrationTool !== 'undefined') {
                calibrationTool.cancel();
            }
        }

        function initCalibrationUpload() {
            const uploadZone = document.getElementById('calibrationUploadZone');
            const fileInput = document.getElementById('calibrationFileInput');

            if (!uploadZone || !fileInput) return;

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.style.borderColor = 'var(--accent-volt, #CDFF00)';
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.style.borderColor = 'rgba(255,255,255,0.3)';
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.style.borderColor = 'rgba(255,255,255,0.3)';
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    startCalibration(file);
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    startCalibration(file);
                }
            });
        }

        async function startCalibration(file) {
            const label = document.getElementById('calibrationLabel').value;
            const player = document.getElementById('calibrationPlayer').value || 'unknown';

            // Show progress
            document.getElementById('calibrationUploadZone').style.display = 'none';
            document.getElementById('calibrationProgress').style.display = 'block';
            document.getElementById('calibrationResults').style.display = 'none';

            try {
                // Initialize calibration tool
                await calibrationTool.initialize();

                // Run calibration
                const results = await calibrationTool.calibrateFromVideo(file, {
                    label: label,
                    player: player,
                    onProgress: (progress) => {
                        document.getElementById('calibrationProgressBar').style.width = progress.progress + '%';
                        document.getElementById('calibrationStatus').textContent =
                            `Processing... ${progress.progress.toFixed(0)}%`;
                        document.getElementById('calibrationStrokeCount').textContent =
                            `${progress.strokesDetected} strokes detected`;
                    },
                    onStrokeDetected: (stroke, count) => {
                        console.log(`Calibration stroke #${count}: ${stroke.type}`);
                    }
                });

                // Show results
                displayCalibrationResults(results);

            } catch (error) {
                console.error('Calibration failed:', error);
                document.getElementById('calibrationStatus').textContent = 'Calibration failed: ' + error.message;
            }
        }

        function displayCalibrationResults(results) {
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrationResults').style.display = 'block';

            if (results.error) {
                document.getElementById('calibrationResults').innerHTML = `
                    <div style="color: #f44336; padding: 20px; text-align: center;">
                        ${results.error}
                    </div>
                `;
                return;
            }

            let html = `
                <div class="summary-stats" style="margin-bottom: 20px;">
                    <div class="summary-stat highlight">
                        <div class="summary-stat-value">${results.totalStrokes}</div>
                        <div class="summary-stat-label">Strokes Detected</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${results.label}</div>
                        <div class="summary-stat-label">Skill Level</div>
                    </div>
                    <div class="summary-stat">
                        <div class="summary-stat-value">${results.player}</div>
                        <div class="summary-stat-label">Player</div>
                    </div>
                </div>
            `;

            // Key metrics
            if (results.metrics) {
                html += `<div class="summary-section"><div class="summary-section-title">Key Metrics</div>`;
                html += `<div style="font-size: 13px; background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px;">`;

                const metricsToShow = ['velocity', 'acceleration', 'rotation', 'elbowAngle', 'hipShoulderSeparation'];
                for (const metric of metricsToShow) {
                    if (results.metrics[metric]) {
                        const m = results.metrics[metric];
                        html += `<div style="margin-bottom: 8px;">
                            <strong>${metric}:</strong>
                            avg=${m.avg.toFixed(4)}, range=[${m.min.toFixed(4)} - ${m.max.toFixed(4)}]
                        </div>`;
                    }
                }

                html += `</div></div>`;
            }

            // Recommended thresholds
            if (results.recommendedThresholds && Object.keys(results.recommendedThresholds).length > 0) {
                html += `<div class="summary-section"><div class="summary-section-title">Recommended Thresholds</div>`;
                html += `<div style="font-size: 12px; background: rgba(76,175,80,0.2); padding: 12px; border-radius: 8px; border: 1px solid rgba(76,175,80,0.3);">`;

                for (const [metric, data] of Object.entries(results.recommendedThresholds)) {
                    if (data.recommended) {
                        html += `<div style="margin-bottom: 8px;">
                            <strong>${metric}:</strong><br>
                            <span style="color: rgba(255,255,255,0.6);">Current:</span> ${JSON.stringify(data.current)}<br>
                            <span style="color: var(--accent-volt, #CDFF00);">Recommended:</span> ${JSON.stringify(data.recommended)}
                        </div>`;
                    }
                }

                html += `</div></div>`;
            }

            // Stroke type distribution
            if (results.distributions?.strokeTypes) {
                html += `<div class="summary-section"><div class="summary-section-title">Stroke Distribution</div>`;
                html += `<div style="display: flex; gap: 8px; flex-wrap: wrap;">`;
                for (const [type, count] of Object.entries(results.distributions.strokeTypes)) {
                    html += `<span style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                        ${type}: ${count}
                    </span>`;
                }
                html += `</div></div>`;
            }

            html += `
                <button class="btn" onclick="resetCalibrationUI()" style="width: 100%; margin-top: 16px;">
                    Calibrate Another Video
                </button>
            `;

            document.getElementById('calibrationResults').innerHTML = html;

            // Show threshold update section after successful calibration
            showThresholdUpdateSection();
        }

        function resetCalibrationUI() {
            document.getElementById('calibrationUploadZone').style.display = 'block';
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrationResults').style.display = 'none';
            document.getElementById('calibrationProgressBar').style.width = '0%';
            document.getElementById('calibrationFileInput').value = '';
            // Reset threshold update section
            document.getElementById('thresholdUpdateSection').style.display = 'none';
            document.getElementById('thresholdApplyStatus').textContent = '';
        }

        function showCalibrationStats() {
            if (typeof calibrationTool === 'undefined') return;

            const stats = calibrationTool.getAggregateStats();
            calibrationTool.printThresholdComparison();

            if (stats.error) {
                alert(stats.error);
                return;
            }

            alert(`Calibration Stats:\n\nTotal Runs: ${stats.totalRuns}\nTotal Strokes: ${stats.totalStrokes}\nLabels: ${stats.labels.join(', ')}\nPlayers: ${stats.players.join(', ')}\n\nSee console for detailed metrics.`);
        }

        function exportCalibrationData() {
            if (typeof calibrationTool !== 'undefined') {
                calibrationTool.exportCalibrationData();
            }
        }

        function applyThresholdsToApp() {
            const statusEl = document.getElementById('thresholdApplyStatus');

            if (typeof thresholdUpdater === 'undefined') {
                statusEl.textContent = 'ERROR: ThresholdUpdater not loaded';
                statusEl.style.color = '#f44336';
                return;
            }

            const result = thresholdUpdater.applyToRunningApp();

            if (result.success) {
                statusEl.innerHTML = `Applied ${result.updatedModules.length} module updates!<br>` +
                    result.updatedModules.map(m => ` ${m}`).join('<br>');
                statusEl.style.color = 'var(--accent-volt, #CDFF00)';
            } else {
                statusEl.textContent = `FAILED: ${result.error}`;
                statusEl.style.color = '#f44336';
            }
        }

        function exportThresholdUpdates() {
            if (typeof thresholdUpdater === 'undefined') {
                alert('ThresholdUpdater not loaded');
                return;
            }

            thresholdUpdater.exportUpdates();
        }

        function showThresholdUpdateSection() {
            const section = document.getElementById('thresholdUpdateSection');
            if (section && calibrationTool && calibrationTool.calibrationRuns.length > 0) {
                section.style.display = 'block';
            }
        }

        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            if (minutes === 0) return `${remainingSeconds}s`;
            return `${minutes}m ${remainingSeconds}s`;
        }

        // Stroke quality flash function
        function flashStrokeQuality(qualityScore) {
            const overlay = document.getElementById('strokeFlashOverlay');

            // Remove existing classes
            overlay.classList.remove('flash', 'great', 'good', 'needs-work');

            // Force reflow to restart animation
            void overlay.offsetWidth;

            // Add appropriate quality class
            if (qualityScore >= 80) {
                overlay.classList.add('great');
            } else if (qualityScore >= 60) {
                overlay.classList.add('good');
            } else {
                overlay.classList.add('needs-work');
            }

            // Trigger flash animation
            overlay.classList.add('flash');
        }

        // ============================================
        // REPLAY FUNCTIONS
        // ============================================
        let replayBtnTimeout = null;

        function showReplayButton(index) {
            const btn = document.getElementById('replayBtn');
            if (!btn) return;
            btn.dataset.index = index;
            btn.classList.add('visible');
            if (replayBtnTimeout) clearTimeout(replayBtnTimeout);
            replayBtnTimeout = setTimeout(() => {
                btn.classList.remove('visible');
            }, 5000);
        }

        function openReplay(index) {
            const overlay = document.getElementById('replayOverlay');
            const canvas = document.getElementById('replayCanvas');
            if (!overlay || !canvas || !window.tennisAI?.replayManager) return;

            const idx = parseInt(index, 10);
            const mgr = window.tennisAI.replayManager;
            if (idx < 0 || idx >= mgr.getReplayCount()) return;

            // Match canvas to main canvas dimensions
            const mainCanvas = document.getElementById('canvasElement');
            if (mainCanvas) {
                canvas.width = mainCanvas.width;
                canvas.height = mainCanvas.height;
            }

            overlay.classList.add('visible');
            const ctx = canvas.getContext('2d');

            mgr.startPlayback(idx, canvas, ctx, {
                speed: 0.5,
                loop: true,
                faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand
            });

            // Hide the replay button
            const btn = document.getElementById('replayBtn');
            if (btn) btn.classList.remove('visible');

            // Update speed button states
            updateSpeedButtons(0.5);
            document.getElementById('replayPlayPauseBtn').textContent = 'PAUSE';
        }

        function closeReplay() {
            const overlay = document.getElementById('replayOverlay');
            if (overlay) overlay.classList.remove('visible');
            if (window.tennisAI?.replayManager) {
                window.tennisAI.replayManager.stopPlayback();
            }
        }

        function toggleReplayPlayback() {
            if (!window.tennisAI?.replayManager) return;
            const mgr = window.tennisAI.replayManager;
            const paused = mgr.pausePlayback();
            document.getElementById('replayPlayPauseBtn').textContent = paused ? 'PLAY' : 'PAUSE';

            // If paused, redraw current frame
            if (paused) {
                const canvas = document.getElementById('replayCanvas');
                const ctx = canvas?.getContext('2d');
                const replay = mgr.getReplay(mgr.currentReplayIndex);
                if (replay && ctx) {
                    mgr.drawReplayFrame(ctx, canvas, replay, mgr.currentFrameIndex, {
                        faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                        dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand
                    });
                }
            }
        }

        function setReplaySpeed(speed) {
            if (!window.tennisAI?.replayManager) return;
            window.tennisAI.replayManager.setPlaybackSpeed(speed);
            updateSpeedButtons(speed);
        }

        function updateSpeedButtons(activeSpeed) {
            document.querySelectorAll('.replay-ctrl-btn[data-speed]').forEach(btn => {
                const s = parseFloat(btn.dataset.speed);
                btn.classList.toggle('active', s === activeSpeed);
            });
        }

        function replayStepFrame(delta) {
            if (!window.tennisAI?.replayManager) return;
            const mgr = window.tennisAI.replayManager;
            const replay = mgr.getReplay(mgr.currentReplayIndex);
            if (!replay) return;

            // Pause if playing
            if (!mgr.isPaused) {
                mgr.pausePlayback();
                document.getElementById('replayPlayPauseBtn').textContent = 'PLAY';
            }

            const newIdx = Math.max(0, Math.min(mgr.currentFrameIndex + delta, replay.frames.length - 1));
            mgr.currentFrameIndex = newIdx;

            const canvas = document.getElementById('replayCanvas');
            const ctx = canvas?.getContext('2d');
            if (ctx) {
                mgr.drawReplayFrame(ctx, canvas, replay, newIdx, {
                    faultLandmarkMap: window.tennisAI.faultLandmarkMap,
                    dominantHand: window.tennisAI.enhancedAnalyzer?.dominantHand
                });
            }
        }

        // Build stroke review grid for session summary
        function buildStrokeReviewGrid(container) {
            if (!window.tennisAI?.replayManager) return;
            const mgr = window.tennisAI.replayManager;
            if (mgr.getReplayCount() === 0) return;

            const section = document.createElement('div');
            section.style.marginTop = '16px';

            const title = document.createElement('div');
            title.textContent = 'Review Strokes';
            title.style.cssText = 'font-size: 14px; font-weight: 700; color: #F5F5F5; margin-bottom: 8px;';
            section.appendChild(title);

            const grid = document.createElement('div');
            grid.className = 'replay-grid';

            const replays = mgr.getAllReplays();
            replays.forEach((replay, idx) => {
                const q = replay.strokeData.quality;
                const bg = q >= 80 ? 'rgba(50, 215, 75, 0.2)'
                    : q >= 60 ? 'rgba(205, 255, 0, 0.2)'
                    : 'rgba(255, 59, 48, 0.2)';
                const color = q >= 80 ? '#32D74B' : q >= 60 ? '#CDFF00' : '#FF3B30';

                const item = document.createElement('div');
                item.className = 'replay-grid-item';
                item.style.background = bg;
                item.style.color = color;
                item.style.border = `1px solid ${color}33`;
                item.textContent = q;
                item.title = `${replay.strokeData.type} - ${q}/100`;
                item.onclick = () => openReplay(idx);
                grid.appendChild(item);
            });

            section.appendChild(grid);
            container.appendChild(section);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                // Close replay if open, otherwise toggle analysis
                const overlay = document.getElementById('replayOverlay');
                if (overlay?.classList.contains('visible')) {
                    toggleReplayPlayback();
                } else {
                    toggleAnalysis();
                }
            } else if (event.code === 'KeyR' && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                resetSession();
            } else if (event.code === 'Escape') {
                closeReplay();
            }
        });
    </script>
</body>
</html>